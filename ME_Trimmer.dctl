// ME_Ratio Shaper ver 1.0
//Made by Moaz Elgabry
#line 4


//functions for Transfer function conversion
 __DEVICE__ float3 LinToLogC3 (float3 in) {
    float3 out;

    float cut = 0.010591;
    float a = 5.555556;
    float b = 0.052272;
    float c = 0.247190;
    float d = 0.385537;
    float e = 5.367655;
    float f = 0.092809;

    out.x = (in.x > cut) ? c * log10(a * in.x + b) + d: e * in.x + f;
    out.y = (in.y > cut) ? c * log10(a * in.y + b) + d: e * in.y + f;
    out.z = (in.z > cut) ? c * log10(a * in.z + b) + d: e * in.z + f;

    return out;
    }
 
 __DEVICE__ float3 LogC3ToLin (float3 in) {
    float3 out;

    float cut = 0.010591;
    float a = 5.555556;
    float b = 0.052272;
    float c = 0.247190;
    float d = 0.385537;
    float e = 5.367655;
    float f = 0.092809;

    out.x = (in.x > e * cut + f) ? (_powf(10, (in.x - d) / c) - b) / a : (in.x - f) / e;
    out.y = (in.y > e * cut + f) ? (_powf(10, (in.y - d) / c) - b) / a : (in.y - f) / e;
    out.z = (in.z > e * cut + f) ? (_powf(10, (in.z - d) / c) - b) / a : (in.z - f) / e;

    return out;
    }//0
 
 __DEVICE__ float3 LinToDI (float3 in) {
    float3 out;

    float a = 0.0075;
    float b = 7.0;
    float c = 0.07329248;
    float m = 10.44426855;
    float lin_cut = 0.00262409;

    out.x = in.x > lin_cut ? (_log2f(in.x + a) + b) * c : out.x = in.x * m;
    out.y = in.y > lin_cut ? (_log2f(in.y + a) + b) * c : out.y = in.y * m;
    out.z = in.z > lin_cut ? (_log2f(in.z + a) + b) * c : out.z = in.z * m;

    return out;
    }
 
 __DEVICE__ float3 DItoLin (float3 in) {
    float3 out;

    float a = 0.0075;
    float b = 7.0;
    float c = 0.07329248;
    float m = 10.44426855;
    float log_cut = 0.02740668;

    out.x = in.x > log_cut ? _powf(2.f, (in.x / c) - b) - a : in.x / m;
    out.y = in.y > log_cut ? _powf(2.f, (in.y / c) - b) - a : in.y / m;
    out.z = in.z > log_cut ? _powf(2.f, (in.z / c) - b) - a : in.z / m;

    return out;
    }//2
 
 __DEVICE__ float3 LinToACEScct (float3 in) {
    float3 out;

    float a = 10.5402377416545;
    float b = 0.0729055341958355;
    float c = 9.72;
    float d = 17.52;
    float e = 0.0078125;

    out.x = in.x <= e ? a * in.x + b : (_log2f(in.x) + c) / d;
    out.y = in.y <= e ? a * in.y + b : (_log2f(in.y) + c) / d;
    out.z = in.z <= e ? a * in.z + b : (_log2f(in.z) + c) / d;

    return out;
    }
 
 __DEVICE__ float3 ACEScctToLin (float3 in) {
    float3 out;

    float a = 10.5402377416545;
    float b = 0.0729055341958355;
    float c = 9.72;
    float d = 17.52;
    float e = _log2f(65504);
    float lin_cut = 0.155251141552511;

    out.x = in.x <= lin_cut ? (in.x - b) / a : in.x < (e + c) / d ? _powf(2, in.x*d-c) : 65504;
    out.y = in.y <= lin_cut ? (in.y - b) / a : in.y < (e + c) / d ? _powf(2, in.y*d-c) : 65504;
    out.z = in.z <= lin_cut ? (in.z - b) / a : in.z < (e + c) / d ? _powf(2, in.z*d-c) : 65504;

    return out;
    }//3
 
 __DEVICE__ float3 LinToLogC4 (float3 in) {
    float3 out;

    float a = (_powf(2.0, 18.0) - 16.0) / 117.45;
    float b = (1023.0 - 95.0) / 1023.0;
    float c = 95.0 / 1023.0;
    float s = (7 * _logf(2) * _powf(2.0, 7 - 14 * c / b)) / (a * b);
    float t = (_powf(2.0, 14.0 * (-c / b) + 6.0) - 64.0) / a;

    out.x = in.x < t ? (in.x - t) / s : (_log2f( a * in.x + 64.0) - 6.0) / 14.0 * b + c;
    out.y = in.y < t ? (in.y - t) / s : (_log2f( a * in.y + 64.0) - 6.0) / 14.0 * b + c;
    out.z = in.z < t ? (in.z - t) / s : (_log2f( a * in.z + 64.0) - 6.0) / 14.0 * b + c;

    return out;
    }
 
 __DEVICE__ float3 LogC4ToLin (float3 in) {
    float3 out;

    float a = (_powf(2.0, 18.0) - 16.0) / 117.45;
    float b = (1023.0 - 95.0) / 1023.0;
    float c = 95.0 / 1023.0;
    float s = (7 * _logf(2) * _powf(2.0, 7 - 14 * c / b)) / (a * b);
    float t = (_powf(2.0, 14.0 * (-c / b) + 6.0) - 64.0) / a;

    out.x = in.x < 0.0 ? in.x * s + t : (_powf(2.0, 14.0 * (in.x - c) / b + 6.0) - 64.0) / a;
    out.y = in.y < 0.0 ? in.y * s + t : (_powf(2.0, 14.0 * (in.y - c) / b + 6.0) - 64.0) / a;
    out.z = in.z < 0.0 ? in.z * s + t : (_powf(2.0, 14.0 * (in.z - c) / b + 6.0) - 64.0) / a;

    return out;
    }//1
 
 __DEVICE__ float3 LinToDLog (float3 in) {
    float3 out;

    out.x = in.x <= 0.0078 ? 6.025 * in.x + 0.0929 : (_log10f(in.x * 0.9892 + 0.0108)) * 0.256663 + 0.584555;
    out.y = in.y <= 0.0078 ? 6.025 * in.y + 0.0929 : (_log10f(in.y * 0.9892 + 0.0108)) * 0.256663 + 0.584555;
    out.z = in.z <= 0.0078 ? 6.025 * in.z + 0.0929 : (_log10f(in.z * 0.9892 + 0.0108)) * 0.256663 + 0.584555;

    return out;
    }
 
 __DEVICE__ float3 DLogToLin (float3 in) {
    float3 out;

    out.x = in.x <= 0.14 ? (in.x - 0.0929) / 6.025 : (_powf(10, 3.89616 * in.x - 2.27752) - 0.0108) / 0.9892;
    out.y = in.y <= 0.14 ? (in.y - 0.0929) / 6.025 : (_powf(10, 3.89616 * in.y - 2.27752) - 0.0108) / 0.9892;
    out.z = in.z <= 0.14 ? (in.z - 0.0929) / 6.025 : (_powf(10, 3.89616 * in.z - 2.27752) - 0.0108) / 0.9892;

    return out;
    }
 
 __DEVICE__ float3 LinToFLog (float3 in) {
    float3 out;

    float a = 0.555556;
    float b = 0.009468;
    float c = 0.344676;
    float d = 0.790453;
    float e = 8.735631;
    float f = 0.092864;
    float cut = 0.00089;

    out.x = in.x >= cut ? c * _log10f(a * in.x + b) + d : e * in.x + f;
    out.y = in.y >= cut ? c * _log10f(a * in.y + b) + d : e * in.y + f;
    out.z = in.z >= cut ? c * _log10f(a * in.z + b) + d : e * in.z + f;

    return out;
    }
 
 __DEVICE__ float3 FLogToLin (float3 in) {
    float3 out;

    float a = 0.555556;
    float b = 0.009468;
    float c = 0.344676;
    float d = 0.790453;
    float e = 8.735631;
    float f = 0.092864;
    float cut = 0.100537775223865;

    out.x = in.x >= cut ? _powf(10, ((in.x - d) / c)) / a - b / a : (in.x - f) / e;
    out.y = in.y >= cut ? _powf(10, ((in.y - d) / c)) / a - b / a : (in.y - f) / e;
    out.z = in.z >= cut ? _powf(10, ((in.z - d) / c)) / a - b / a : (in.z - f) / e;

    return out;
    }
 
 __DEVICE__ float3 LinToFLog2 (float3 in) {
    float3 out;

    float a = 5.555556;
    float b = 0.064829;
    float c = 0.245281;
    float d = 0.384316;
    float e = 8.799461;
    float f = 0.092864;
    float cut = 0.000889;

    out.x = in.x >= cut ? c * _log10f(a * in.x + b) + d : e * in.x + f;
    out.y = in.y >= cut ? c * _log10f(a * in.y + b) + d : e * in.y + f;
    out.z = in.z >= cut ? c * _log10f(a * in.z + b) + d : e * in.z + f;

    return out;
    }
 
 __DEVICE__ float3 FLog2ToLin (float3 in) {
    float3 out;

    float a = 5.555556;
    float b = 0.064829;
    float c = 0.245281;
    float d = 0.384316;
    float e = 8.799461;
    float f = 0.092864;
    float cut = 0.100686685370811;

    out.x = in.x >= cut ? _powf(10, ((in.x - d) / c)) / a - b / a : (in.x - f) / e;
    out.y = in.y >= cut ? _powf(10, ((in.y - d) / c)) / a - b / a : (in.y - f) / e;
    out.z = in.z >= cut ? _powf(10, ((in.z - d) / c)) / a - b / a : (in.z - f) / e;

    return out;
    }
 
 __DEVICE__ float3 LinToVLog (float3 in) {
    float3 out;

    float cut = 0.01;
    float b = 0.00873;
    float c = 0.241514;
    float d = 0.598206;

    out.x = in.x < cut ? 5.6 * in.x + 0.125 : c * _log10f(in.x + b) + d;
    out.y = in.y < cut ? 5.6 * in.y + 0.125 : c * _log10f(in.y + b) + d;
    out.z = in.z < cut ? 5.6 * in.z + 0.125 : c * _log10f(in.z + b) + d;

    return out;
    }
 
 __DEVICE__ float3 VLogToLin (float3 in) {
    float3 out;

    float cut = 0.181;
    float b = 0.00873;
    float c = 0.241514;
    float d = 0.598206;

    out.x = in.x < cut ? (in.x - 0.125) / 5.6 : _powf(10.0, ((in.x - d) / c)) - b;
    out.y = in.y < cut ? (in.y - 0.125) / 5.6 : _powf(10.0, ((in.y - d) / c)) - b;
    out.z = in.z < cut ? (in.z - 0.125) / 5.6 : _powf(10.0, ((in.z - d) / c)) - b;

    return out;
    }
 
 __DEVICE__ float3 LinToLog3G10 (float3 in) {
    float3 out;

    float a = 0.224282f;
    float b = 155.975327f;
    float c = 0.01f;
    float g = 15.1927f;

    in.x += c;
    in.y += c;
    in.z += c;

    out.x = in.x < 0.0f ? in.x * g : a * _log10f((in.x * b) + 1.0f);
    out.y = in.y < 0.0f ? in.y * g : a * _log10f((in.y * b) + 1.0f);
    out.z = in.z < 0.0f ? in.z * g : a * _log10f((in.z * b) + 1.0f);

    return out;
    }
 
 __DEVICE__ float3 Log3G10toLin (float3 in) {
    float3 out;

    float a = 0.224282f;
    float b = 155.975327f;
    float c = 0.01f;
    float g = 15.1927f;

    out.x = in.x < 0.0f ? (in.x / g) - c : (_powf(10.0f, in.x / a) - 1.0f) / b;
    out.y = in.y < 0.0f ? (in.y / g) - c : (_powf(10.0f, in.y / a) - 1.0f) / b;
    out.z = in.z < 0.0f ? (in.z / g) - c : (_powf(10.0f, in.z / a) - 1.0f) / b;

    out.x -= c;
    out.y -= c;
    out.z -= c;

    return out;
    }
 
 __DEVICE__ float3 LinToSLog3 (float3 in) {
    float3 out;

    out.x = in.x >= 0.01125000 ? (420.0 + _log10f((in.x + 0.01) / (0.18 + 0.01)) * 261.5) / 1023.0 : (in.x * (171.2102946929 - 95.0)/0.01125000 + 95.0) / 1023.0;
    out.y = in.y >= 0.01125000 ? (420.0 + _log10f((in.y + 0.01) / (0.18 + 0.01)) * 261.5) / 1023.0 : (in.y * (171.2102946929 - 95.0)/0.01125000 + 95.0) / 1023.0;
    out.z = in.z >= 0.01125000 ? (420.0 + _log10f((in.z + 0.01) / (0.18 + 0.01)) * 261.5) / 1023.0 : (in.z * (171.2102946929 - 95.0)/0.01125000 + 95.0) / 1023.0;    

    return out;
    }
 
 __DEVICE__ float3 SLog3ToLin (float3 in) {
    float3 out;

    out.x = in.x >= 171.2102946929 / 1023.0 ? (_powf(10.0, ((in.x * 1023.0 - 420.0) / 261.5))) * (0.18 + 0.01) - 0.01 : (in.x * 1023.0 - 95.0) * 0.01125000 / (171.2102946929 - 95.0);
    out.y = in.y >= 171.2102946929 / 1023.0 ? (_powf(10.0, ((in.y * 1023.0 - 420.0) / 261.5))) * (0.18 + 0.01) - 0.01 : (in.y * 1023.0 - 95.0) * 0.01125000 / (171.2102946929 - 95.0);
    out.z = in.z >= 171.2102946929 / 1023.0 ? (_powf(10.0, ((in.z * 1023.0 - 420.0) / 261.5))) * (0.18 + 0.01) - 0.01 : (in.z * 1023.0 - 95.0) * 0.01125000 / (171.2102946929 - 95.0);

    return out;
    }
 
 __DEVICE__ float3 LinToBMDFilmGen5(float3 in) {
    float3 out;

    float a = 8.283605932402494f;
    float b = 0.09246575342465753f;
    float c = 0.5300133392291939f;
    float d = 0.08692876065491224f;
    float e = 0.005494072432257808f;
    float cut = 0.005f;

    out.x = in.x < cut ? a * in.x + b : d * _logf(in.x + e) + c;
    out.y = in.y < cut ? a * in.y + b : d * _logf(in.y + e) + c;
    out.z = in.z < cut ? a * in.z + b : d * _logf(in.z + e) + c;

    return out;
    }
 
 __DEVICE__ float3 BMDFilmGen5ToLin(float3 in) {
    float3 out;

    float a = 8.283605932402494f;
    float b = 0.09246575342465753f;
    float c = 0.5300133392291939f;
    float d = 0.08692876065491224f;
    float e = 0.005494072432257808f;
    float cut = a * 0.005f + b;

    out.x = in.x < (a * 0.005f + b) ? (in.x - b) / a : _expf((in.x - c) / d) - e;
    out.y = in.y < (a * 0.005f + b) ? (in.y - b) / a : _expf((in.y - c) / d) - e;
    out.z = in.z < (a * 0.005f + b) ? (in.z - b) / a : _expf((in.z - c) / d) - e;

    return out;
    }
 
 __DEVICE__ float3 LinToCLog (float3 in) {
    float3 out;

    out.x = in.x < 0 ? -.529136 * _log10f(1 - 10.1596 * in.x) + 0.0730597 : .529136 * _log10f(10.1596 * in.x + 1) + 0.0730597;
    out.y = in.y < 0 ? -.529136 * _log10f(1 - 10.1596 * in.y) + 0.0730597 : .529136 * _log10f(10.1596 * in.y + 1) + 0.0730597;
    out.z = in.z < 0 ? -.529136 * _log10f(1 - 10.1596 * in.z) + 0.0730597 : .529136 * _log10f(10.1596 * in.z + 1) + 0.0730597;

    return out;
    }
 
 __DEVICE__ float3 CLogToLin (float3 in) {
    float3 out;

    out.x = in.x < 0.0730597 ? -(_powf(10, (0.0730597 - in.x) / .529136) - 1) / 10.1596 : (_powf(10, (in.x - 0.0730597) / .529136) - 1) / 10.1596;
    out.y = in.y < 0.0730597 ? -(_powf(10, (0.0730597 - in.y) / .529136) - 1) / 10.1596 : (_powf(10, (in.y - 0.0730597) / .529136) - 1) / 10.1596;
    out.z = in.z < 0.0730597 ? -(_powf(10, (0.0730597 - in.z) / .529136) - 1) / 10.1596 : (_powf(10, (in.z - 0.0730597) / .529136) - 1) / 10.1596;

    return out;
    }
 
 __DEVICE__ float3 LinToCLog2 (float3 in) {
    float3 out;

    out.x = in.x < 0 ? -0.24136077 * _log10f(1 - 87.099375 * in.x) + 0.092864125 : 0.24136077 * _log10f(87.099375 * in.x + 1) + 0.092864125;
    out.y = in.y < 0 ? -0.24136077 * _log10f(1 - 87.099375 * in.y) + 0.092864125 : 0.24136077 * _log10f(87.099375 * in.y + 1) + 0.092864125;
    out.z = in.z < 0 ? -0.24136077 * _log10f(1 - 87.099375 * in.z) + 0.092864125 : 0.24136077 * _log10f(87.099375 * in.z + 1) + 0.092864125;

    return out;
    }
 
 __DEVICE__ float3 CLog2ToLin (float3 in) {
    float3 out;

    out.x = in.x < 0.092864125 ? -(_powf(10, (0.092864125 - in.x) / 0.24136077) - 1) / 87.099375 : (_powf(10, (in.x - 0.092864125) / 0.24136077) - 1) / 87.099375;
    out.y = in.y < 0.092864125 ? -(_powf(10, (0.092864125 - in.y) / 0.24136077) - 1) / 87.099375 : (_powf(10, (in.y - 0.092864125) / 0.24136077) - 1) / 87.099375;
    out.z = in.z < 0.092864125 ? -(_powf(10, (0.092864125 - in.z) / 0.24136077) - 1) / 87.099375 : (_powf(10, (in.z - 0.092864125) / 0.24136077) - 1) / 87.099375;

    return out;
    }
 
 __DEVICE__ float3 LinToCLog3 (float3 in) {
    float3 out;

    out.x = in.x < -0.014 ? -0.36726845 * _log10f(1 - 14.98325 * in.x) + 0.12783901 : in.x <= 0.014 ? 1.9754798 * in.x + 0.12512219 : 0.36726845 * _log10f(14.98325 * in.x + 1) + 0.12240537;
    out.y = in.y < -0.014 ? -0.36726845 * _log10f(1 - 14.98325 * in.y) + 0.12783901 : in.y <= 0.014 ? 1.9754798 * in.y + 0.12512219 : 0.36726845 * _log10f(14.98325 * in.y + 1) + 0.12240537;
    out.z = in.z < -0.014 ? -0.36726845 * _log10f(1 - 14.98325 * in.z) + 0.12783901 : in.z <= 0.014 ? 1.9754798 * in.z + 0.12512219 : 0.36726845 * _log10f(14.98325 * in.z + 1) + 0.12240537;

    return out;
    }
 
 __DEVICE__ float3 CLog3ToLin (float3 in) {
    float3 out;

    out.x = in.x < 0.097465473 ? -(_powf(10, (0.12783901 - in.x) / 0.36726845) - 1) / 14.98325 : in.x <= 0.15277891 ? (in.x - 0.12512219) / 1.9754798 : (_powf(10, (in.x - 0.12240537) / 0.36726845) - 1) / 14.98325;
    out.y = in.y < 0.097465473 ? -(_powf(10, (0.12783901 - in.y) / 0.36726845) - 1) / 14.98325 : in.y <= 0.15277891 ? (in.y - 0.12512219) / 1.9754798 : (_powf(10, (in.y - 0.12240537) / 0.36726845) - 1) / 14.98325;
    out.z = in.z < 0.097465473 ? -(_powf(10, (0.12783901 - in.z) / 0.36726845) - 1) / 14.98325 : in.z <= 0.15277891 ? (in.z - 0.12512219) / 1.9754798 : (_powf(10, (in.z - 0.12240537) / 0.36726845) - 1) / 14.98325;

    return out;
    }
 
 
 __DEVICE__ float3 GammaCurveToLin (float3 in, float gamma) {
    float3 out;

    out.x = _powf(_fmaxf(in.x, 0.0f), gamma);
    out.y = _powf(_fmaxf(in.y, 0.0f), gamma);
    out.z = _powf(_fmaxf(in.z, 0.0f), gamma);

    return out;
    }  
 
 __DEVICE__ float3 LinToGammaCurve (float3 in, float gamma) {
    float3 out;

    out.x = _powf(_fmaxf(in.x, 0.0f), (1 / gamma));
    out.y = _powf(_fmaxf(in.y, 0.0f), (1 / gamma));
    out.z = _powf(_fmaxf(in.z, 0.0f), (1 / gamma));

    return out;
    }
 
 


//functions to apply transfer function conversions
 
 __DEVICE__ float3 GammaToLin (float3 in, int gamma) {

    if (gamma ==  0) return LogC3ToLin(in);
    if (gamma ==  1) return LogC4ToLin(in);
    if (gamma ==  2) return DItoLin(in);
    if (gamma ==  3) return ACEScctToLin (in);
    if (gamma ==  4) return Log3G10toLin(in);
    if (gamma ==  5) return SLog3ToLin(in);
    if (gamma ==  6) return BMDFilmGen5ToLin(in);
    if (gamma ==  7) return CLog3ToLin(in);
    if (gamma ==  8) return DLogToLin(in);
    if (gamma ==  9) return FLogToLin(in);
    if (gamma == 10) return FLog2ToLin(in);
    if (gamma == 11) return VLogToLin(in);
    if (gamma == 12) return GammaCurveToLin(in, 2.2);
    if (gamma == 13) return GammaCurveToLin(in, 2.4);
    if (gamma == 14) return GammaCurveToLin(in, 2.6);
    if (gamma == 15) return in; // Lin


    return make_float3(0, 0, 1); // Blue on error
    }
 
 __DEVICE__ float3 LinToGamma (float3 in, int gamma) {
    if (gamma ==  0) return LinToLogC3(in);
    if (gamma ==  1) return LinToLogC4(in);
    if (gamma ==  2) return LinToDI(in);
    if (gamma ==  3) return LinToACEScct(in);
    if (gamma ==  4) return LinToLog3G10(in);
    if (gamma ==  5) return LinToSLog3(in);
    if (gamma ==  6) return LinToBMDFilmGen5(in);
    if (gamma ==  7) return LinToCLog3(in);
    if (gamma ==  8) return LinToDLog(in);
    if (gamma ==  9) return LinToFLog(in);
    if (gamma == 10) return LinToFLog2(in);
    if (gamma == 11) return LinToVLog(in);
    if (gamma == 12) return LinToGammaCurve(in, 2.2);
    if (gamma == 13) return LinToGammaCurve(in, 2.4);
    if (gamma == 14) return LinToGammaCurve(in, 2.6);
    if (gamma == 15) return in; // Lin


    
    return make_float3(0, 1, 0); // Green on error
    }
 
 __DEVICE__ float set_pivot (float pivot, int gamma) {
    float p_transfer_f = gamma;
    float midgray;
    const float logc3_gray = 0.39101f;
    const float logc4_gray = 0.2784f;
    const float DI_gray = 0.33604f;
    const float ACEScct_gray = 0.41359f;
    const float log3g10_gray = 0.3333f;
    const float slog3_gray = 0.41056f;
    const float bmd_f5_gray = 0.38356f;
    const float clog3_gray = 0.34339f;
    const float dlog_gray = 0.39876f;
    const float fLog_gray = 0.45932f;
    const float fLog2_gray = 0.39101f;
    const float vlog_gray = 0.42331f;
    const float g22_gray = 0.45866f;
    const float g24_gray = 0.48944f;
    const float g26_gray = 0.51709f;
    const float linear_gray = 0.18f;

    if (p_transfer_f ==  0) { midgray = logc3_gray;}
    if (p_transfer_f ==  1) { midgray = logc4_gray; }
    if (p_transfer_f ==  2) { midgray = DI_gray;}
    if (p_transfer_f ==  3) { midgray = ACEScct_gray;}
    if (p_transfer_f ==  4) { midgray = log3g10_gray;}
    if (p_transfer_f ==  5) { midgray = slog3_gray;}
    if (p_transfer_f ==  6) { midgray = bmd_f5_gray;}
    if (p_transfer_f ==  7) { midgray = clog3_gray;}
    if (p_transfer_f ==  8) { midgray = dlog_gray;}
    if (p_transfer_f ==  9) { midgray = fLog_gray;}
    if (p_transfer_f == 10) { midgray = fLog2_gray;}
    if (p_transfer_f == 11) { midgray = vlog_gray;}
    if (p_transfer_f == 12) { midgray = g22_gray;}
    if (p_transfer_f == 13) { midgray = g24_gray;}
    if (p_transfer_f == 14) { midgray = g26_gray;}
    if (p_transfer_f == 15) { midgray = linear_gray;}
    
    float3 get_mid = make_float3(0.18f, 0.18f,0.18f);
    get_mid = LinToGamma(get_mid, p_transfer_f);
    //get_mid = maxf3(get_mid);
    midgray = get_mid.x;

    pivot = pivot + midgray;
    
    return pivot;
    }


//color models
 __DEVICE__ float3 RGBtoCHEN(float3 in) {
    float r = in.x;
    float g = in.y;
    float b = in.z;

    float h;
    float c;
    float l;

    const float rtr = r * 0.81649658f + g * -0.40824829f + b * -0.40824829f;
    const float rtg = r * 0.0f + g * 0.70710678f + b * -0.70710678f;
    const float rtb = r * 0.57735027f + g * 0.57735027f + b * 0.57735027f;

    const float art = _atan2f(rtg, rtr);

    const float sphr = _sqrtf(rtr*rtr + rtg*rtg + rtb*rtb);
    const float spht = art < 0.0f ? art + 2.0f * 3.141592653589f : art;
    const float sphp = _atan2f(_sqrtf(rtr*rtr + rtg*rtg), rtb);

    l = sphr * 0.5773502691896258f;
    h = spht * 0.15915494309189535f;
    c = sphp * 1.0467733744265997f;

    return make_float3(h, c, l);
  } //by Kaur Hendrikson
 
 __DEVICE__ float3 CHENtoRGB(float3 in) {
    float h = in.x * 6.283185307179586f;
    float c = in.y * 0.9553166181245093f;
    float l = in.z * 1.7320508075688772f;
    
   float r = 0;
   float g = 0;
   float b = 0;

    const float ctr = l * _sinf(c) * _cosf(h);
    const float ctg = l * _sinf(c) * _sinf(h);
    const float ctb = l * _cosf(c);

    r = ctr * 0.81649658f + ctg * 0.0f + ctb * 0.57735027f;
    g = ctr * -0.40824829f + ctg * 0.70710678f + ctb * 0.57735027f;
    b = ctr * -0.40824829f + ctg * -0.70710678f + ctb * 0.57735027f;

    return make_float3(r, g, b);
  } //by Kaur Hendrikson
 

//main tool functions


__DEVICE__ float3 exposure_high(float3 rgb, float ex, float pv, float fa, int inv) {
  // Zoned highlight exposure with falloff : https://www.desmos.com/calculator/ylq5yvkhoq

  // Parameter setup
  const float f = 5.0f * _powf(fa, 1.6f) + 1.0f;
  const float p = _fabs(ex + f) < 1e-8f ? 1e-8f : (ex + f) / f;
  const float m = _powf(2.0f, ex);
  const float t0 = 0.18f * _powf(2.0f, pv);
  const float a = _powf(t0, 1.0f - p) / p;
  const float b = t0 * (1.0f - 1.0f / p);
  const float x1 = t0 * _powf(2.0f, f);
  const float y1 = a * _powf(x1, p) + b;

  // Calculate scale factor for rgb
  float n = _fmaxf(rgb.x, _fmaxf(rgb.y, rgb.z));
  float s;
  if (inv == 1)
    s = n < t0 ? 1.0f : n > y1 ? ((m * x1 - y1 + n) / m) / n : _powf((n - b) / a, 1.0f / p) / n;
  else
    s = n < t0 ? 1.0f : n > x1 ? (m * (n - x1) + y1) / n : (a * _powf(n, p) + b) / n;
  return rgb * s;
}

__DEVICE__ float3 exposure_low(float3 rgb, float ex, float pv, float fa) {
  // Zoned shadow exposure with falloff : https://www.desmos.com/calculator/my116fpnix
  // https://colab.research.google.com/drive/1GAoiqR33U2zlW5fw1byUdZBw7eqJibjN

  // Parameter setup
  const float f = 6.0f - 5.0f * fa;
  const float p = _fminf(f / 2.0f, f / 2.0f * _powf(0.5, ex));
  const float t0 = 0.18f * _powf(2.0f, pv);
  const float _c = _powf(2.0f, ex);
  const float _a = p*(_c - 1.0f)/_powf(t0, p + 1.0f);
  const float _b = (1.0f - _c)*(p + 1.0f)/_powf(t0, p);
  
  // Calculate scale factor for rgb
  float n = _fmaxf(rgb.x, _fmaxf(rgb.y, rgb.z));
  float s = n > t0 || n < 0.0f ? 1.0f : _powf(n, p) * (_a * n + _b) + _c; // implicit divide by n here
  return rgb * s;
}

 __DEVICE__ float3 apply_white_point (float3 in, float white_point, float pivot, float shoulder_strength) {

float3 out = in; 
float scale_factor;

if (in.x > pivot) {
    scale_factor = (1.0f - pivot) / _powf(_powf((white_point - pivot) / (1.0f - pivot), -1.0f*shoulder_strength) - 1.0f, 1.0f/shoulder_strength);
    
    out.x = pivot + scale_factor *((in.x - pivot) / scale_factor) / (_powf(1.0f + _powf((in.x - pivot) / scale_factor, shoulder_strength), 1.0f / shoulder_strength));

    }

        else {
           
        out.x = in.x;
        
        }

if (in.y > pivot) {
    scale_factor = (1.0f - pivot) / _powf(_powf((white_point - pivot) / (1.0f - pivot), -1.0f*shoulder_strength) - 1.0f, 1.0f/shoulder_strength);
    
    out.y = pivot + scale_factor *((in.y - pivot) / scale_factor) / (_powf(1.0f + _powf((in.y - pivot) / scale_factor, shoulder_strength), 1.0f / shoulder_strength));

    }

        else {
           
        out.y = in.y;
        
        }

if (in.z > pivot) {
    scale_factor = (1.0f - pivot) / _powf(_powf((white_point - pivot) / (1.0f - pivot), -1.0f*shoulder_strength) - 1.0f, 1.0f/shoulder_strength);
    
    out.z = pivot + scale_factor *((in.z - pivot) / scale_factor) / (_powf(1.0f + _powf((in.z - pivot) / scale_factor, shoulder_strength), 1.0f / shoulder_strength));

    }

        else {
           
        out.z = in.z;
        
        }

    return out;
 }


 __DEVICE__ float3 apply_black_point (float3 in, float black_point, float pivot, float toe_str) {

float3 out = in; 

in.x = 1.0f - in.x;
in.y = 1.0f - in.y ;
in.z = 1.0f - in.z ;

float scale_factor;

    if (in.x > pivot) {
    scale_factor = (1.0f - pivot) / _powf(_powf((black_point - pivot) / (1.0f - pivot), -1.0f*toe_str) - 1.0f, 1.0f/toe_str);
    
    out.x = pivot + scale_factor *((in.x - pivot) / scale_factor) / (_powf(1.0f + _powf((in.x - pivot) / scale_factor, toe_str), 1.0f / toe_str));
    }
    
            else {
           
        out.x = in.x;
        
        }
    
    if (in.y > pivot) {

    scale_factor = (1.0f - pivot) / _powf(_powf((black_point - pivot) / (1.0f - pivot), -1.0f*toe_str) - 1.0f, 1.0f/toe_str);
    
    out.y = pivot + scale_factor *((in.y - pivot) / scale_factor) / (_powf(1.0f + _powf((in.y - pivot) / scale_factor, toe_str), 1.0f / toe_str));

    }
    
            else {
           
        out.y = in.y;
        
        }
    
    if (in.z > pivot) {
    scale_factor = (1.0f - pivot) / _powf(_powf((black_point - pivot) / (1.0f - pivot), -1.0f*toe_str) - 1.0f, 1.0f/toe_str);
    
    out.z = pivot + scale_factor *((in.z - pivot) / scale_factor) / (_powf(1.0f + _powf((in.z - pivot) / scale_factor, toe_str), 1.0f / toe_str));

    }
    
            else {
           
        out.z = in.z;
        
        }

 out.x = 1 - out.x;
 out.y = 1 - out.y;
 out.z = 1 - out.z;

return out;
 }


DEFINE_UI_PARAMS(P_exHI, Hi - Exposure, DCTLUI_SLIDER_FLOAT, 0.0, -5.0, 5.0, 0.0)
DEFINE_UI_PARAMS(P_faHI, Hi Falloff, DCTLUI_SLIDER_FLOAT, 0.8, 0.0, 1.0, 0.0)
//DEFINE_UI_PARAMS(invert, invert, DCTLUI_CHECK_BOX, 0)


DEFINE_UI_PARAMS(P_exLo, Lo - Exposure, DCTLUI_SLIDER_FLOAT, 0.0, -5.0, 5.0, 0.0)
DEFINE_UI_PARAMS(P_faLo, Lo Falloff, DCTLUI_SLIDER_FLOAT, 0.8, 0.0, 1.0, 0.0)

DEFINE_UI_PARAMS(p_white_point, Roll High End , DCTLUI_SLIDER_FLOAT, 0.9999f, 0.0f, 0.9999f, 0.0001f)
DEFINE_UI_PARAMS(p_black_point, Roll Low End , DCTLUI_SLIDER_FLOAT, 0.0011, 0.0011, 1, 0.0001)
DEFINE_UI_PARAMS(p_save_sat, Preserve Color , DCTLUI_SLIDER_FLOAT, .5f, 0.0f, 1.0f, 0.01f)


DEFINE_UI_PARAMS(P_pvHI, HI Pivot, DCTLUI_SLIDER_FLOAT, 0.0, -5.0, 5.0, 0.0)
DEFINE_UI_PARAMS(P_pvLo, Lo Pivot, DCTLUI_SLIDER_FLOAT, 0.0, -3.0, 2.5, 0.0)

DEFINE_UI_PARAMS(bypass, ðŸš« Bypass, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(opt_showcurve, ðŸ“ˆ Show Curve, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(opt_ramp, ðŸ“ Show Ramp, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(opt_ramp_scope, =Wide aspect overlays =, DCTLUI_CHECK_BOX, 0)

DEFINE_UI_PARAMS(p_transfer_f, Transfer function, DCTLUI_COMBO_BOX, 2, {logc3, logc4, di, aces_cct, log3g10, slog3, bmd_f5, clog3, dlog, fLog, fLog2, vlog, g22, g24, g26, linear}, {ARRI LogC3, ARRI LogC4,  DaVinci Intermediate, ACEScct, RED Log3G10, Sony S-Log3, BMD Film Gen 5, Canon Log 3, DJI D-Log, FujiFilm F-Log, FujiFilm F-Log2, Panasonic V-Log, Gamma 2.2, Gamma 2.4, Gamma 2.6, Linear})


__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B) 
{
    
//--------------------------
//--------------------------
//prepare for doing magic here
//--------------------------
//--------------------------


    const float3 bypass_RGB = make_float3(p_R, p_G, p_B);
    float3 out;
    //float3 outRGB0;
    out = bypass_RGB;
   P_pvLo = 2.9*set_pivot(P_pvLo, p_transfer_f);
   P_pvHI = 3*set_pivot(P_pvHI, p_transfer_f);

 //Roll sanitization
	p_white_point= .7 + p_white_point*.3;
	float P_black= 1-p_black_point;
	P_black = .9+ P_black*.1;
	float black_pivot = set_pivot(0, p_transfer_f);



  //create a linear ramp to enable the view graph control
   	float width = (float)p_Width;
   	float height = (float)p_Height;
   	if (opt_ramp_scope) {height = height*0.64f; }
   	float X = (float)p_X;
   	float Y = height - (float)p_Y;
   	if (opt_ramp_scope) { Y = height*1.28f - (float)p_Y; }
   	//Relative X,Y 
   	float rY = Y / height;
   	float rX = X / width;
   	float3 ramp = {rX, rX, rX};

   	//a clean version of the ramp to show in the bypass version
    float3 cleanRamp = ramp;
    
    //extract original saturation
    float3 chen_lum;
    float3 save_sat;
    chen_lum = RGBtoCHEN(out);
    float chen_hue = chen_lum.x;
    float chen_sat= chen_lum.y;
    float chen_luma= chen_lum.z;
    chen_lum= make_float3 (chen_luma,chen_luma,chen_luma);

//--------------------------
//--------------------------
//start doing magic here
//--------------------------
//--------------------------




  out = exposure_low(out, P_exLo, P_pvLo, P_faLo);
  ramp = exposure_low(ramp, P_exLo, P_pvLo, P_faLo);
  chen_lum= exposure_low(chen_lum, P_exLo, P_pvLo, P_faLo);

  out = exposure_high(out, P_exHI, P_pvHI, P_faHI, 0);
  ramp = exposure_high(ramp, P_exHI, P_pvHI, P_faHI, 0);
  chen_lum = exposure_high(chen_lum, P_exHI, P_pvHI, P_faHI, 0);


  //apply compression to the white and black points
     out = apply_white_point(out, p_white_point, 0.0f, 3.0);
     ramp = apply_white_point(ramp, p_white_point, 0.0f, 3.0);
     chen_lum = apply_white_point(chen_lum, p_white_point, 0.0f, 3.0);

     out = apply_black_point(out, P_black, black_pivot, 5.0f);           
     ramp = apply_black_point(ramp, P_black, black_pivot, 5.0f);
     chen_lum = apply_black_point(chen_lum, P_black, black_pivot, 5.0f);

     //implement preserve color functionality

     save_sat = make_float3 (chen_hue,chen_sat,chen_lum.z);
     save_sat = CHENtoRGB(save_sat);
     out = _mix(out, save_sat, p_save_sat);
  

	// bypass option including a bypass option to the ramp to display an untouched curve
     if (bypass ==1 ) {

   	   	out = bypass_RGB;
   	   	ramp = cleanRamp;

   		}

    //Optional show curve functionality
     if (opt_showcurve == 1) {
    
 		float3 scopeY = LinToGamma(make_float3(.9f,.9f,.9f), p_transfer_f);


        float overlayR = ramp.x >= (Y - 5.0f) / height && ramp.x <= (Y + 5.0f) / height ? scopeY.x : 0.0f;
        float overlayG = ramp.y >= (Y - 5.0f) / height && ramp.y <= (Y + 5.0f) / height ? scopeY.y : 0.0f;
        float overlayB = ramp.z >= (Y - 5.0f) / height && ramp.z <= (Y + 5.0f) / height ? scopeY.z : 0.0f;
        out.x = overlayR == 0.0f ? out.x : overlayR;
        out.y = overlayG == 0.0f ? out.y : overlayG;
        out.z = overlayB == 0.0f ? out.z : overlayB;
            
		}

  	//option to overlay a grayscale ramp on the bottom edge of the frame
      if (opt_ramp) {
          if (opt_ramp_scope){ 
                  if( rY < 0.05f  && rY > -0.02f) {out = ramp;}
              return out;
              }  
      if( rY < 0.1f ) {out = ramp;}
                  
      
      }






  return out;

}
