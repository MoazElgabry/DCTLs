#line 2 
/*

Exposure Chart DCTL ver 1.1
by Moaz Elgabry, moazelgabry.com

Thanks to Thatcher Freeman for the original code to draw the chart and to render text


*/
//functions for Transfer function conversion


 __DEVICE__ float3 inline LinToLogC3 (float3 in) {
    float3 out;

    float cut = 0.010591;
    float a = 5.555556;
    float b = 0.052272;
    float c = 0.247190;
    float d = 0.385537;
    float e = 5.367655;
    float f = 0.092809;

    out.x = (in.x > cut) ? c * log10(a * in.x + b) + d: e * in.x + f;
    out.y = (in.y > cut) ? c * log10(a * in.y + b) + d: e * in.y + f;
    out.z = (in.z > cut) ? c * log10(a * in.z + b) + d: e * in.z + f;

    return out;
    }
 
 __DEVICE__ float3 inline LinToDI (float3 in) {
    float3 out;

    float a = 0.0075;
    float b = 7.0;
    float c = 0.07329248;
    float m = 10.44426855;
    float lin_cut = 0.00262409;

    out.x = in.x > lin_cut ? (_log2f(in.x + a) + b) * c : out.x = in.x * m;
    out.y = in.y > lin_cut ? (_log2f(in.y + a) + b) * c : out.y = in.y * m;
    out.z = in.z > lin_cut ? (_log2f(in.z + a) + b) * c : out.z = in.z * m;

    return out;
    }
 
 __DEVICE__ float3 inline LinToACEScct (float3 in) {
    float3 out;

    float a = 10.5402377416545;
    float b = 0.0729055341958355;
    float c = 9.72;
    float d = 17.52;
    float e = 0.0078125;

    out.x = in.x <= e ? a * in.x + b : (_log2f(in.x) + c) / d;
    out.y = in.y <= e ? a * in.y + b : (_log2f(in.y) + c) / d;
    out.z = in.z <= e ? a * in.z + b : (_log2f(in.z) + c) / d;

    return out;
    }
 
 __DEVICE__ float3 inline LinToLogC4 (float3 in) {
    float3 out;

    float a = (_powf(2.0, 18.0) - 16.0) / 117.45;
    float b = (1023.0 - 95.0) / 1023.0;
    float c = 95.0 / 1023.0;
    float s = (7 * _logf(2) * _powf(2.0, 7 - 14 * c / b)) / (a * b);
    float t = (_powf(2.0, 14.0 * (-c / b) + 6.0) - 64.0) / a;

    out.x = in.x < t ? (in.x - t) / s : (_log2f( a * in.x + 64.0) - 6.0) / 14.0 * b + c;
    out.y = in.y < t ? (in.y - t) / s : (_log2f( a * in.y + 64.0) - 6.0) / 14.0 * b + c;
    out.z = in.z < t ? (in.z - t) / s : (_log2f( a * in.z + 64.0) - 6.0) / 14.0 * b + c;

    return out;
    }
 
 __DEVICE__ float3 inline LinToDLog (float3 in) {
    float3 out;

    out.x = in.x <= 0.0078 ? 6.025 * in.x + 0.0929 : (_log10f(in.x * 0.9892 + 0.0108)) * 0.256663 + 0.584555;
    out.y = in.y <= 0.0078 ? 6.025 * in.y + 0.0929 : (_log10f(in.y * 0.9892 + 0.0108)) * 0.256663 + 0.584555;
    out.z = in.z <= 0.0078 ? 6.025 * in.z + 0.0929 : (_log10f(in.z * 0.9892 + 0.0108)) * 0.256663 + 0.584555;

    return out;
    }
 
 __DEVICE__ float3 inline LinToFLog (float3 in) {
    float3 out;

    float a = 0.555556;
    float b = 0.009468;
    float c = 0.344676;
    float d = 0.790453;
    float e = 8.735631;
    float f = 0.092864;
    float cut = 0.00089;

    out.x = in.x >= cut ? c * _log10f(a * in.x + b) + d : e * in.x + f;
    out.y = in.y >= cut ? c * _log10f(a * in.y + b) + d : e * in.y + f;
    out.z = in.z >= cut ? c * _log10f(a * in.z + b) + d : e * in.z + f;

    return out;
    }
 
 __DEVICE__ float3 inline LinToFLog2 (float3 in) {
    float3 out;

    float a = 5.555556;
    float b = 0.064829;
    float c = 0.245281;
    float d = 0.384316;
    float e = 8.799461;
    float f = 0.092864;
    float cut = 0.000889;

    out.x = in.x >= cut ? c * _log10f(a * in.x + b) + d : e * in.x + f;
    out.y = in.y >= cut ? c * _log10f(a * in.y + b) + d : e * in.y + f;
    out.z = in.z >= cut ? c * _log10f(a * in.z + b) + d : e * in.z + f;

    return out;
    }
 
 __DEVICE__ float3 inline LinToVLog (float3 in) {
    float3 out;

    float cut = 0.01;
    float b = 0.00873;
    float c = 0.241514;
    float d = 0.598206;

    out.x = in.x < cut ? 5.6 * in.x + 0.125 : c * _log10f(in.x + b) + d;
    out.y = in.y < cut ? 5.6 * in.y + 0.125 : c * _log10f(in.y + b) + d;
    out.z = in.z < cut ? 5.6 * in.z + 0.125 : c * _log10f(in.z + b) + d;

    return out;
    }
 
 __DEVICE__ float3 inline LinToLog3G10 (float3 in) {
    float3 out;

    float a = 0.224282f;
    float b = 155.975327f;
    float c = 0.01f;
    float g = 15.1927f;

    in.x += c;
    in.y += c;
    in.z += c;

    out.x = in.x < 0.0f ? in.x * g : a * _log10f((in.x * b) + 1.0f);
    out.y = in.y < 0.0f ? in.y * g : a * _log10f((in.y * b) + 1.0f);
    out.z = in.z < 0.0f ? in.z * g : a * _log10f((in.z * b) + 1.0f);

    return out;
    }
 
 __DEVICE__ float3 inline LinToSLog3 (float3 in) {
    float3 out;

    out.x = in.x >= 0.01125000 ? (420.0 + _log10f((in.x + 0.01) / (0.18 + 0.01)) * 261.5) / 1023.0 : (in.x * (171.2102946929 - 95.0)/0.01125000 + 95.0) / 1023.0;
    out.y = in.y >= 0.01125000 ? (420.0 + _log10f((in.y + 0.01) / (0.18 + 0.01)) * 261.5) / 1023.0 : (in.y * (171.2102946929 - 95.0)/0.01125000 + 95.0) / 1023.0;
    out.z = in.z >= 0.01125000 ? (420.0 + _log10f((in.z + 0.01) / (0.18 + 0.01)) * 261.5) / 1023.0 : (in.z * (171.2102946929 - 95.0)/0.01125000 + 95.0) / 1023.0;    

    return out;
    }
 
 __DEVICE__ float3 inline LinToBMDFilmGen5(float3 in) {
    float3 out;

    float a = 8.283605932402494f;
    float b = 0.09246575342465753f;
    float c = 0.5300133392291939f;
    float d = 0.08692876065491224f;
    float e = 0.005494072432257808f;
    float cut = 0.005f;

    out.x = in.x < cut ? a * in.x + b : d * _logf(in.x + e) + c;
    out.y = in.y < cut ? a * in.y + b : d * _logf(in.y + e) + c;
    out.z = in.z < cut ? a * in.z + b : d * _logf(in.z + e) + c;

    return out;
    }

 
 __DEVICE__ float3 inline LinToCLog3 (float3 in) {
    float3 out;

    out.x = in.x < -0.014 ? -0.36726845 * _log10f(1 - 14.98325 * in.x) + 0.12783901 : in.x <= 0.014 ? 1.9754798 * in.x + 0.12512219 : 0.36726845 * _log10f(14.98325 * in.x + 1) + 0.12240537;
    out.y = in.y < -0.014 ? -0.36726845 * _log10f(1 - 14.98325 * in.y) + 0.12783901 : in.y <= 0.014 ? 1.9754798 * in.y + 0.12512219 : 0.36726845 * _log10f(14.98325 * in.y + 1) + 0.12240537;
    out.z = in.z < -0.014 ? -0.36726845 * _log10f(1 - 14.98325 * in.z) + 0.12783901 : in.z <= 0.014 ? 1.9754798 * in.z + 0.12512219 : 0.36726845 * _log10f(14.98325 * in.z + 1) + 0.12240537;

    return out;
    }

 __DEVICE__ float3 inline oetf_gopro_protune(float3 x, int inv) {
  /* GoPro Protune Flat log curve
      Unable to find whitepaper on this but it is described in this file from the original HPD opencolorio ACES config:
      https://github.com/hpd/OpenColorIO-Configs/blob/master/aces_1.0.3/python/aces_ocio/colorspaces/gopro.py
  */
    float3 result;

    if (inv == 1) {
        result.x = (_powf(113.0f, x.x) - 1.0f) / 112.0f;
        result.y = (_powf(113.0f, x.y) - 1.0f) / 112.0f;
        result.z = (_powf(113.0f, x.z) - 1.0f) / 112.0f;
    } else {
        result.x = _logf(x.x * 112.0f + 1.0f) / _logf(113.0f);
        result.y = _logf(x.y * 112.0f + 1.0f) / _logf(113.0f);
        result.z = _logf(x.z * 112.0f + 1.0f) / _logf(113.0f);
    }

    return result;
    }
 
 __DEVICE__ float3 inline oetf_leica_llog(float3 x, int inv) {
  /* Leica L-Log
      https://leica-camera.com/sites/default/files/pm-65977-210914__L-Log_Reference_Manual_EN.pdf
  */
 const float a = 8.0f;
    const float b = 0.09f;
    const float c = 0.27f;
    const float d = 1.3f;
    const float e = 0.0115f;
    const float f = 0.6f;
    const float c0 = 0.006f;
    const float c1 = 0.138f;

    float3 result;

    if (inv == 1) {
        // Inverse transformation
        // Apply condition per component
        result.x = (x.x < c1) ? (x.x - b) / a : (_exp10f((x.x - f) / c) - e) / d;
        result.y = (x.y < c1) ? (x.y - b) / a : (_exp10f((x.y - f) / c) - e) / d;
        result.z = (x.z < c1) ? (x.z - b) / a : (_exp10f((x.z - f) / c) - e) / d;
    } else {
        // Forward transformation
        result.x = (x.x < c0) ? a * x.x + b : c * _log10f(d * x.x + e) + f;
        result.y = (x.y < c0) ? a * x.y + b : c * _log10f(d * x.y + e) + f;
        result.z = (x.z < c0) ? a * x.z + b : c * _log10f(d * x.z + e) + f;
    }

    return result;
    }
 
 __DEVICE__ float3 inline oetf_nikon_nlog(float3 x, int inv) {
  /* Nikon N-Log
      http://download.nikonimglib.com/archive3/hDCmK00m9JDI03RPruD74xpoU905/N-Log_Specification_(En)01.pdf
  */
    const float a = 619.0f / 1023.0f;
    const float b = 150.0f / 1023.0f;
    const float c = 650.0f / 1023.0f;
    const float d = 0.0075f;
    const float c0 = 452.0f / 1023.0f;
    const float c1 = 0.328f;

    float3 result;

    if (inv == 1) {
        // Inverse transformation
        result.x = (x.x > c0) ? _expf((x.x - a) / b) : _powf(x.x / c, 3.0f) - d;
        result.y = (x.y > c0) ? _expf((x.y - a) / b) : _powf(x.y / c, 3.0f) - d;
        result.z = (x.z > c0) ? _expf((x.z - a) / b) : _powf(x.z / c, 3.0f) - d;
    } else {
        // Forward transformation
        result.x = (x.x > c1) ? b * _logf(x.x) + a : c * _powf(x.x + d, 1.0f / 3.0f);
        result.y = (x.y > c1) ? b * _logf(x.y) + a : c * _powf(x.y + d, 1.0f / 3.0f);
        result.z = (x.z > c1) ? b * _logf(x.z) + a : c * _powf(x.z + d, 1.0f / 3.0f);
    }

    return result;
    }

 __DEVICE__ float3 inline oetf_sony_slog2(float3 x, int inv) {
  /* Sony S-Log2
      from the pdf originally retrieved from :
      https://pro.sony/ue_US/?sonyref=pro.sony.com/bbsccms/assets/files/micro/dmpc/training/S-Log2_Technical_PaperV1_0.pdf
      Link is down, here is a mirror:
      https://mega.nz/file/e6hDxC5b#YaRzePfGFFPkx_hRtmqw2gTT0NIPuzlJycwCP38H720
  */
    const float c0 = 0.432699f;
    const float c1 = 155.0f;
    const float c2 = 219.0f;
    const float c3 = 0.037584f;
    const float c4 = 0.616596f;
    const float c5 = 0.03f;
    const float c6 = 3.53881278538813f;
    const float c7 = 0.030001222851889303f;

    float3 result;

    if (inv == 1) {
        // Inverse transformation
        float3 normalized = (x - (64.0f / 1023.0f)) / (876.0f / 1023.0f);
        result.x = (normalized.x < c7) ? (normalized.x - c7) / c6
                                       : c2 * (_exp10f((normalized.x - c4 - c5) / c0) - c3) / c1;
        result.y = (normalized.y < c7) ? (normalized.y - c7) / c6
                                       : c2 * (_exp10f((normalized.y - c4 - c5) / c0) - c3) / c1;
        result.z = (normalized.z < c7) ? (normalized.z - c7) / c6
                                       : c2 * (_exp10f((normalized.z - c4 - c5) / c0) - c3) / c1;
        result = result * 0.9f;
    } else {
        // Forward transformation
        float3 scaled = x / 0.9f;
        result.x = (scaled.x < 0.0f) ? scaled.x * c6 + c7
                                     : (c0 * _log10f(c1 * scaled.x / c2 + c3) + c4) + c5;
        result.y = (scaled.y < 0.0f) ? scaled.y * c6 + c7
                                     : (c0 * _log10f(c1 * scaled.y / c2 + c3) + c4) + c5;
        result.z = (scaled.z < 0.0f) ? scaled.z * c6 + c7
                                     : (c0 * _log10f(c1 * scaled.z / c2 + c3) + c4) + c5;
        result = result * (876.0f / 1023.0f) + (64.0f / 1023.0f);
    }

    return result;
    }

 __DEVICE__ float3 inline oetf_filmlight_tlog(float3 x, int inv) {
  /* Filmlight T-Log
      Specified in the flspace file included with the Baselight software
      /etc/colourspaces/FilmLight_TLog_EGamut.flspace
  */
  
    const float o = 0.075f;
    const float A = 0.5520126568606655f;
    const float B = 0.09232902596577353f;
    const float C = 0.0057048244042473785f;
    const float G = 16.184376489665897f;

    float3 result;

    if (inv == 1) {
        // Inverse transformation
        result.x = (x.x < o) ? (x.x - o) / G : _expf((x.x - A) / B) - C;
        result.y = (x.y < o) ? (x.y - o) / G : _expf((x.y - A) / B) - C;
        result.z = (x.z < o) ? (x.z - o) / G : _expf((x.z - A) / B) - C;
    } else {
        // Forward transformation
        result.x = (x.x < 0.0f) ? G * x.x + o : _logf(x.x + C) * B + A;
        result.y = (x.y < 0.0f) ? G * x.y + o : _logf(x.y + C) * B + A;
        result.z = (x.z < 0.0f) ? G * x.z + o : _logf(x.z + C) * B + A;
    }

    return result;
    }

 __DEVICE__ float3 inline oetf_kodak_cineon(float3 x, int inv) {
  /* Kodak Cineon Log
      https://github.com/imageworks/OpenColorIO-Configs/blob/master/nuke-default/make.py
  */
    const float a = 685.0f;
    const float b = 300.0f;
    const float c = 95.0f;
    const float off = _exp10f((c - a) / b);

    float3 result;

    if (inv == 1) {
        // Inverse transformation
        result.x = (_exp10f(((1023.0f * x.x - a) / b)) - off) / (1.0f - off);
        result.y = (_exp10f(((1023.0f * x.y - a) / b)) - off) / (1.0f - off);
        result.z = (_exp10f(((1023.0f * x.z - a) / b)) - off) / (1.0f - off);
    } else {
        // Forward transformation
        result.x = (a + b * _log10f(x.x * (1.0f - off) + off)) / 1023.0f;
        result.y = (a + b * _log10f(x.y * (1.0f - off) + off)) / 1023.0f;
        result.z = (a + b * _log10f(x.z * (1.0f - off) + off)) / 1023.0f;
    }

    return result;
    }

 __DEVICE__ float3 inline LinToGammaCurve (float3 in, float gamma) {
    float3 out;

    out.x = _powf(_fmaxf(in.x, 0.0f), (1 / gamma));
    out.y = _powf(_fmaxf(in.y, 0.0f), (1 / gamma));
    out.z = _powf(_fmaxf(in.z, 0.0f), (1 / gamma));

    return out;
    }
 
//functions to apply transfer function conversions
 
 __DEVICE__ float3 inline LinToTF (float3 in, int TF) {
    if (TF ==  0) return LinToLogC3(in);
    if (TF ==  1) return LinToLogC4(in);
    if (TF ==  2) return LinToDI(in);
    if (TF ==  3) return LinToACEScct(in);
    if (TF ==  4) return LinToLog3G10(in);
    if (TF ==  5) return LinToSLog3(in);
    if (TF ==  6) return oetf_sony_slog2(in,0);
    if (TF ==  7) return LinToBMDFilmGen5(in);
    if (TF ==  8) return LinToCLog3(in);
    if (TF ==  9) return LinToDLog(in);
    if (TF == 10) return LinToFLog(in);
    if (TF == 11) return LinToFLog2(in);
    if (TF == 12) return LinToVLog(in);
    if (TF == 13) return oetf_gopro_protune(in,0);
    if (TF == 14) return oetf_leica_llog(in,0);
    if (TF == 15) return oetf_nikon_nlog(in,0);
    if (TF == 16) return oetf_filmlight_tlog(in,0);
    if (TF == 17) return oetf_kodak_cineon(in,0);
    if (TF == 18) return LinToGammaCurve(in, 2.2);
    if (TF == 19) return LinToGammaCurve(in, 2.4);
    if (TF == 20) return LinToGammaCurve(in, 2.6);
    if (TF == 21) return in; // Lin


    
    return make_float3(1, 0, 0); // Red on error
    }
 
 __DEVICE__ float inline set_mid_gray (float mid_gray, int TF) {

    float3 get_mid = make_float3(0.18f, 0.18f,0.18f);
    get_mid = LinToTF(get_mid, TF);
    mid_gray = get_mid.x;
    
    return mid_gray;
    }



// UI Parameters

DEFINE_UI_PARAMS(num_steps, Number of Steps, DCTLUI_SLIDER_INT, 17, 1, 36, 1)
DEFINE_UI_PARAMS(mid_gray, Mid-Gray Value, DCTLUI_SLIDER_FLOAT, 0.18, 0.0, 1.0, 0.001)
DEFINE_UI_PARAMS(opt_mid, Enable Custom Mid-Gray, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(opt_card, Show Gray Card, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(opt_ramp, Overlay Linear Ramp, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(opt_scope, :: Wide Aspect Mode ::, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(annotation_mode, Annotate, DCTLUI_COMBO_BOX, 0, {ANNOTATE_NONE, ANNOTATE_MIDGRAY_BASELINE, ANNOTATE_START_FROM_ZERO}, {None, Midgray Baseline, Start from Zero})
DEFINE_UI_PARAMS(p_TF, Transfer Function, DCTLUI_COMBO_BOX, 2, {logc3, logc4, di, aces_cct, log3g10, slog2,slog3, bmd_f5, clog3, dlog, fLog, fLog2, vlog,goprotune, Leicallog, nlog,tlog,cineon, g22, g24, g26, linear}, {ARRI LogC3, ARRI LogC4,  DaVinci Intermediate, ACEScct, RED Log3G10, Sony S-Log2,Sony S-Log3, BMD Film Gen 5, Canon Log 3, DJI D-Log, FujiFilm F-Log, FujiFilm F-Log2, Panasonic V-Log, Gopro protune, Leica - Llog, Nikon Nlog, Filmlight T log,Kodak Cineon,Gamma 2.2, Gamma 2.4, Gamma 2.6, Linear})
DEFINE_UI_PARAMS(opt_label, Show Label, DCTLUI_CHECK_BOX, 1) // Checkbox to toggle label display




////////////////
// FONT STUFF //
////////////////

#define FONT_WIDTH 10
#define FONT_HEIGHT 16
#define FONT_LENGTH 127

__CONSTANT__ int font_widths[FONT_LENGTH] = {
    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
    10, 3,  4,  7,  6,  10, 8,  2,  4,  4,  6,  6,  3,  4,  3,  4,  6,  5,  6,  6,  7,  6,  6,  6,  6,  6,  3,  3,  7,  6,  7,  6,
    10, 8,  7,  8,  8,  7,  7,  8,  8,  3,  5,  8,  7,  9,  7,  8,  7,  8,  8,  7,  6,  8,  8,  10, 7,  6,  7,  4,  4,  3,  6,  7,
    3,  6,  7,  6,  6,  6,  4,  6,  7,  3,  3,  6,  3,  9,  7,  6,  7,  6,  6,  5,  4,  7,  6,  8,  6,  6,  6,  4,  3,  4,  6};
__CONSTANT__ int font[FONT_LENGTH][FONT_HEIGHT] = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 0, 8, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 80, 80, 252, 40, 40, 252, 40, 40, 0, 0, 0, 0},
                                                   {0, 0, 0, 16, 56, 84, 20, 56, 80, 84, 56, 16, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 272, 296, 168, 144, 576, 1344, 1312, 544, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 48, 72, 72, 48, 296, 196, 196, 312, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 16, 8, 8, 4, 4, 4, 4, 8, 8, 16, 0, 0},
                                                   {0, 0, 0, 0, 4, 8, 8, 16, 16, 16, 16, 8, 8, 4, 0, 0},
                                                   {0, 0, 0, 0, 0, 84, 56, 84, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 16, 16, 124, 16, 16, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 4, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 16, 16, 16, 8, 8, 8, 4, 4, 4, 0, 0, 0},
                                                   {0, 0, 0, 0, 56, 68, 68, 68, 68, 68, 68, 56, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 32, 48, 40, 32, 32, 32, 32, 32, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 56, 68, 64, 32, 16, 8, 4, 124, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 56, 68, 64, 48, 64, 64, 68, 56, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 64, 96, 80, 72, 68, 252, 64, 64, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 124, 4, 4, 60, 64, 64, 68, 56, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 56, 68, 4, 60, 68, 68, 68, 56, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 124, 64, 32, 32, 16, 16, 8, 8, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 56, 68, 68, 56, 68, 68, 68, 56, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 56, 68, 68, 68, 120, 64, 64, 56, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 8, 8, 4, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 192, 48, 12, 48, 192, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 124, 0, 124, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 12, 48, 192, 48, 12, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 56, 68, 68, 32, 16, 16, 0, 16, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 480, 528, 1480, 1320, 1320, 968, 1040, 992, 0, 0, 0},
                                                   {0, 0, 0, 0, 32, 32, 80, 80, 136, 248, 260, 260, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 120, 136, 136, 120, 136, 136, 136, 120, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 240, 264, 4, 4, 4, 4, 264, 240, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 120, 136, 264, 264, 264, 264, 136, 120, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 248, 8, 8, 120, 8, 8, 8, 248, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 248, 8, 8, 120, 8, 8, 8, 8, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 240, 264, 4, 4, 452, 260, 264, 240, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 264, 264, 264, 504, 264, 264, 264, 264, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 32, 32, 32, 32, 32, 32, 36, 24, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 136, 72, 40, 24, 40, 72, 136, 264, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 248, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 520, 792, 792, 680, 680, 584, 584, 520, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 136, 152, 152, 168, 168, 200, 200, 136, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 112, 136, 260, 260, 260, 260, 136, 112, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 120, 136, 136, 136, 120, 8, 8, 8, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 112, 136, 260, 260, 260, 260, 200, 496, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 248, 264, 264, 264, 248, 72, 136, 264, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 112, 136, 8, 48, 64, 128, 136, 112, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 124, 16, 16, 16, 16, 16, 16, 16, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 264, 264, 264, 264, 264, 264, 264, 240, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 260, 260, 136, 136, 80, 80, 32, 32, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 1092, 1092, 1092, 680, 680, 680, 272, 272, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 136, 80, 80, 32, 32, 80, 80, 136, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 68, 68, 40, 40, 16, 16, 16, 16, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 252, 128, 64, 32, 16, 8, 4, 252, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 24, 8, 8, 8, 8, 8, 8, 8, 8, 24, 0, 0},
                                                   {0, 0, 0, 0, 4, 4, 4, 8, 8, 8, 16, 16, 16, 0, 0, 0},
                                                   {0, 0, 0, 0, 12, 8, 8, 8, 8, 8, 8, 8, 8, 12, 0, 0},
                                                   {0, 0, 0, 0, 16, 40, 40, 68, 68, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 252, 0, 0},
                                                   {0, 0, 0, 0, 4, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 56, 68, 120, 68, 120, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 8, 8, 8, 120, 136, 136, 136, 120, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 56, 68, 4, 68, 56, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 64, 64, 64, 120, 68, 68, 68, 120, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 56, 68, 124, 4, 120, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 16, 8, 8, 28, 8, 8, 8, 8, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 120, 68, 68, 68, 120, 64, 56, 0, 0},
                                                   {0, 0, 0, 0, 8, 8, 8, 120, 136, 136, 136, 136, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 8, 0, 8, 8, 8, 8, 8, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 8, 0, 8, 8, 8, 8, 8, 8, 4, 0, 0},
                                                   {0, 0, 0, 0, 8, 8, 8, 72, 40, 24, 40, 72, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 440, 584, 584, 584, 584, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 120, 136, 136, 136, 136, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 56, 68, 68, 68, 56, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 120, 136, 136, 136, 120, 8, 8, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 120, 68, 68, 68, 120, 64, 64, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 104, 24, 8, 8, 8, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 56, 4, 24, 32, 28, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 8, 8, 28, 8, 8, 8, 16, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 136, 136, 136, 136, 240, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 68, 68, 40, 40, 16, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 292, 292, 340, 136, 136, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 68, 40, 16, 40, 68, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 68, 68, 40, 40, 16, 16, 12, 0, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 124, 32, 16, 8, 124, 0, 0, 0, 0},
                                                   {0, 0, 0, 0, 16, 8, 8, 8, 8, 4, 8, 8, 8, 8, 16, 0},
                                                   {0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0},
                                                   {0, 0, 0, 0, 4, 8, 8, 8, 8, 16, 8, 8, 8, 8, 4, 0},
                                                   {0, 0, 0, 0, 0, 0, 0, 80, 40, 0, 0, 0, 0, 0, 0, 0}};


// Define structures for text rendering
 typedef struct {
     float x, y;  // Top-left position of a character or string
     float scale; // Height of the character relative to the image height
 } char_trans_t;
 
 typedef struct {
     float x, y; // Current pixel position in normalized coordinates
 } curr_pos_t;
 
// Helper functions
 __DEVICE__ char_trans_t make_char_trans(float x, float y, float scale) {
    char_trans_t result = {};
    result.x = x;
    result.y = y;
    result.scale = scale;
    return result;
 }
 
 __DEVICE__ curr_pos_t make_curr_pos(float x, float y) {
    curr_pos_t result = {};
    result.x = x;
    result.y = y;
    return result;
 }
 
 __DEVICE__ void draw_char(
    char c, float3 char_color, __PRIVATE__ char_trans_t* char_trans, __PRIVATE__ curr_pos_t* curr_pos, __PRIVATE__ float3* curr_color) {
    float char_height = char_trans->scale;
    float char_width = char_trans->scale * FONT_WIDTH / FONT_HEIGHT;

    // Check if current position is within the character bounds
    if (char_trans->x <= curr_pos->x && curr_pos->x <= char_trans->x + char_width && char_trans->y <= curr_pos->y &&
        curr_pos->y <= char_trans->y + char_height) {

        // Get the character symbol from the font data
        __CONSTANTREF__ int* char_symbol = &font[c][0];

        // Compute the row and column in the character grid
        int row = (int)_round((curr_pos->y - char_trans->y) / char_height * FONT_HEIGHT);
        int col = (int)_round((curr_pos->x - char_trans->x) / char_width * FONT_WIDTH);

        if (char_symbol[row] & (1 << col)) {
            *curr_color = char_color;
        }
    }
 }
 
 __DEVICE__ void draw_string(
    char str[], float3 str_color, __PRIVATE__ char_trans_t* char_trans, __PRIVATE__ curr_pos_t* curr_pos, __PRIVATE__ float3* curr_color) {
    int i = 0;
    char c = str[0];
    float c_width;
    char_trans_t c_trans = *char_trans;
    while (c != '\0' && c != 0) {
        draw_char(c, str_color, &c_trans, curr_pos, curr_color);

        c_width = font_widths[c];
        i += 1;
        c = str[i];
        // Move to the next character position
        c_trans.x += c_trans.scale * c_width / FONT_HEIGHT;
    }
 }
 
 __DEVICE__ int strlen(char a[]) {
    int i = 0;
    while (a[i] != '\0' && a[i] != 0) {
        ++i;
    }
    return i;
 }
 
 __DEVICE__ void strcpy(char str_src[], char str_dst[]) {
    int i = 0;
    while (str_src[i] != '\0' && i < 64) {
        str_dst[i] = str_src[i];
        i++;
    }
    str_dst[i] = '\0';
 }
 
 __DEVICE__ void strcat(char a[], char b[], char dest[]) {
    int len_a = strlen(a);
    int len_b = strlen(b);
    for (int i = 0; i < len_a; ++i) {
        dest[i] = a[i];
    }
    for (int i = 0; i < len_b; ++i) {
        dest[len_a + i] = b[i];
    }
    dest[len_a + len_b] = '\0';
 }
 
// Corrected float2str function
 __DEVICE__ void float2str(float f, char output[], int decimal_places) {
    int runner = 0;
    char inf[] = "inf";
    char nan[] = "NaN";

    if (f < 0) {
        output[runner++] = '-';
        f = -f;
    }

    if (isinf(f)) {
        strcpy(inf, output + runner);
        return;
    } else if (isnan(f)) {
        strcpy(nan, output + runner);
        return;
    }

    int int_part = (int)f;
    float frac_part = f - int_part;

    // Convert integer part
    int digits = 0;
    int temp_int = int_part;
    do {
        temp_int /= 10;
        digits++;
    } while (temp_int != 0);

    for (int i = digits - 1; i >= 0; i--) {
        output[runner + i] = '0' + int_part % 10;
        int_part /= 10;
    }
    runner += digits;

    output[runner++] = '.';

    // Convert fractional part
    for (int i = 0; i < decimal_places; i++) {
        frac_part *= 10.0f;
        int digit = (int)frac_part;
        output[runner++] = '0' + digit;
        frac_part -= digit;
    }

    output[runner] = '\0';
 }
 
 __DEVICE__ float string_width_in_units(char str[], float scale) {
    float width = 0.0f;
    int i = 0;
    char c = str[i];
    while (c != '\0' && c != 0) {
        int c_width = font_widths[c];
        width += scale * c_width / FONT_HEIGHT;
        i++;
        c = str[i];
    }
    return width;
 }
 
// Function to get the transfer function name based on index
 __DEVICE__ void get_tf_name(int index, char output[]) {
    switch (index) {
        case 0:
            strcpy("ARRI LogC3", output);
            break;
        case 1:
            strcpy("ARRI LogC4", output);
            break;
        case 2:
            strcpy("DaVinci Intermediate", output);
            break;
        case 3:
            strcpy("ACEScct", output);
            break;
        case 4:
            strcpy("RED Log3G10", output);
            break;
        case 5:
            strcpy("Sony S-Log2", output);
            break;
        case 6:
            strcpy("Sony S-Log3", output);
            break;        
        case 7:
            strcpy("BMD Film Gen 5", output);
            break;
        case 8:
            strcpy("Canon Log 3", output);
            break;
        case 9:
            strcpy("DJI D-Log", output);
            break;
        case 10:
            strcpy("FujiFilm F-Log", output);
            break;
        case 11:
            strcpy("FujiFilm F-Log2", output);
            break;
        case 12:
            strcpy("Panasonic V-Log", output);
            break;
        case 13:
            strcpy("gopro protune ", output);
            break;
        case 14:
            strcpy("Leica - Llog", output);
            break;
        case 15:
            strcpy("Nikon Nlog", output);
            break;
        case 16:
            strcpy("Filmlight T log", output);
            break;
        case 17:
            strcpy("Kodak Cineon", output);
            break;
        case 18:
            strcpy("Gamma 2.2", output);
            break;
        case 19:
            strcpy("Gamma 2.4", output);
            break;
        case 20:
            strcpy("Gamma 2.6", output);
            break;
        case 21:
            strcpy("Linear", output);
            break;
       default:
            strcpy("Unknown", output);
            break;
    }
 }

//  function to convert integer to string with sign
 __DEVICE__ void strcpy_idx(char str_src[], char str_dst[], int src_start_idx, int dst_start_idx, int num_chars) {
    for (int i = 0; i < num_chars; ++i) {
        str_dst[dst_start_idx + i] = str_src[src_start_idx + i];
    }
 }
 __DEVICE__ char digit2char(int i) {
    return (char)('0' + i);
 }
 
 __DEVICE__ void int2str(int f, char output[], int num_chars) {
    int runner = 0;

    // First char is neg sign, if necessary
    char zero[] = "0";

    if (f < 0) {
        output[runner] = '-';
        runner++;
        f = -f; // Convert to positive for processing
    }
    if (f == 0) {
        strcpy_idx(zero, output, 0, runner, strlen(zero));
        runner += strlen(zero);
    } else {
        // input is positive integer
        int left_digits = (int)(_log10f((float)f) + 1);

        // Extract left digits
        for (int i = left_digits; i > 0 && runner < num_chars; --i, ++runner) {
            float base = _powf(10.0, i - 1);
            int d = (int)_truncf(f / base);
            f = _fmod(f, base);
            output[runner] = digit2char(d);
        }
    }
    output[runner] = '\0';
 }
 
 __DEVICE__ void int2str_signed(int value, char output[]) {
    int runner = 0;
    if (value < 0) {
        output[runner++] = '-';
        value = -value;
    } else if (value > 0) {
        output[runner++] = '+';
    } else {
        output[runner++] = '0';
        output[runner] = '\0';
        return;
    }

    // Convert integer part
    int digits = 0;
    int temp = value;
    do {
        temp /= 10;
        digits++;
    } while (temp != 0);

    for (int i = digits - 1; i >= 0; i--) {
        int digit = value % 10;
        output[runner + i] = '0' + digit;
        value /= 10;
    }
    runner += digits;
    output[runner] = '\0';
 }
 
 



// Main transform function
__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B) {
    // Frame dimensions
    float frame_width = p_Width;
    float frame_height = p_Height;

    
    // Aspect ratio adjustments
     float x, y;
     if (opt_scope) {
        // Wide Aspect Mode (Aspect Ratio 2.5)
        float target_aspect = 2.5f;
        float current_aspect = frame_width / frame_height;

        if (current_aspect > target_aspect) {
            // Pillarboxing
            float new_width = frame_height * target_aspect;
            float pad_width = (frame_width - new_width) / 2.0f;

            if (p_X < pad_width || p_X >= frame_width - pad_width) {
                // Outside content area, set to black
                return make_float3(0.0f, 0.0f, 0.0f);
            }

            x = (p_X - pad_width) / new_width;
            y = p_Y / frame_height;
        } else {
            // Letterboxing
            float new_height = frame_width / target_aspect;
            float pad_height = (frame_height - new_height) / 2.0f;

            if (p_Y < pad_height || p_Y >= frame_height - pad_height) {
                // Outside content area, set to black
                return make_float3(0.0f, 0.0f, 0.0f);
            }

            x = p_X / frame_width;
            y = (p_Y - pad_height) / new_height;
        }
     } else {
        // Standard mode
        x = p_X / (frame_width - 1);
        y = p_Y / (frame_height - 1);
     }
 
     // Ensure x and y are within [0,1]
     if (x < 0.0f || x > 1.0f || y < 0.0f || y > 1.0f) {
         return make_float3(0.0f, 0.0f, 0.0f);
     }
 
    // Determine the mid-gray value to use
    float mid_gray_value;
    int slct_p_TF;
    if (opt_mid == 1) {
        // Custom Mid-Gray is enabled; use linear transfer function
        mid_gray_value = mid_gray;
        slct_p_TF = 21; // Linear
    } else {
        // Custom Mid-Gray is disabled; use predefined mid-gray and selected transfer function
        mid_gray_value = 0.18f;
        slct_p_TF = p_TF;
    }

    // Compute mid-gray in the transfer function space
    float3 mid_gray_tf = LinToTF(make_float3(mid_gray_value, mid_gray_value, mid_gray_value), slct_p_TF);
    float mid_gray_tf_value = mid_gray_tf.x; // Assuming R=G=B

    float step_width = 1.0f / num_steps;
    int middle_step = num_steps / 2;
    float3 Output;

    // Resolution-agnostic framing for the middle box
    float middle_box_left = 0.25f;
    float middle_box_right = 0.75f;
    float middle_box_top = 0.3f;
    float middle_box_bottom = 0.7f;

    // Variables for annotations
    int curr_step = (int)(x / step_width);
    float val;

    if (middle_box_left <= x && x <= middle_box_right && middle_box_top <= y && y <= middle_box_bottom) {
        // Middle box
        Output = mid_gray_tf;
    } else if (y <= 0.6f) {
        // Top half of chart, make steps
        val = mid_gray_value * _exp2f((float)curr_step - middle_step);
        Output = LinToTF(make_float3(val, val, val), slct_p_TF);
    } else if (y <= 1.f) {
        // Make exponential ramp
        val = mid_gray_value * _exp2f((float)(x / step_width) - 0.5f - middle_step);
        Output = LinToTF(make_float3(val, val, val), slct_p_TF);
    } else {
        // Outside the chart area, set to black
        Output = make_float3(0.0f, 0.0f, 0.0f);
    }

    if (opt_ramp) {
        // Make linear ramp using unaltered x position defined as cleanX 
   float cleanX = (float)p_X / ((float)p_Width-1);
   float3 ramp = make_float3(cleanX, cleanX, cleanX);
        Output = y >= 0.85f ? ramp: Output;
    }

    if (opt_card) {
        // Make gray card
        Output = mid_gray_tf;
    }

    // Initialize curr_color
    float3 curr_color = Output;

    // Current pixel position in normalized coordinates
    curr_pos_t curr_pos = make_curr_pos(x, y);

    // Annotation for Top Gradation Steps
    if (y <= 0.2f && y >= 0.09f && annotation_mode != ANNOTATE_NONE) {
        // Annotation area just below the steps
        float annotation_y = 0.15f; // Adjust as needed
        float annotation_scale = 0.035f; // Adjust text size

        // Compute position of current step
        float step_center = (curr_step + 0.5f) * step_width;

        // Determine if current pixel is within the annotation area for this step
        float annotation_height = annotation_scale; // Height of the annotation area
        float annotation_width = step_width; // Width of each step

        // Check if current pixel is within the annotation area
        if (x >= curr_step * step_width && x < (curr_step + 1) * step_width &&
            y >= annotation_y && y <= annotation_y + annotation_height) {

            // Prepare the annotation string
            char annotation_str[16];
            if (annotation_mode == ANNOTATE_MIDGRAY_BASELINE) {
                int stops = curr_step - middle_step;
                int2str_signed(stops, annotation_str);
            } else if (annotation_mode == ANNOTATE_START_FROM_ZERO) {
                int2str(curr_step, annotation_str, 3);
            }

            // Calculate annotation position
            float string_width = string_width_in_units(annotation_str, annotation_scale);
            float label_x = (curr_step + 0.5f) * step_width - string_width / 2.0f;

            // Ensure label is within bounds
            if (label_x < curr_step * step_width) label_x = curr_step * step_width;
            if (label_x + string_width > (curr_step + 1) * step_width) label_x = (curr_step + 1) * step_width - string_width;

            // Set label color (contrast with background)
            float lum = (curr_color.x + curr_color.y + curr_color.z) / 3.0f;
            float3 label_color = lum > 0.5f ? make_float3(0.0f, 0.0f, 0.0f) : make_float3(1.0f, 1.0f, 1.0f);

            // Create character transformation
            char_trans_t char_trans = make_char_trans(label_x, annotation_y, annotation_scale);

            // Draw the annotation string
            draw_string(annotation_str, label_color, &char_trans, &curr_pos, &curr_color);
        }
    }

    // Draw the label within the middle box if opt_label is true
    if (opt_label == 1 && middle_box_left <= x && x <= middle_box_right && middle_box_top <= y && y <= middle_box_bottom) {
        // Get the transfer function name
        char tf_name[64];
        get_tf_name(slct_p_TF, tf_name);

        // Convert mid_gray_tf_value to string with 4 decimal places
        char mid_gray_str[32];
        float2str(mid_gray_tf_value, mid_gray_str, 4); // 4 decimal places

        // Construct the mid-gray label string
        char mid_gray_label[64];
        strcpy("Mid Gray: ", mid_gray_label);
        strcat(mid_gray_label, mid_gray_str, mid_gray_label);

        // Character scales
        float scale_line1 = 0.054f; // Scale for the first line
        float scale_line2 = 0.035f; // Smaller scale for the second line

        // Compute string widths
        float width_line1 = string_width_in_units(tf_name, scale_line1);
        float width_line2 = string_width_in_units(mid_gray_label, scale_line2);
        float max_width = width_line1 > width_line2 ? width_line1 : width_line2;

        // Position the label within the middle box
        float label_x = 0.5f - max_width / 2.0f;

        // Ensure label is within the middle box bounds
        if (label_x < middle_box_left) label_x = middle_box_left;
        if (label_x + max_width > middle_box_right) label_x = middle_box_right - max_width;

        // Vertical positions for the two lines
        float label_y_line1 = 0.48f - scale_line1 / 2.0f; // Slightly above center
        float label_y_line2 = label_y_line1 + scale_line1 + 0.005f; // Slight gap between lines

        // Ensure labels are within the middle box bounds vertically
        if (label_y_line2 + scale_line2 > middle_box_bottom) {
            // Adjust both lines upwards if necessary
            float overflow = (label_y_line2 + scale_line2) - middle_box_bottom;
            label_y_line1 -= overflow;
            label_y_line2 -= overflow;
        }

        // Set label color (contrast with background)
        float lum = (curr_color.x + curr_color.y + curr_color.z) / 3.0f;
        float3 label_color = lum > 0.5f ? make_float3(0.0f, 0.0f, 0.0f) : make_float3(1.0f, 1.0f, 1.0f);

        // Draw the first line (Transfer Function Name)
        char_trans_t char_trans_line1 = make_char_trans(label_x, label_y_line1, scale_line1);
        draw_string(tf_name, label_color, &char_trans_line1, &curr_pos, &curr_color);

        // Draw the second line (Mid Gray Value) with smaller scale
        char_trans_t char_trans_line2 = make_char_trans(label_x, label_y_line2, scale_line2);
        draw_string(mid_gray_label, label_color, &char_trans_line2, &curr_pos, &curr_color);
    }

    return curr_color;
}
