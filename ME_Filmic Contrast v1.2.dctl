#line 2
//Flimic Contrast V1.2
//written by Moaz Elgabry


//functions for Transfer function conversion
 __DEVICE__ float3 LinToLogC3 (float3 in) {
    float3 out;

    float cut = 0.010591;
    float a = 5.555556;
    float b = 0.052272;
    float c = 0.247190;
    float d = 0.385537;
    float e = 5.367655;
    float f = 0.092809;

    out.x = (in.x > cut) ? c * log10(a * in.x + b) + d: e * in.x + f;
    out.y = (in.y > cut) ? c * log10(a * in.y + b) + d: e * in.y + f;
    out.z = (in.z > cut) ? c * log10(a * in.z + b) + d: e * in.z + f;

    return out;
    }
 
 __DEVICE__ float3 LogC3ToLin (float3 in) {
    float3 out;

    float cut = 0.010591;
    float a = 5.555556;
    float b = 0.052272;
    float c = 0.247190;
    float d = 0.385537;
    float e = 5.367655;
    float f = 0.092809;

    out.x = (in.x > e * cut + f) ? (_powf(10, (in.x - d) / c) - b) / a : (in.x - f) / e;
    out.y = (in.y > e * cut + f) ? (_powf(10, (in.y - d) / c) - b) / a : (in.y - f) / e;
    out.z = (in.z > e * cut + f) ? (_powf(10, (in.z - d) / c) - b) / a : (in.z - f) / e;

    return out;
    }//0
 
 __DEVICE__ float3 LinToDI (float3 in) {
    float3 out;

    float a = 0.0075;
    float b = 7.0;
    float c = 0.07329248;
    float m = 10.44426855;
    float lin_cut = 0.00262409;

    out.x = in.x > lin_cut ? (_log2f(in.x + a) + b) * c : out.x = in.x * m;
    out.y = in.y > lin_cut ? (_log2f(in.y + a) + b) * c : out.y = in.y * m;
    out.z = in.z > lin_cut ? (_log2f(in.z + a) + b) * c : out.z = in.z * m;

    return out;
    }
 
 __DEVICE__ float3 DItoLin (float3 in) {
    float3 out;

    float a = 0.0075;
    float b = 7.0;
    float c = 0.07329248;
    float m = 10.44426855;
    float log_cut = 0.02740668;

    out.x = in.x > log_cut ? _powf(2.f, (in.x / c) - b) - a : in.x / m;
    out.y = in.y > log_cut ? _powf(2.f, (in.y / c) - b) - a : in.y / m;
    out.z = in.z > log_cut ? _powf(2.f, (in.z / c) - b) - a : in.z / m;

    return out;
    }//2
 
 __DEVICE__ float3 LinToACEScct (float3 in) {
    float3 out;

    float a = 10.5402377416545;
    float b = 0.0729055341958355;
    float c = 9.72;
    float d = 17.52;
    float e = 0.0078125;

    out.x = in.x <= e ? a * in.x + b : (_log2f(in.x) + c) / d;
    out.y = in.y <= e ? a * in.y + b : (_log2f(in.y) + c) / d;
    out.z = in.z <= e ? a * in.z + b : (_log2f(in.z) + c) / d;

    return out;
    }
 
 __DEVICE__ float3 ACEScctToLin (float3 in) {
    float3 out;

    float a = 10.5402377416545;
    float b = 0.0729055341958355;
    float c = 9.72;
    float d = 17.52;
    float e = _log2f(65504);
    float lin_cut = 0.155251141552511;

    out.x = in.x <= lin_cut ? (in.x - b) / a : in.x < (e + c) / d ? _powf(2, in.x*d-c) : 65504;
    out.y = in.y <= lin_cut ? (in.y - b) / a : in.y < (e + c) / d ? _powf(2, in.y*d-c) : 65504;
    out.z = in.z <= lin_cut ? (in.z - b) / a : in.z < (e + c) / d ? _powf(2, in.z*d-c) : 65504;

    return out;
    }//3
 
 __DEVICE__ float3 LinToLogC4 (float3 in) {
    float3 out;

    float a = (_powf(2.0, 18.0) - 16.0) / 117.45;
    float b = (1023.0 - 95.0) / 1023.0;
    float c = 95.0 / 1023.0;
    float s = (7 * _logf(2) * _powf(2.0, 7 - 14 * c / b)) / (a * b);
    float t = (_powf(2.0, 14.0 * (-c / b) + 6.0) - 64.0) / a;

    out.x = in.x < t ? (in.x - t) / s : (_log2f( a * in.x + 64.0) - 6.0) / 14.0 * b + c;
    out.y = in.y < t ? (in.y - t) / s : (_log2f( a * in.y + 64.0) - 6.0) / 14.0 * b + c;
    out.z = in.z < t ? (in.z - t) / s : (_log2f( a * in.z + 64.0) - 6.0) / 14.0 * b + c;

    return out;
    }
 
 __DEVICE__ float3 LogC4ToLin (float3 in) {
    float3 out;

    float a = (_powf(2.0, 18.0) - 16.0) / 117.45;
    float b = (1023.0 - 95.0) / 1023.0;
    float c = 95.0 / 1023.0;
    float s = (7 * _logf(2) * _powf(2.0, 7 - 14 * c / b)) / (a * b);
    float t = (_powf(2.0, 14.0 * (-c / b) + 6.0) - 64.0) / a;

    out.x = in.x < 0.0 ? in.x * s + t : (_powf(2.0, 14.0 * (in.x - c) / b + 6.0) - 64.0) / a;
    out.y = in.y < 0.0 ? in.y * s + t : (_powf(2.0, 14.0 * (in.y - c) / b + 6.0) - 64.0) / a;
    out.z = in.z < 0.0 ? in.z * s + t : (_powf(2.0, 14.0 * (in.z - c) / b + 6.0) - 64.0) / a;

    return out;
    }//1
 
 __DEVICE__ float3 LinToDLog (float3 in) {
    float3 out;

    out.x = in.x <= 0.0078 ? 6.025 * in.x + 0.0929 : (_log10f(in.x * 0.9892 + 0.0108)) * 0.256663 + 0.584555;
    out.y = in.y <= 0.0078 ? 6.025 * in.y + 0.0929 : (_log10f(in.y * 0.9892 + 0.0108)) * 0.256663 + 0.584555;
    out.z = in.z <= 0.0078 ? 6.025 * in.z + 0.0929 : (_log10f(in.z * 0.9892 + 0.0108)) * 0.256663 + 0.584555;

    return out;
    }
 
 __DEVICE__ float3 DLogToLin (float3 in) {
    float3 out;

    out.x = in.x <= 0.14 ? (in.x - 0.0929) / 6.025 : (_powf(10, 3.89616 * in.x - 2.27752) - 0.0108) / 0.9892;
    out.y = in.y <= 0.14 ? (in.y - 0.0929) / 6.025 : (_powf(10, 3.89616 * in.y - 2.27752) - 0.0108) / 0.9892;
    out.z = in.z <= 0.14 ? (in.z - 0.0929) / 6.025 : (_powf(10, 3.89616 * in.z - 2.27752) - 0.0108) / 0.9892;

    return out;
    }
 
 __DEVICE__ float3 LinToFLog (float3 in) {
    float3 out;

    float a = 0.555556;
    float b = 0.009468;
    float c = 0.344676;
    float d = 0.790453;
    float e = 8.735631;
    float f = 0.092864;
    float cut = 0.00089;

    out.x = in.x >= cut ? c * _log10f(a * in.x + b) + d : e * in.x + f;
    out.y = in.y >= cut ? c * _log10f(a * in.y + b) + d : e * in.y + f;
    out.z = in.z >= cut ? c * _log10f(a * in.z + b) + d : e * in.z + f;

    return out;
    }
 
 __DEVICE__ float3 FLogToLin (float3 in) {
    float3 out;

    float a = 0.555556;
    float b = 0.009468;
    float c = 0.344676;
    float d = 0.790453;
    float e = 8.735631;
    float f = 0.092864;
    float cut = 0.100537775223865;

    out.x = in.x >= cut ? _powf(10, ((in.x - d) / c)) / a - b / a : (in.x - f) / e;
    out.y = in.y >= cut ? _powf(10, ((in.y - d) / c)) / a - b / a : (in.y - f) / e;
    out.z = in.z >= cut ? _powf(10, ((in.z - d) / c)) / a - b / a : (in.z - f) / e;

    return out;
    }
 
 __DEVICE__ float3 LinToFLog2 (float3 in) {
    float3 out;

    float a = 5.555556;
    float b = 0.064829;
    float c = 0.245281;
    float d = 0.384316;
    float e = 8.799461;
    float f = 0.092864;
    float cut = 0.000889;

    out.x = in.x >= cut ? c * _log10f(a * in.x + b) + d : e * in.x + f;
    out.y = in.y >= cut ? c * _log10f(a * in.y + b) + d : e * in.y + f;
    out.z = in.z >= cut ? c * _log10f(a * in.z + b) + d : e * in.z + f;

    return out;
    }
 
 __DEVICE__ float3 FLog2ToLin (float3 in) {
    float3 out;

    float a = 5.555556;
    float b = 0.064829;
    float c = 0.245281;
    float d = 0.384316;
    float e = 8.799461;
    float f = 0.092864;
    float cut = 0.100686685370811;

    out.x = in.x >= cut ? _powf(10, ((in.x - d) / c)) / a - b / a : (in.x - f) / e;
    out.y = in.y >= cut ? _powf(10, ((in.y - d) / c)) / a - b / a : (in.y - f) / e;
    out.z = in.z >= cut ? _powf(10, ((in.z - d) / c)) / a - b / a : (in.z - f) / e;

    return out;
    }
 
 __DEVICE__ float3 LinToVLog (float3 in) {
    float3 out;

    float cut = 0.01;
    float b = 0.00873;
    float c = 0.241514;
    float d = 0.598206;

    out.x = in.x < cut ? 5.6 * in.x + 0.125 : c * _log10f(in.x + b) + d;
    out.y = in.y < cut ? 5.6 * in.y + 0.125 : c * _log10f(in.y + b) + d;
    out.z = in.z < cut ? 5.6 * in.z + 0.125 : c * _log10f(in.z + b) + d;

    return out;
    }
 
 __DEVICE__ float3 VLogToLin (float3 in) {
    float3 out;

    float cut = 0.181;
    float b = 0.00873;
    float c = 0.241514;
    float d = 0.598206;

    out.x = in.x < cut ? (in.x - 0.125) / 5.6 : _powf(10.0, ((in.x - d) / c)) - b;
    out.y = in.y < cut ? (in.y - 0.125) / 5.6 : _powf(10.0, ((in.y - d) / c)) - b;
    out.z = in.z < cut ? (in.z - 0.125) / 5.6 : _powf(10.0, ((in.z - d) / c)) - b;

    return out;
    }
 
 __DEVICE__ float3 LinToLog3G10 (float3 in) {
    float3 out;

    float a = 0.224282f;
    float b = 155.975327f;
    float c = 0.01f;
    float g = 15.1927f;

    in.x += c;
    in.y += c;
    in.z += c;

    out.x = in.x < 0.0f ? in.x * g : a * _log10f((in.x * b) + 1.0f);
    out.y = in.y < 0.0f ? in.y * g : a * _log10f((in.y * b) + 1.0f);
    out.z = in.z < 0.0f ? in.z * g : a * _log10f((in.z * b) + 1.0f);

    return out;
    }
 
 __DEVICE__ float3 Log3G10toLin (float3 in) {
    float3 out;

    float a = 0.224282f;
    float b = 155.975327f;
    float c = 0.01f;
    float g = 15.1927f;

    out.x = in.x < 0.0f ? (in.x / g) - c : (_powf(10.0f, in.x / a) - 1.0f) / b;
    out.y = in.y < 0.0f ? (in.y / g) - c : (_powf(10.0f, in.y / a) - 1.0f) / b;
    out.z = in.z < 0.0f ? (in.z / g) - c : (_powf(10.0f, in.z / a) - 1.0f) / b;

    out.x -= c;
    out.y -= c;
    out.z -= c;

    return out;
    }
 
 __DEVICE__ float3 LinToSLog3 (float3 in) {
    float3 out;

    out.x = in.x >= 0.01125000 ? (420.0 + _log10f((in.x + 0.01) / (0.18 + 0.01)) * 261.5) / 1023.0 : (in.x * (171.2102946929 - 95.0)/0.01125000 + 95.0) / 1023.0;
    out.y = in.y >= 0.01125000 ? (420.0 + _log10f((in.y + 0.01) / (0.18 + 0.01)) * 261.5) / 1023.0 : (in.y * (171.2102946929 - 95.0)/0.01125000 + 95.0) / 1023.0;
    out.z = in.z >= 0.01125000 ? (420.0 + _log10f((in.z + 0.01) / (0.18 + 0.01)) * 261.5) / 1023.0 : (in.z * (171.2102946929 - 95.0)/0.01125000 + 95.0) / 1023.0;    

    return out;
    }
 
 __DEVICE__ float3 SLog3ToLin (float3 in) {
    float3 out;

    out.x = in.x >= 171.2102946929 / 1023.0 ? (_powf(10.0, ((in.x * 1023.0 - 420.0) / 261.5))) * (0.18 + 0.01) - 0.01 : (in.x * 1023.0 - 95.0) * 0.01125000 / (171.2102946929 - 95.0);
    out.y = in.y >= 171.2102946929 / 1023.0 ? (_powf(10.0, ((in.y * 1023.0 - 420.0) / 261.5))) * (0.18 + 0.01) - 0.01 : (in.y * 1023.0 - 95.0) * 0.01125000 / (171.2102946929 - 95.0);
    out.z = in.z >= 171.2102946929 / 1023.0 ? (_powf(10.0, ((in.z * 1023.0 - 420.0) / 261.5))) * (0.18 + 0.01) - 0.01 : (in.z * 1023.0 - 95.0) * 0.01125000 / (171.2102946929 - 95.0);

    return out;
    }
 
 __DEVICE__ float3 LinToBMDFilmGen5(float3 in) {
    float3 out;

    float a = 8.283605932402494f;
    float b = 0.09246575342465753f;
    float c = 0.5300133392291939f;
    float d = 0.08692876065491224f;
    float e = 0.005494072432257808f;
    float cut = 0.005f;

    out.x = in.x < cut ? a * in.x + b : d * _logf(in.x + e) + c;
    out.y = in.y < cut ? a * in.y + b : d * _logf(in.y + e) + c;
    out.z = in.z < cut ? a * in.z + b : d * _logf(in.z + e) + c;

    return out;
    }
 
 __DEVICE__ float3 BMDFilmGen5ToLin(float3 in) {
    float3 out;

    float a = 8.283605932402494f;
    float b = 0.09246575342465753f;
    float c = 0.5300133392291939f;
    float d = 0.08692876065491224f;
    float e = 0.005494072432257808f;
    float cut = a * 0.005f + b;

    out.x = in.x < (a * 0.005f + b) ? (in.x - b) / a : _expf((in.x - c) / d) - e;
    out.y = in.y < (a * 0.005f + b) ? (in.y - b) / a : _expf((in.y - c) / d) - e;
    out.z = in.z < (a * 0.005f + b) ? (in.z - b) / a : _expf((in.z - c) / d) - e;

    return out;
    }
 
 __DEVICE__ float3 LinToCLog (float3 in) {
    float3 out;

    out.x = in.x < 0 ? -.529136 * _log10f(1 - 10.1596 * in.x) + 0.0730597 : .529136 * _log10f(10.1596 * in.x + 1) + 0.0730597;
    out.y = in.y < 0 ? -.529136 * _log10f(1 - 10.1596 * in.y) + 0.0730597 : .529136 * _log10f(10.1596 * in.y + 1) + 0.0730597;
    out.z = in.z < 0 ? -.529136 * _log10f(1 - 10.1596 * in.z) + 0.0730597 : .529136 * _log10f(10.1596 * in.z + 1) + 0.0730597;

    return out;
    }
 
 __DEVICE__ float3 CLogToLin (float3 in) {
    float3 out;

    out.x = in.x < 0.0730597 ? -(_powf(10, (0.0730597 - in.x) / .529136) - 1) / 10.1596 : (_powf(10, (in.x - 0.0730597) / .529136) - 1) / 10.1596;
    out.y = in.y < 0.0730597 ? -(_powf(10, (0.0730597 - in.y) / .529136) - 1) / 10.1596 : (_powf(10, (in.y - 0.0730597) / .529136) - 1) / 10.1596;
    out.z = in.z < 0.0730597 ? -(_powf(10, (0.0730597 - in.z) / .529136) - 1) / 10.1596 : (_powf(10, (in.z - 0.0730597) / .529136) - 1) / 10.1596;

    return out;
    }
 
 __DEVICE__ float3 LinToCLog2 (float3 in) {
    float3 out;

    out.x = in.x < 0 ? -0.24136077 * _log10f(1 - 87.099375 * in.x) + 0.092864125 : 0.24136077 * _log10f(87.099375 * in.x + 1) + 0.092864125;
    out.y = in.y < 0 ? -0.24136077 * _log10f(1 - 87.099375 * in.y) + 0.092864125 : 0.24136077 * _log10f(87.099375 * in.y + 1) + 0.092864125;
    out.z = in.z < 0 ? -0.24136077 * _log10f(1 - 87.099375 * in.z) + 0.092864125 : 0.24136077 * _log10f(87.099375 * in.z + 1) + 0.092864125;

    return out;
    }
 
 __DEVICE__ float3 CLog2ToLin (float3 in) {
    float3 out;

    out.x = in.x < 0.092864125 ? -(_powf(10, (0.092864125 - in.x) / 0.24136077) - 1) / 87.099375 : (_powf(10, (in.x - 0.092864125) / 0.24136077) - 1) / 87.099375;
    out.y = in.y < 0.092864125 ? -(_powf(10, (0.092864125 - in.y) / 0.24136077) - 1) / 87.099375 : (_powf(10, (in.y - 0.092864125) / 0.24136077) - 1) / 87.099375;
    out.z = in.z < 0.092864125 ? -(_powf(10, (0.092864125 - in.z) / 0.24136077) - 1) / 87.099375 : (_powf(10, (in.z - 0.092864125) / 0.24136077) - 1) / 87.099375;

    return out;
    }
 
 __DEVICE__ float3 LinToCLog3 (float3 in) {
    float3 out;

    out.x = in.x < -0.014 ? -0.36726845 * _log10f(1 - 14.98325 * in.x) + 0.12783901 : in.x <= 0.014 ? 1.9754798 * in.x + 0.12512219 : 0.36726845 * _log10f(14.98325 * in.x + 1) + 0.12240537;
    out.y = in.y < -0.014 ? -0.36726845 * _log10f(1 - 14.98325 * in.y) + 0.12783901 : in.y <= 0.014 ? 1.9754798 * in.y + 0.12512219 : 0.36726845 * _log10f(14.98325 * in.y + 1) + 0.12240537;
    out.z = in.z < -0.014 ? -0.36726845 * _log10f(1 - 14.98325 * in.z) + 0.12783901 : in.z <= 0.014 ? 1.9754798 * in.z + 0.12512219 : 0.36726845 * _log10f(14.98325 * in.z + 1) + 0.12240537;

    return out;
    }
 
 __DEVICE__ float3 CLog3ToLin (float3 in) {
    float3 out;

    out.x = in.x < 0.097465473 ? -(_powf(10, (0.12783901 - in.x) / 0.36726845) - 1) / 14.98325 : in.x <= 0.15277891 ? (in.x - 0.12512219) / 1.9754798 : (_powf(10, (in.x - 0.12240537) / 0.36726845) - 1) / 14.98325;
    out.y = in.y < 0.097465473 ? -(_powf(10, (0.12783901 - in.y) / 0.36726845) - 1) / 14.98325 : in.y <= 0.15277891 ? (in.y - 0.12512219) / 1.9754798 : (_powf(10, (in.y - 0.12240537) / 0.36726845) - 1) / 14.98325;
    out.z = in.z < 0.097465473 ? -(_powf(10, (0.12783901 - in.z) / 0.36726845) - 1) / 14.98325 : in.z <= 0.15277891 ? (in.z - 0.12512219) / 1.9754798 : (_powf(10, (in.z - 0.12240537) / 0.36726845) - 1) / 14.98325;

    return out;
    }
 
 
 __DEVICE__ float3 GammaCurveToLin (float3 in, float gamma) {
    float3 out;

    out.x = _powf(_fmaxf(in.x, 0.0f), gamma);
    out.y = _powf(_fmaxf(in.y, 0.0f), gamma);
    out.z = _powf(_fmaxf(in.z, 0.0f), gamma);

    return out;
    }  
 
 __DEVICE__ float3 LinToGammaCurve (float3 in, float gamma) {
    float3 out;

    out.x = _powf(_fmaxf(in.x, 0.0f), (1 / gamma));
    out.y = _powf(_fmaxf(in.y, 0.0f), (1 / gamma));
    out.z = _powf(_fmaxf(in.z, 0.0f), (1 / gamma));

    return out;
    }
 
 
//functions that convert between color models

 __DEVICE__ float3 RGB_to_HSV(float3 RGB) {
    float3 HSV;
    float min = _fminf(_fminf(RGB.x, RGB.y), RGB.z);
    float max = _fmaxf(_fmaxf(RGB.x, RGB.y), RGB.z);
    HSV.z = max;
    float delta = max - min;
    if (max != 0.0f) {
    HSV.y = delta / max;
    } else {
    HSV.y = 0.0f;
    HSV.x = 0.0f;
    return HSV;
    }
    if (delta == 0.0f) {
    HSV.x = 0.0f;
    } else if (RGB.x == max) {
    HSV.x = (RGB.y - RGB.z) / delta;
    } else if (RGB.y == max) {
    HSV.x = 2.0f + (RGB.z - RGB.x) / delta;
    } else {
    HSV.x = 4.0f + (RGB.x - RGB.y) / delta;
    }
    HSV.x *= 1.0f / 6.0f;
    if (HSV.x < 0.0f)
    HSV.x += 1.0f;
    return HSV;
    } //Convert to HSV
 
 __DEVICE__ float3 HSV_to_RGB(float3 HSV) {
    float3 RGB;
    if (HSV.y == 0.0f) {
    RGB.x = RGB.y = RGB.z = HSV.z;
    } else {
    HSV.x *= 6.0f;
    int i = floor(HSV.x);
    float f = HSV.x - i;
    i = (i >= 0) ? (i % 6) : (i % 6) + 6;
    float p = HSV.z * (1.0f - HSV.y);
    float q = HSV.z * (1.0f - HSV.y * f);
    float t = HSV.z * (1.0f - HSV.y * (1.0f - f));
    RGB.x = i == 0 ? HSV.z : i == 1 ? q : i == 2 ? p : i == 3 ? p : i == 4 ? t : HSV.z;
    RGB.y = i == 0 ? t : i == 1 ? HSV.z : i == 2 ? HSV.z : i == 3 ? q : i == 4 ? p : p;
    RGB.z = i == 0 ? p : i == 1 ? p : i == 2 ? t : i == 3 ? HSV.z : i == 4 ? HSV.z : q;
    }
    return RGB;
    } //Convert from HSV to RGB

   __DEVICE__ float3 RGB_to_cone(float3 rgb) {
    const float pi= 3.14159265359f;
    const float rtr = rgb.x * 0.81649658f + rgb.y * -0.40824829f + rgb.z * -0.40824829f;
    const float rtg = rgb.x * 0.0f + rgb.y * 0.70710678f + rgb.z * -0.70710678f;
    const float rtb = rgb.x * 0.57735027f + rgb.y * 0.57735027f + rgb.z * 0.57735027f;

    const float art = _atan2f(rtg, rtr);

    const float sphr = _sqrtf(rtr*rtr + rtg*rtg + rtb*rtb);
    const float spht = art < 0.0f ? art + 2.0f * 3.141592653589f : art;
    const float sphp = _atan2f(_sqrtf(rtr*rtr + rtg*rtg), rtb);

 //This is to modify the lum component which is the main reason why the saturation component has a different behavior 
    const float huecoef1= 1.0f/(2.0f-(0.78539816f/0.61547971f));
    const float huecoef2 = 2.0f*sphp*_sinf((2.0f*pi/3.0f)-_fmod(spht,(pi/3.0f)))/1.7320508075688f;
    const float huemag =((_acosf(_cosf(3.0f*spht+pi)))/(pi*huecoef1)+(((0.78539816f/0.61547971f))-1.0f))*huecoef2;
    const float satmag = _sinf(huemag+0.61547971f);



    return make_float3(
        sphr*satmag,
        spht * 0.15915494309189535f,
        sphp * 1.0467733744265997f
    );
       } //Convert to cone cordinates by Juan Pablo Zambrano
   
   __DEVICE__ float3 cone_to_RGB(float3 sph) {
    
    const float pi= 3.14159265359f;
    sph.y *= 6.283185307179586f;
    sph.z *= 0.9553166181245093f;
    const float huecoef1= 1.0f/(2.0f-(0.78539816f/0.61547971f));
    const float huecoef2 = 2.0f*sph.z*_sinf((2.0f*pi/3.0f)- _fmod(sph.y,(pi/3.0f)))/1.7320508075688f;
    const float huemag =((_acosf(_cosf(3.0f*sph.y+pi)))/(pi*huecoef1)+(((0.78539816f/0.61547971f))-1.0f))*huecoef2;
    const float satmagsp = _sinf(huemag+0.61547971f);
    sph.x *= 1.0f/satmagsp;

    const float ctr = sph.x * _sinf(sph.z) * _cosf(sph.y);
    const float ctg = sph.x * _sinf(sph.z) * _sinf(sph.y);
    const float ctb = sph.x * _cosf(sph.z);

    return make_float3(
        ctr * 0.81649658f + ctg * 0.0f + ctb * 0.57735027f,
        ctr * -0.40824829f + ctg * 0.70710678f + ctb * 0.57735027f,
        ctr * -0.40824829f + ctg * -0.70710678f + ctb * 0.57735027f
    );
       } // convert from cone to RGB
   
   __DEVICE__ float3 RGBtoCHEN(float3 in) {
    float r = in.x;
    float g = in.y;
    float b = in.z;

    float h;
    float c;
    float l;

    const float rtr = r * 0.81649658f + g * -0.40824829f + b * -0.40824829f;
    const float rtg = r * 0.0f + g * 0.70710678f + b * -0.70710678f;
    const float rtb = r * 0.57735027f + g * 0.57735027f + b * 0.57735027f;

    const float art = _atan2f(rtg, rtr);

    const float sphr = _sqrtf(rtr*rtr + rtg*rtg + rtb*rtb);
    const float spht = art < 0.0f ? art + 2.0f * 3.141592653589f : art;
    const float sphp = _atan2f(_sqrtf(rtr*rtr + rtg*rtg), rtb);

    l = sphr * 0.5773502691896258f;
    h = spht * 0.15915494309189535f;
    c = sphp * 1.0467733744265997f;

    return make_float3(h, c, l);
    } //by Kaur Hendrikson
   
   __DEVICE__ float3 CHENtoRGB(float3 in) {
    float h = in.x * 6.283185307179586f;
    float c = in.y * 0.9553166181245093f;
    float l = in.z * 1.7320508075688772f;
    
   float r = 0;
   float g = 0;
   float b = 0;

    const float ctr = l * _sinf(c) * _cosf(h);
    const float ctg = l * _sinf(c) * _sinf(h);
    const float ctb = l * _cosf(c);

    r = ctr * 0.81649658f + ctg * 0.0f + ctb * 0.57735027f;
    g = ctr * -0.40824829f + ctg * 0.70710678f + ctb * 0.57735027f;
    b = ctr * -0.40824829f + ctg * -0.70710678f + ctb * 0.57735027f;

    return make_float3(r, g, b);
    } //by Kaur Hendrikson
 


// Helper functions
 
 __DEVICE__ float powf(float base, float exp) {
     return _copysignf(_powf(_fabs(base), exp), base);
     }
 
 __DEVICE__ float pow2f(float base) {
     return _powf(_fabs(base), 2.0);
     }
 
 __DEVICE__ float maxf3(float3 x) {
     return _fmaxf(_fmaxf(x.x, x.y), x.z);
     }
 
 __DEVICE__ float minf3(float3 x) {
     return _fminf(_fminf(x.x, x.y), x.z);
     }
 
 __DEVICE__ float3 powf3(float3 base, float exp) {
     return make_float3(powf(base.x, exp), powf(base.y, exp), powf(base.z, exp));
     }
     

//functions to apply transfer function conversions
 
 __DEVICE__ float3 GammaToLin (float3 in, int gamma) {

    if (gamma ==  0) return LogC3ToLin(in);
    if (gamma ==  1) return LogC4ToLin(in);
    if (gamma ==  2) return DItoLin(in);
    if (gamma ==  3) return ACEScctToLin (in);
    if (gamma ==  4) return Log3G10toLin(in);
    if (gamma ==  5) return SLog3ToLin(in);
    if (gamma ==  6) return BMDFilmGen5ToLin(in);
    if (gamma ==  7) return CLog3ToLin(in);
    if (gamma ==  8) return DLogToLin(in);
    if (gamma ==  9) return FLogToLin(in);
    if (gamma == 10) return FLog2ToLin(in);
    if (gamma == 11) return VLogToLin(in);
    if (gamma == 12) return GammaCurveToLin(in, 2.2);
    if (gamma == 13) return GammaCurveToLin(in, 2.4);
    if (gamma == 14) return GammaCurveToLin(in, 2.6);
    if (gamma == 15) return in; // Lin


    return make_float3(0, 0, 1); // Blue on error
    }
 
 __DEVICE__ float3 LinToGamma (float3 in, int gamma) {
    if (gamma ==  0) return LinToLogC3(in);
    if (gamma ==  1) return LinToLogC4(in);
    if (gamma ==  2) return LinToDI(in);
    if (gamma ==  3) return LinToACEScct(in);
    if (gamma ==  4) return LinToLog3G10(in);
    if (gamma ==  5) return LinToSLog3(in);
    if (gamma ==  6) return LinToBMDFilmGen5(in);
    if (gamma ==  7) return LinToCLog3(in);
    if (gamma ==  8) return LinToDLog(in);
    if (gamma ==  9) return LinToFLog(in);
    if (gamma == 10) return LinToFLog2(in);
    if (gamma == 11) return LinToVLog(in);
    if (gamma == 12) return LinToGammaCurve(in, 2.2);
    if (gamma == 13) return LinToGammaCurve(in, 2.4);
    if (gamma == 14) return LinToGammaCurve(in, 2.6);
    if (gamma == 15) return in; // Lin


    
    return make_float3(0, 1, 0); // Green on error
    }
 
 __DEVICE__ float set_pivot (float pivot, int gamma) {
    float p_transfer_f = gamma;
    float midgray;
    const float logc3_gray = 0.39101f;
    const float logc4_gray = 0.2784f;
    const float DI_gray = 0.33604f;
    const float ACEScct_gray = 0.41359f;
    const float log3g10_gray = 0.3333f;
    const float slog3_gray = 0.41056f;
    const float bmd_f5_gray = 0.38356f;
    const float clog3_gray = 0.34339f;
    const float dlog_gray = 0.39876f;
    const float fLog_gray = 0.45932f;
    const float fLog2_gray = 0.39101f;
    const float vlog_gray = 0.42331f;
    const float g22_gray = 0.45866f;
    const float g24_gray = 0.48944f;
    const float g26_gray = 0.51709f;
    const float linear_gray = 0.18f;

    if (p_transfer_f ==  0) { midgray = logc3_gray;}
    if (p_transfer_f ==  1) { midgray = logc4_gray; }
    if (p_transfer_f ==  2) { midgray = DI_gray;}
    if (p_transfer_f ==  3) { midgray = ACEScct_gray;}
    if (p_transfer_f ==  4) { midgray = log3g10_gray;}
    if (p_transfer_f ==  5) { midgray = slog3_gray;}
    if (p_transfer_f ==  6) { midgray = bmd_f5_gray;}
    if (p_transfer_f ==  7) { midgray = clog3_gray;}
    if (p_transfer_f ==  8) { midgray = dlog_gray;}
    if (p_transfer_f ==  9) { midgray = fLog_gray;}
    if (p_transfer_f == 10) { midgray = fLog2_gray;}
    if (p_transfer_f == 11) { midgray = vlog_gray;}
    if (p_transfer_f == 12) { midgray = g22_gray;}
    if (p_transfer_f == 13) { midgray = g24_gray;}
    if (p_transfer_f == 14) { midgray = g26_gray;}
    if (p_transfer_f == 15) { midgray = linear_gray;}
    
    float3 get_mid = make_float3(0.18f, 0.18f,0.18f);
    get_mid = LinToGamma(get_mid, p_transfer_f);
    //get_mid = maxf3(get_mid);
    midgray = get_mid.x;

    pivot = _clampf(( pivot + midgray), 0.02f, 1.0f); //clamping to 0 caused artifacts
    
    return pivot;
    }



//functions for the main functionality of contrast 

  __DEVICE__ float apply_linear_contrast (float in, float contrast, float pivot) {
    
    float out = in;
    //offsetting the user slider to set the starting point at zero
    contrast = contrast+1;
    //limit user input to zero
    if (contrast <0) {contrast = _fmaxf(contrast, 0.0f);}

    out = (in - pivot) * contrast + pivot;


    return out;
     }
 
 __DEVICE__ float3 apply_linear_contrastf3 (float3 in, float contrast, float pivot) {
   float3 out = in;

   out.x = apply_linear_contrast (out.x, contrast, pivot);
   out.y = apply_linear_contrast (out.y, contrast, pivot);
   out.z = apply_linear_contrast (out.z, contrast, pivot);

   return out;
  }
  __DEVICE__ float apply_rolling_contrast (float in, float contrast, float pivot) {
   float out = in;
       //offsett the user slider to set the starting point at zero instead of 1
   contrast = contrast + 1.f;


    // apply rolling contrast

   if (in <= pivot) {out = powf((in / pivot) , contrast) * pivot;} 
        if (in > pivot) {
            in = 1 - in; 
            pivot = 1 - pivot;
            out = powf((in / pivot) , contrast) * pivot;
            out = 1 - out;
            pivot = 1 - pivot;
        }
   return out;
 
  }
  __DEVICE__ float3 apply_rolling_contrastf3 (float3 in, float contrast, float pivot) {
    
    float3 out = in;

    // apply rolling contrast to 3 channels
    out.x = apply_rolling_contrast (out.x, contrast, pivot);
    out.y = apply_rolling_contrast (out.y, contrast, pivot);
    out.z = apply_rolling_contrast (out.z, contrast, pivot);
    
    return out;
 
     }
  
  __DEVICE__ float3 apply_white_point (float3 in, float white_point, float pivot, float shoulder_strength) {
   
   float3 out = in; 
   float scale_factor;
   
   if (in.x > pivot) {
    scale_factor = (1.0f - pivot) / _powf(_powf((white_point - pivot) / (1.0f - pivot), -1.0f*shoulder_strength) - 1.0f, 1.0f/shoulder_strength);
    
    out.x = pivot + scale_factor *((in.x - pivot) / scale_factor) / (_powf(1.0f + _powf((in.x - pivot) / scale_factor, shoulder_strength), 1.0f / shoulder_strength));

    }

        else {
           
        out.x = in.x;
        
        }

   if (in.y > pivot) {
    scale_factor = (1.0f - pivot) / _powf(_powf((white_point - pivot) / (1.0f - pivot), -1.0f*shoulder_strength) - 1.0f, 1.0f/shoulder_strength);
    
    out.y = pivot + scale_factor *((in.y - pivot) / scale_factor) / (_powf(1.0f + _powf((in.y - pivot) / scale_factor, shoulder_strength), 1.0f / shoulder_strength));

    }

        else {
           
        out.y = in.y;
        
        }

   if (in.z > pivot) {
    scale_factor = (1.0f - pivot) / _powf(_powf((white_point - pivot) / (1.0f - pivot), -1.0f*shoulder_strength) - 1.0f, 1.0f/shoulder_strength);
    
    out.z = pivot + scale_factor *((in.z - pivot) / scale_factor) / (_powf(1.0f + _powf((in.z - pivot) / scale_factor, shoulder_strength), 1.0f / shoulder_strength));

    }

        else {
           
        out.z = in.z;
        
        }

    return out;
 
     }
  
  __DEVICE__ float3 apply_black_point (float3 in, float black_point, float pivot, float toe_str) {

      float3 out = in; 
      
      in.x = 1.0f - in.x;
      in.y = 1.0f - in.y ;
      in.z = 1.0f - in.z ;
      
      float scale_factor;
      
    if (in.x > pivot) {
    scale_factor = (1.0f - pivot) / _powf(_powf((black_point - pivot) / (1.0f - pivot), -1.0f*toe_str) - 1.0f, 1.0f/toe_str);
    
    out.x = pivot + scale_factor *((in.x - pivot) / scale_factor) / (_powf(1.0f + _powf((in.x - pivot) / scale_factor, toe_str), 1.0f / toe_str));
    }
    
            else {
           
        out.x = in.x;
        
        }
    
    if (in.y > pivot) {

    scale_factor = (1.0f - pivot) / _powf(_powf((black_point - pivot) / (1.0f - pivot), -1.0f*toe_str) - 1.0f, 1.0f/toe_str);
    
    out.y = pivot + scale_factor *((in.y - pivot) / scale_factor) / (_powf(1.0f + _powf((in.y - pivot) / scale_factor, toe_str), 1.0f / toe_str));

    }
    
            else {
           
        out.y = in.y;
        
        }
    
    if (in.z > pivot) {
    scale_factor = (1.0f - pivot) / _powf(_powf((black_point - pivot) / (1.0f - pivot), -1.0f*toe_str) - 1.0f, 1.0f/toe_str);
    
    out.z = pivot + scale_factor *((in.z - pivot) / scale_factor) / (_powf(1.0f + _powf((in.z - pivot) / scale_factor, toe_str), 1.0f / toe_str));

    }
    
            else {
           
        out.z = in.z;
        
        }

    out.x = 1 - out.x;
    out.y = 1 - out.y;
    out.z = 1 - out.z;
   
   return out;
    
        }
    

//functions for implementing the feathered luma mask
     __DEVICE__ float smoothstep(float x) {
    x = _clampf(x, 0.0, 1.0);
    return 3.0 * powf(x, 2.0) - 2.0 * powf(x, 3.0);}

   __DEVICE__ float3 HiLoLumaMask (float3 in, float3 base, float HiThreshold, float HiFeather, float LoThreshold,  float LoFeather, float TF, float factor, float alpha, int X, int Y)  {
      float3 mid_grey_f3 = LinToGamma(make_float3 (0.18,0.18,0.18), TF);
      float mid_grey = mid_grey_f3.x;
      //float pxlX = (float)X;
      //float pxlY = (float)Y;

      //mid_grey = 0.18;
      

      float Lo_min = mid_grey * _exp2f(LoThreshold - 0.5 * LoFeather);
      float Lo_max = mid_grey * _exp2f(LoThreshold + 0.5 * LoFeather);
      float Hi_min = mid_grey * _exp2f(HiThreshold - 0.5 * HiFeather);
      float Hi_max = mid_grey * _exp2f(HiThreshold + 0.5 * HiFeather);            
      float input_metric = _fmaxf(_fmaxf(base.x, base.y), base.z);

      float input_metric_log = _log2f(_fmaxf(input_metric, 0.0));
      float Hi_min_log = _log2f(Hi_min);
      float Hi_max_log = _log2f(Hi_max);
      float Lo_min_log = _log2f(Lo_min);
      float Lo_max_log = _log2f(Lo_max);

      float shadow_mask;
          if (input_metric < Lo_min) {
              shadow_mask = 1.0;
          } else if (Lo_max < input_metric) {
              shadow_mask = 0.0;
          } else {
              shadow_mask = _mix(1.0, 0.0, smoothstep((input_metric_log - Lo_min_log) / (Lo_max_log - Lo_min_log)));
          }
      

      float highlight_mask;
          if (input_metric < Hi_min) {
              highlight_mask = 1.0;
           } 
          else if (Hi_max < input_metric) {
              highlight_mask = 0.0;
          } 
          else {
              highlight_mask = _mix(1.0, 0.0, smoothstep((input_metric_log - Hi_min_log) / (Hi_max_log - Hi_min_log)));

           }
                 highlight_mask = 1- highlight_mask;       

          float HiLo_mask = shadow_mask + highlight_mask;
           HiLo_mask = 1- _saturatef(HiLo_mask);



         float3 pinends = _mix(base,in,HiLo_mask);

         float3 output = _mix(in, pinends, factor);



            float highlight_r = 0.0;
            float highlight_g = 0.4;
            float highlight_b = 0.35;
            float3 Checker = make_float3(highlight_r, highlight_g, highlight_b);
            float checker_size = 5;
            if (((int)(X / checker_size) + (int)(Y / checker_size)) % 2 == 0) {Checker = make_float3(1.0 - highlight_r, 1.0 - highlight_g, 1.0 - highlight_b);}

         if (alpha) {

            return _mix(Checker,output,_saturatef(HiLo_mask));
           }

         
         return output;



      }

//A function that applies contrast to only the luma channel in a CHEN color model image state before mixing it with the contrast applied to RGB

 __DEVICE__ float3 mix_sat (float3 in_1, float3 in_2, float p_mix_sat, float contrast, float pivot) { 
 
 in_2 = RGBtoCHEN(in_2);
 in_2.z = apply_rolling_contrast (in_2.z, contrast, pivot);
 in_2 = CHENtoRGB(in_2);
 
  float3 new_sat = _mix(in_1, in_2, p_mix_sat);
 return new_sat;
  }
  
 __DEVICE__ float3 mix_sat_lincon (float3 in_1, float3 in_2, float p_mix_sat, float contrast, float pivot) { 
 
 in_2 = RGBtoCHEN(in_2);
 in_2.z = apply_linear_contrast (in_2.z, contrast, pivot);
 in_2 = CHENtoRGB(in_2);
 
  float3 new_sat = _mix(in_1, in_2, p_mix_sat);
 return new_sat;
  }




DEFINE_UI_PARAMS(P_exposure,  Exposure ðŸŒž, DCTLUI_SLIDER_FLOAT, 0.0, -4, 4.0, 0.001)
DEFINE_UI_PARAMS(contrast, Contrast ðŸŒ“ , DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 1, 0.0001)
DEFINE_UI_PARAMS(pivot, Relative Pivot ðŸ“Œ, DCTLUI_SLIDER_FLOAT, 0.0, -1, 1, 0.001)


DEFINE_UI_PARAMS(p_white_point, âšª White Point  :âšª, DCTLUI_SLIDER_FLOAT, 1.015, 0.0, 1.018, 0.0001)
DEFINE_UI_PARAMS(p_w_p_pivot, â”œ Shoulder â€€â•­, DCTLUI_SLIDER_FLOAT, 0.6, 0.2, .997, 0.1)
DEFINE_UI_PARAMS(p_shoulder_str,â”” Fall off â•­ â€€â€€, DCTLUI_SLIDER_FLOAT, 6, 0.0, 9, 0.001)

DEFINE_UI_PARAMS(p_black_point, âš« Black Point  :âš«, DCTLUI_SLIDER_FLOAT, 0.0001, 0.0001, .5, 0.0001)
DEFINE_UI_PARAMS(p_b_p_pivot, â”œâ€€Toe â€€â€€â€€â€€âŒ£â€€â€€, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 0.8, 0.001)
DEFINE_UI_PARAMS(p_toe_str, â”” Fall offâ€€  âŒ£ â€€â€€, DCTLUI_SLIDER_FLOAT, 2.0, 0.0, 10.0, 0.001)


DEFINE_UI_PARAMS(p_mix_contrast, Linear / S curve: , DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 1.0, 0.01)
DEFINE_UI_PARAMS(p_mix_sat, Preserve Color ðŸ–ï¸, DCTLUI_SLIDER_FLOAT, .5, 0.0, 1.0, 0.01)
DEFINE_UI_PARAMS(p_mix_pin, Pin Hi-LO Ends, DCTLUI_SLIDER_FLOAT, 0.0, 0.0, 1.0, 0.01)


DEFINE_UI_PARAMS(bypass, ðŸš« Bypass, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(opt_showcurve, ðŸ“ˆ Show Curve, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(opt_ramp, ðŸ“ Show Ramp, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(opt_ramp_scope, =Wide aspect overlays =, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(exp_toggle, Tone-mapped exposure, DCTLUI_CHECK_BOX, 0)

DEFINE_UI_PARAMS(preservemidgray_toggle, Preserve Mid-gray, DCTLUI_CHECK_BOX, 1)
DEFINE_UI_PARAMS(alpha_toggle, Show Pin Range, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(p_transfer_f, Transfer function, DCTLUI_COMBO_BOX, 2, {logc3, logc4, di, aces_cct, log3g10, slog3, bmd_f5, clog3, dlog, fLog, fLog2, vlog, g22, g24, g26, linear}, {ARRI LogC3, ARRI LogC4,  DaVinci Intermediate, ACEScct, RED Log3G10, Sony S-Log3, BMD Film Gen 5, Canon Log 3, DJI D-Log, FujiFilm F-Log, FujiFilm F-Log2, Panasonic V-Log, Gamma 2.2, Gamma 2.4, Gamma 2.6, Linear})




__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B) {

    const float3 clean = make_float3(p_R, p_G, p_B);
    float3 in_RGB = make_float3(p_R, p_G, p_B);
    pivot = set_pivot(pivot, p_transfer_f);
    float3 out;


    //create a linear ramp to enable the view graph control
     float width = (float)p_Width;
     float height = (float)p_Height;
     if (opt_ramp_scope) {height = height*0.64f; }
     float X = (float)p_X;
     float Y = height - (float)p_Y;
     if (opt_ramp_scope) { Y = height*1.28f - (float)p_Y; }
     //Relative X,Y 
     float rY = Y / height;
     float rX = X / width;
     float3 ramp = {rX, rX, rX};
     float3 clean_ramp = ramp;

     
     //sanitize black and white points
     if (p_transfer_f == 15) {p_shoulder_str += 5;}
     p_w_p_pivot = _fminf(p_white_point, p_w_p_pivot );
     p_shoulder_str= _fmaxf((10 - p_shoulder_str), 0.3f);
     p_toe_str= _fmaxf((10 - p_toe_str), 0.17f);

     p_black_point = p_black_point*.4;
     p_black_point = 1.0f - p_black_point;

     p_b_p_pivot = _fminf((p_black_point - 0.05f) , p_b_p_pivot );
     p_white_point = _fmaxf(p_white_point*.5f + 0.49f,0.5f);
     //p_white_point = _fmaxf(p_white_point , 0.5f);
     p_black_point = _fmaxf(p_black_point , 0.69f);

   //preserve mid-gray mode that limits ranges of tone mapping
     float rememberPivot = pivot;
     if (preservemidgray_toggle == 1) {
       
       pivot = _fminf(0.90, _fmaxf(0.05, pivot));
       p_white_point = _fmaxf(p_white_point, _fmaxf((pivot*1.1f), .7f));
       p_w_p_pivot = _fmaxf(_fmaxf(pivot*1.015f, p_w_p_pivot),p_w_p_pivot );
       p_b_p_pivot = _fmaxf((1- _fmaxf(_fminf(0.6,(1-p_b_p_pivot)), pivot)), pivot);
       if (pivot > 0.7) {
         p_b_p_pivot = _fminf(pivot, (1 - p_b_p_pivot) * pivot+0.5);
         }
       p_black_point = p_black_point* 0.45 +.55;
       p_toe_str = p_toe_str*.15 + (10*.15);
       p_toe_str -= .05;

     } else {pivot = rememberPivot;}



     //flip preserve color slider for negative contrast for more intutive results

    if (contrast < 0) {p_mix_sat = 1-p_mix_sat;}

//bypass option that outputs untouched image when activated
    if (bypass ==1 ) {
        //float3 clean = {p_R, p_G, p_B};

     out = clean;

    //option to overlay a grayscale ramp on the bottom edge of the frame
       if (opt_ramp) {
         if (opt_ramp_scope){ 
               if( rY < 0.05f  && rY > -0.02) {out = ramp;}
            }  
         if( rY < 0.1f) {out = ramp;}
    
         }
     
    //Optional show curve functionality
     if (opt_showcurve == 1) {
    
     float3 scopeY = LinToGamma(make_float3(.9f,.9f,.9f), p_transfer_f);


        float overlayR = ramp.x >= (Y - 5.0f) / height && ramp.x <= (Y + 5.0f) / height ? scopeY.x : 0.0f;
        float overlayG = ramp.y >= (Y - 5.0f) / height && ramp.y <= (Y + 5.0f) / height ? scopeY.y : 0.0f;
        float overlayB = ramp.z >= (Y - 5.0f) / height && ramp.z <= (Y + 5.0f) / height ? scopeY.z : 0.0f;
        out.x = overlayR == 0.0f ? out.x : overlayR;
        out.y = overlayG == 0.0f ? out.y : overlayG;
        out.z = overlayB == 0.0f ? out.z : overlayB;
            

                    //Wide aspect mode
       if (opt_ramp_scope) {

                        if (rX < pivot+0.0025f && rX > pivot- 0.0025f && rY > 0.0f  && rY< 1.1f) {
                        float3 scopeR = LinToGamma(make_float3(.8f,.8f,.8f), p_transfer_f);
                        float3 scopeG = LinToGamma(make_float3(.8f,.8f,.8f), p_transfer_f);
                        float3 scopeB = LinToGamma(make_float3(.8f,.8f,.8f), p_transfer_f);

                        out.x = scopeR.x;
                        out.y = scopeG.x;
                        out.z = scopeB.x;

                         }  

                      //if (rX < p_w_p_pivot+0.001f && rX > p_w_p_pivot- 0.001f && rY > 0.0f && rY< 1.1f) {
                      //float3 scopeR = LinToGamma(make_float3(.8f,.8f,.8f), p_transfer_f);
                      //float3 scopeG = LinToGamma(make_float3(.1f,.1f,.1f), p_transfer_f);
                      //float3 scopeB = LinToGamma(make_float3(.01f,.01f,.01f), p_transfer_f);
                      //
                      //out.x = scopeR.x;
                      //out.y = scopeG.x;
                      //out.z = scopeB.x;
                      //    }
    
                      //if (rX < p_b_p_pivot+0.001f && rX > p_b_p_pivot- 0.001f && rY > 0.0f && rY< 1.1f) {
                      //float3 scopeR = LinToGamma(make_float3(.01f,.01f,.01f), p_transfer_f);
                      //float3 scopeG = LinToGamma(make_float3(.3f,.3f,.3f), p_transfer_f);
                      //float3 scopeB = LinToGamma(make_float3(.7f,.7f,.7f), p_transfer_f);

                      //out.x = scopeR.x;
                      //out.y = scopeG.x;
                      //out.z = scopeB.x;
                      //}

                    } 
                    //wide aspect mode off
        else{

                    if (rX < pivot+0.0025f && rX > pivot- 0.0025f) {
                        float3 scopeR = LinToGamma(make_float3(.8f,.8f,.8f), p_transfer_f);
                        float3 scopeG = LinToGamma(make_float3(.8f,.8f,.8f), p_transfer_f);
                        float3 scopeB = LinToGamma(make_float3(.8f,.8f,.8f), p_transfer_f);

                        out.x = scopeR.x;
                        out.y = scopeG.x;
                        out.z = scopeB.x;
                         }   

                  //if (rX < p_w_p_pivot+0.001f && rX > p_w_p_pivot- 0.001f) {
                  //    float3 scopeR = LinToGamma(make_float3(.8f,.8f,.8f), p_transfer_f);
                  //    float3 scopeG = LinToGamma(make_float3(.1f,.1f,.1f), p_transfer_f);
                  //    float3 scopeB = LinToGamma(make_float3(.01f,.01f,.01f), p_transfer_f);

                  //    out.x = scopeR.x;
                  //    out.y = scopeG.x;
                  //    out.z = scopeB.x;
                  //     }

                  //if (rX < p_b_p_pivot+0.001f && rX > p_b_p_pivot- 0.001f) {
                  //    float3 scopeR = LinToGamma(make_float3(.01f,.01f,.01f), p_transfer_f);
                  //    float3 scopeG = LinToGamma(make_float3(.3f,.3f,.3f), p_transfer_f);
                  //    float3 scopeB = LinToGamma(make_float3(.7f,.7f,.7f), p_transfer_f);

                  //    out.x = scopeR.x;
                  //    out.y = scopeG.x;
                  //    out.z = scopeB.x;
                  //    }
                    
                }
      }

    

    return out;
    }

// exposure slider that works in linear
 if(exp_toggle == 1){
    P_exposure = powf(2.0, P_exposure);
    in_RGB = GammaToLin(in_RGB, p_transfer_f);
    ramp = GammaToLin(ramp, p_transfer_f);
    
    
        // Apply linear gain
           in_RGB = in_RGB * P_exposure;
           ramp = ramp * P_exposure;
    
    in_RGB = LinToGamma(in_RGB, p_transfer_f);
    ramp = LinToGamma(ramp, p_transfer_f);
         }     

//apply compression to the white and black points
     in_RGB = apply_white_point(in_RGB, p_white_point, p_w_p_pivot, p_shoulder_str);
     ramp = apply_white_point(ramp, p_white_point, p_w_p_pivot, p_shoulder_str);

     in_RGB = apply_black_point(in_RGB, p_black_point, p_b_p_pivot, p_toe_str);           
     ramp = apply_black_point(ramp, p_black_point, p_b_p_pivot, p_toe_str);
     const float3 in_toned = in_RGB;
     const float3 ramp_toned = ramp;


//apply contrast operations
     float3 lin_contrast = apply_linear_contrastf3 (in_RGB, contrast, pivot);
     float3 ramp_linear = apply_linear_contrastf3 (ramp, contrast, pivot);

           //mix back the original saturation in CHEN 
           lin_contrast = mix_sat_lincon (lin_contrast, in_RGB, p_mix_sat, contrast, pivot);
           ramp_linear = mix_sat_lincon (ramp_linear, ramp, p_mix_sat, contrast, pivot);


     float3 roll_contrast = apply_rolling_contrastf3 (in_toned, contrast, pivot);
     float3 ramp_rolling = apply_rolling_contrastf3 (ramp_toned, contrast, pivot);
      //mix back the original saturation in CHEN 
            roll_contrast = mix_sat (roll_contrast, in_toned, p_mix_sat, contrast, pivot);
            ramp_rolling = mix_sat (ramp_rolling, ramp_toned, p_mix_sat, contrast, pivot);

     in_RGB = _mix(lin_contrast, roll_contrast, p_mix_contrast);
     ramp = _mix(ramp_linear, ramp_rolling, p_mix_contrast);



// exposure slider that works in linear
   if (exp_toggle == 0) {
    P_exposure = powf(2.0, P_exposure );
    in_RGB = GammaToLin(in_RGB, p_transfer_f);
    ramp = GammaToLin(ramp, p_transfer_f);
    
    
        // Apply linear gain
           in_RGB = in_RGB * P_exposure;
           ramp = ramp * P_exposure;
    
    in_RGB = LinToGamma(in_RGB, p_transfer_f);
    ramp = LinToGamma(ramp, p_transfer_f);
   }

    out = in_RGB;
   

out = HiLoLumaMask (in_RGB, clean, 0.85, 1.0, -4.0, 6, p_transfer_f, p_mix_pin,alpha_toggle, p_X, p_Y);
ramp= HiLoLumaMask (ramp, clean_ramp, 0.85, 1.0, -4.0, 6, p_transfer_f, p_mix_pin,alpha_toggle, p_X, p_Y);
    
//hide curve overlay when showing the pinned range
 float opt_mem = opt_showcurve;

   if (alpha_toggle)
      { 
         opt_showcurve = 0;

    } else if (alpha_toggle = 0){opt_showcurve = opt_mem; }


//option to overlay a grayscale ramp on the bottom edge of the frame
    if (opt_ramp) {
        if (opt_ramp_scope){ 
                if( rY < 0.05f  && rY > -0.02f) {out = ramp;}
            return out;
            }  
    if( rY < 0.1f ) {out = ramp;}
                
    
    }

//Optional show curve functionality
    if (opt_showcurve == 1) {
    
   float3 scopeY = LinToGamma(make_float3(.9f,.9f,.9f), p_transfer_f);


        float overlayR = ramp.x >= (Y - 5.0f) / height && ramp.x <= (Y + 5.0f) / height ? scopeY.x : 0.0f;
        float overlayG = ramp.y >= (Y - 5.0f) / height && ramp.y <= (Y + 5.0f) / height ? scopeY.y : 0.0f;
        float overlayB = ramp.z >= (Y - 5.0f) / height && ramp.z <= (Y + 5.0f) / height ? scopeY.z : 0.0f;
        out.x = overlayR == 0.0f ? out.x : overlayR;
        out.y = overlayG == 0.0f ? out.y : overlayG;
        out.z = overlayB == 0.0f ? out.z : overlayB;
            

                    //Wide aspect mode
       if (opt_ramp_scope) {

                        if (rX < pivot+0.0025f && rX > pivot- 0.0025f && rY > 0.0f  && rY< 1.1f) {
                        float3 scopeR = LinToGamma(make_float3(.8f,.8f,.8f), p_transfer_f);
                        float3 scopeG = LinToGamma(make_float3(.8f,.8f,.8f), p_transfer_f);
                        float3 scopeB = LinToGamma(make_float3(.8f,.8f,.8f), p_transfer_f);

                        out.x = scopeR.x;
                        out.y = scopeG.x;
                        out.z = scopeB.x;

                         }  

                     // if (rX < p_w_p_pivot+0.001f && rX > p_w_p_pivot- 0.001f && rY > 0.0f && rY< 1.1f) {
                     // float3 scopeR = LinToGamma(make_float3(.8f,.8f,.8f), p_transfer_f);
                     // float3 scopeG = LinToGamma(make_float3(.1f,.1f,.1f), p_transfer_f);
                     // float3 scopeB = LinToGamma(make_float3(.01f,.01f,.01f), p_transfer_f);

                     // out.x = scopeR.x;
                     // out.y = scopeG.x;
                     // out.z = scopeB.x;
                     //     }
    
                     // if (rX < p_b_p_pivot+0.001f && rX > p_b_p_pivot- 0.001f && rY > 0.0f && rY< 1.1f) {
                     // float3 scopeR = LinToGamma(make_float3(.01f,.01f,.01f), p_transfer_f);
                     // float3 scopeG = LinToGamma(make_float3(.3f,.3f,.3f), p_transfer_f);
                     // float3 scopeB = LinToGamma(make_float3(.7f,.7f,.7f), p_transfer_f);

                     // out.x = scopeR.x;
                     // out.y = scopeG.x;
                     // out.z = scopeB.x;
                     // }

                    } 
                    //wide aspect mode off
        else{

                    if (rX < pivot+0.0025f && rX > pivot- 0.0025f) {
                        float3 scopeR = LinToGamma(make_float3(.8f,.8f,.8f), p_transfer_f);
                        float3 scopeG = LinToGamma(make_float3(.8f,.8f,.8f), p_transfer_f);
                        float3 scopeB = LinToGamma(make_float3(.8f,.8f,.8f), p_transfer_f);

                        out.x = scopeR.x;
                        out.y = scopeG.x;
                        out.z = scopeB.x;
                         }   

                  //if (rX < p_w_p_pivot+0.001f && rX > p_w_p_pivot- 0.001f) {
                  //    float3 scopeR = LinToGamma(make_float3(.8f,.8f,.8f), p_transfer_f);
                  //    float3 scopeG = LinToGamma(make_float3(.1f,.1f,.1f), p_transfer_f);
                  //    float3 scopeB = LinToGamma(make_float3(.01f,.01f,.01f), p_transfer_f);

                  //    out.x = scopeR.x;
                  //    out.y = scopeG.x;
                  //    out.z = scopeB.x;
                  //     }

                  //if (rX < p_b_p_pivot+0.001f && rX > p_b_p_pivot- 0.001f) {
                  //    float3 scopeR = LinToGamma(make_float3(.01f,.01f,.01f), p_transfer_f);
                  //    float3 scopeG = LinToGamma(make_float3(.3f,.3f,.3f), p_transfer_f);
                  //    float3 scopeB = LinToGamma(make_float3(.7f,.7f,.7f), p_transfer_f);

                  //    out.x = scopeR.x;
                  //    out.y = scopeG.x;
                  //    out.z = scopeB.x;
                  //    }
                    
                }
    }





    
return out;
    }