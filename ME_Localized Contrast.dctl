#line 2
/*

ME Localized Contrast v1.2.1
by Moaz Elgabry
moazelgabry.com
buymeacoffee.com/moazelgabry

Localized, smooth, range-limited contrast shaping.

Changelog:
V1.2.1 - *Refined the chroma protection logic for negative Amount settings to better preserve color integrity while still allowing effective contrast shaping, especially in shadow regions. 
v1.2   - *Added a new Highlight Pivot Point toggle that draws a green guide over the pivot-centered middle band to help align exposure targets when shaping contrast.
         *Improved the chroma/luma protection logic in constrained shadow/highlight regions to better preserve color integrity while still allowing effective contrast shaping.
         *Better mapping of regional amount limits to the safety slider, with more gradual relaxation of constraints as safety increases.
v1.1   - *Reworked the tool for safer contrast shaping under extreme pushes: substantial tuning was added so results stay controlled and image integrity is protected, even at aggressive settings.
         *Replaced the old Safe Range toggle with a new Safety Fader: a smooth, gradual control that expands freedom progressively instead of hard-jumping between constrained/unconstrained behavior.
         *Added stability logic that keeps contrast growth usable and avoids "breaking" the image when pushing Amount/Center/Width in difficult regions.
v1.0   - Initial release


*/



DEFINE_UI_PARAMS(p_amount, Amount, DCTLUI_SLIDER_FLOAT, 0.0, -1.0, 1.0, 0.001)
DEFINE_UI_PARAMS(p_region, Region, DCTLUI_COMBO_BOX, 1, {shadows, mids, highlights, custom}, {Shadows, Midtones, Highlights, Custom})
DEFINE_UI_PARAMS(p_center_shift, Center Shift, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.001)
DEFINE_UI_PARAMS(p_width, Range Width, DCTLUI_SLIDER_FLOAT, 0.35, 0.1, 1.0, 0.001)
DEFINE_UI_PARAMS(p_symmetry_bias, Symmetry Bias, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.001)
DEFINE_UI_PARAMS(p_preserve_mid_gray, Preserve Exposure, DCTLUI_CHECK_BOX, 1)
DEFINE_UI_PARAMS(p_highlight_pivot_point, Highlight Pivot Point, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(p_bypass, Bypass, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(p_guide, Guide Ramp, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(p_curve, Curve Overlay, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(p_safety, Safety Fader, DCTLUI_SLIDER_FLOAT, 0.25, 0.25, 1.0, 0.001)
DEFINE_UI_PARAMS(p_input_space, Input Space, DCTLUI_COMBO_BOX, 1, {Linear, DI, ACEScct, LogC3}, {Linear, DaVinci Intermediate, ACEScct, ARRI LogC3})


/*----------- Tooltips -----------------*/
#if ((__RESOLVE_VER_MAJOR__ > 19)) || ((__RESOLVE_VER_MAJOR__ == 19) && (__RESOLVE_VER_MINOR__ >= 1))
DEFINE_UI_TOOLTIP(Amount, "Local contrast strength. Positive increases separation, negative compresses.")
DEFINE_UI_TOOLTIP(Region, "Target tonal band. Shadows/Midtones/Highlights use stop-based ranges around midgray; Custom centers on the Center Shift value.")
DEFINE_UI_TOOLTIP(Center Shift, "Moves the center in stops. Shadows/Highlights are constrained to avoid crossing midgray; Custom spans a wider stop range.")
DEFINE_UI_TOOLTIP(Range Width, "Width of the affected range available only in custom mode. Auto-expands with higher Amount for smoother roll-off.")
DEFINE_UI_TOOLTIP(Input Space, "this should match the color space of the input footage for correct tonal targeting.")
DEFINE_UI_TOOLTIP(Bypass, "Disables processing (passes input through).")
DEFINE_UI_TOOLTIP(Symmetry Bias, "Biases localized contrast toward one side of the center. 0 = symmetric, + favors highlights side, - favors shadows side.")
DEFINE_UI_TOOLTIP(Preserve Exposure, "Applies a global linear gain so the processed image mid-gray returns to its original working-space value.")
DEFINE_UI_TOOLTIP(Highlight Pivot Point, "Draws a green guide over the pivot-centered middle band to help you align the operation around your targets when the image subject is not exactly at mid gray.")
DEFINE_UI_TOOLTIP(Guide Ramp, "Shows stepped/ramp guide. Red = steps too close (risk of clipping/flat areas). Yellow = low slope (flat curve warning).")
DEFINE_UI_TOOLTIP(Curve Overlay, "Draws the curve response on the image to visualize the current settings. the curve is encoded in the output space of the tool, so it reflects the actual applied contrast shaping.")
DEFINE_UI_TOOLTIP(Safety Fader, "Controls how tightly Amount is constrained. Lower values are safer; higher values allow more range.")
#endif

__DEVICE__ float saturatef(float x) {
    return _fminf(_fmaxf(x, 0.0f), 1.0f);
}

__DEVICE__ float smootherstep01(float x) {
    x = saturatef(x);
    return x * x * x * (x * (x * 6.0f - 15.0f) + 10.0f);
}

__DEVICE__ float di_to_linear(float t) {
    const float a = 0.0075f;
    const float b = 7.0f;
    const float c = 0.07329248f;
    const float m = 10.44426855f;
    const float log_cut = 0.02740668f;

    return (t > log_cut) ? _exp2f((t / c) - b) - a : t / m;
}

__DEVICE__ float linear_to_di(float x) {
    const float a = 0.0075f;
    const float b = 7.0f;
    const float c = 0.07329248f;
    const float m = 10.44426855f;
    const float lin_cut = 0.00262409f;

    x = _fmaxf(x, 0.0f);
    return (x > lin_cut) ? (_log2f(x + a) + b) * c : x * m;
}

// ACEScct OETF / inverse OETF (ACEScct <-> linear)
__DEVICE__ float acescct_to_linear(float x) {
    const float cut2 = 0.155251141552511f;
    const float A = 10.5402377416545f;
    const float B = 0.0729055341958355f;
    const float C = 9.72f;
    const float D = 17.52f;

    return (x <= cut2) ? (x - B) / A : _exp2f(x * D - C);
}

__DEVICE__ float linear_to_acescct(float x) {
    const float cut1 = 0.0078125f;
    const float A = 10.5402377416545f;
    const float B = 0.0729055341958355f;
    const float C = 9.72f;
    const float D = 17.52f;

    x = _fmaxf(x, 0.0f);
    return (x <= cut1) ? A * x + B : (_log2f(x) + C) / D;
}

// ARRI LogC3 OETF / inverse OETF (LogC3 <-> linear), EI800 form.
__DEVICE__ float logc3_to_linear(float x) {
    const float cut = 0.010591f;
    const float a = 5.555556f;
    const float b = 0.052272f;
    const float c = 0.247190f;
    const float d = 0.385537f;
    const float e = 5.367655f;
    const float f = 0.092809f;
    const float cut_code = e * cut + f;

    float lin = (x < cut_code) ? ((x - f) / e) : ((_exp10f((x - d) / c) - b) / a);
    return _fmaxf(lin, 0.0f);
}

__DEVICE__ float linear_to_logc3(float x) {
    const float cut = 0.010591f;
    const float a = 5.555556f;
    const float b = 0.052272f;
    const float c = 0.247190f;
    const float d = 0.385537f;
    const float e = 5.367655f;
    const float f = 0.092809f;

    x = _fmaxf(x, 0.0f);
    return (x < cut) ? (e * x + f) : (c * _log10f(a * x + b) + d);
}

// ============================================================================
// Stop-based tonal range definitions
// ============================================================================

// ColorSpace: Defines midgray for a specific input space.
struct ColorSpace {
    int space_id;
    float midgray_lin;  // Midgray in linear light
};

// TonaRegion: Defines a tonal range in stops relative to midgray
struct TonaRegion {
    float center_stops;   // Center position in stops from midgray
    float width_stops;    // Total width in stops
};

// Shared input bundle for contrast processing paths.
struct ProcessInput {
    int input_space;
    int region;
    float center_shift;
    float width_user;
    float amount;
    float amount_ui;
    float symmetry_bias;
    float safety;
    int preserve_mid_gray;
};

// Derived curve state used across shaping and overlays.
struct CurveState {
    float center;
    float width;
    float amount_scaled;
    float halfW;
    float bmin;
    float bmax;
};

// Space IDs for encode->linear mapping. ++Add new ones here.
#define SPACE_LINEAR 0
#define SPACE_DI 1
#define SPACE_ACEScct 2
#define SPACE_LOGC3 3

// Custom mode center range in stops from midgray (both directions).
// Increase to allow the custom center to reach deeper shadows/highlights.
__CONSTANT__ float k_custom_center_range_stops = 11.0f;

// Range expansion with amount (code-level tuning).
// Small pushes expand little; heavy pushes expand more.
__CONSTANT__ float k_range_expand = 0.6f;
__CONSTANT__ float k_range_expand_power = 2.0f;
// Keep localized curve support inside the DI display domain with a small headroom.
__CONSTANT__ float k_curve_domain_margin = 0.01f;
// Stability limiter range for effective amount vs width.
// Lower values are safer; higher values allow more freedom.
__CONSTANT__ float k_amount_width_limit_safe = 0.8f;
__CONSTANT__ float k_amount_width_limit_max = 1.0f;
// High-safety taper relaxation: lifts center-distance taper toward 1.0 as Safety increases.
__CONSTANT__ float k_safety_taper_relax = 0.25f;
// Adaptive chroma protection in constrained shadow/highlight regions.
__CONSTANT__ float k_chroma_protect_strength = 0.9f;
__CONSTANT__ float k_chroma_protect_boundary_fraction = 0.35f;
__CONSTANT__ float k_pivot_overlay_alpha = 0.35f;
// Negative-amount chroma recovery split by luminance relative to mid gray.
// Below mid gray: stronger recovery.
__CONSTANT__ float k_neg_hs_min_below_mid = 0.5f;
__CONSTANT__ float k_neg_hs_max_below_mid = 0.70f;
// Above mid gray: gentler recovery.
__CONSTANT__ float k_neg_hs_min_above_mid = 0.08f;
__CONSTANT__ float k_neg_hs_max_above_mid = 0.16f;
// Split center in stops relative to mid gray (positive shifts split into highlights).
__CONSTANT__ float k_neg_hs_split_center_stops = 0.7f;
// Smooth transition width (in stops) around mid gray for mix split.
__CONSTANT__ float k_neg_hs_split_soft_stops = 1.2f;
// Relative-chroma mix regularization (no hard clamps).
__CONSTANT__ float k_neg_hs_rel_k = 0.02f;
// Soft-bound scale for relative chroma; larger = looser bound.
__CONSTANT__ float k_neg_hs_rel_soft_limit = 4.0f;
// Near-black fade for HS recovery (in linear-light Y).
__CONSTANT__ float k_neg_hs_black_y0 = 0.005f;
__CONSTANT__ float k_neg_hs_black_y1 = 0.03f;

// Amount sensitivity by tonal group (shadows/highlights are more constrained).
__CONSTANT__ float k_amount_scale_mid = 1.0f;
__CONSTANT__ float k_amount_scale_sh = 0.6f;
// DaVinci Intermediate practical headroom from the official BMD white paper.
__CONSTANT__ float k_di_above_midgray_stops = 9.12f;
__CONSTANT__ float k_di_below_midgray_stops = 9.0f;
// Soft transition width (in stops) near DI headroom clamp boundaries.
__CONSTANT__ float k_di_headroom_soft_stops = 0.35f;
// Deep shadow/highlight taper (smoothly approaches this in extremes).
__CONSTANT__ float k_amount_scale_extreme = 0.4f;
// In Custom mode, narrow widths reduce effective amount to keep behavior controlled.
__CONSTANT__ float k_custom_amount_min_scale = 0.2f;
__CONSTANT__ float k_custom_width_min = 0.05f;
__CONSTANT__ float k_custom_width_max = 1.0f;
// Safety slider endpoints.
__CONSTANT__ float k_safety_min = 0.25f;
__CONSTANT__ float k_safety_max = 1.0f;

// Convert a code value to linear for the selected input space
__DEVICE__ float code_to_linear_space(float code, int space_id) {
    if (space_id == SPACE_LINEAR) {
        return code;
    }
    if (space_id == SPACE_DI) {
        return di_to_linear(code);
    }
    if (space_id == SPACE_ACEScct) {
        return acescct_to_linear(code);
    }
    if (space_id == SPACE_LOGC3) {
        return logc3_to_linear(code);
    }
    return code;
}

// Convert linear to code for the selected input space
__DEVICE__ float linear_to_code_space(float lin, int space_id) {
    if (space_id == SPACE_LINEAR) {
        return lin;
    }
    if (space_id == SPACE_DI) {
        return linear_to_di(lin);
    }
    if (space_id == SPACE_ACEScct) {
        return linear_to_acescct(lin);
    }
    if (space_id == SPACE_LOGC3) {
        return linear_to_logc3(lin);
    }
    return lin;
}

// Get ColorSpace definition based on input space
__DEVICE__ ColorSpace get_color_space(int input_space) {
    ColorSpace cs;
    if (input_space == SPACE_DI || input_space == SPACE_ACEScct || input_space == SPACE_LOGC3 || input_space == SPACE_LINEAR) {
        cs.space_id = input_space;
    } else {
        cs.space_id = SPACE_LINEAR;
    }
    cs.midgray_lin = 0.18f;  // Standard midgray in linear light
    return cs;
}

// Convert stops relative to midgray into DI code value
// stops: positive = brighter, negative = darker
__DEVICE__ float stops_to_di_code(float stops, ColorSpace cs) {
    float target_lin = cs.midgray_lin * _powf(2.0f, stops);
    float target_code = linear_to_code_space(target_lin, cs.space_id);
    return linear_to_di(code_to_linear_space(target_code, cs.space_id));
}

// Get tonal region definition by index
// Ranges chosen to naturally divide the tonal spectrum with reasonable defaults
__DEVICE__ TonaRegion get_tonal_region(int region) {
    TonaRegion tr;
    
    if (region == 0) {
        // Shadows: narrower default span for more center-shift headroom.
        tr.center_stops = -2.5f;
        tr.width_stops = 4.0f;
    }
    else if (region == 1) {
        // Midtones: -0.5 to +1.5 stops from midgray (as specified)
        tr.center_stops = 0.0f;
        tr.width_stops = 8.0f;
    }
    else if (region == 2) {
        // Highlights: +1 to +3 stops from midgray
        tr.center_stops = 2.0f;
        tr.width_stops = 6.0f;
    }
    else {
        // Custom: center at midgray, 2-stop width
        tr.center_stops = 0.5f;
        tr.width_stops = 6.0f;
    }
    
    return tr;
}

// Remap center shift so full slider travel maps to a constrained stop range,
// while keeping center_shift = 0 at the region's nominal center.
__DEVICE__ float remap_center_stops(int region, float center_shift) {
    TonaRegion tr = get_tonal_region(region);
    float base = tr.center_stops;
    float half_range = 0.5f * tr.width_stops;
    float min_s = base - half_range;
    float max_s = base + half_range;

    if (region == 2) {
        // Highlights do not cross below midgray.
        min_s = 0.0f;
    }
    else if (region == 0) {
        // Shadows do not cross above midgray.
        max_s = 0.0f;
    }
    // Clamp to DI practical stop headroom from midgray.
    min_s = _fmaxf(min_s, -k_di_below_midgray_stops);
    max_s = _fminf(max_s,  k_di_above_midgray_stops);
    // Smooth clamp near boundaries to avoid a hard "wall" feel.
    if (base <= min_s) {
        base = min_s;
    } else if (base >= max_s) {
        base = max_s;
    } else {
        float soft = _fmaxf(k_di_headroom_soft_stops, 1e-6f);
        if (base < (min_s + soft)) {
            float t = (base - min_s) / soft;
            float s = smootherstep01(t);
            base = min_s + (base - min_s) * s;
        } else if (base > (max_s - soft)) {
            float d = (max_s - base);
            float t = d / soft;
            float s = smootherstep01(t);
            base = max_s - (max_s - base) * s;
        }
    }

    // Shared remap rule for all modes: same derivation, different bounds.
    float u = _fminf(_fmaxf(center_shift / 0.5f, -1.0f), 1.0f);
    return (u >= 0.0f) ? (base + u * (max_s - base)) : (base + u * (base - min_s));
}

// Calculate center in DI code from region selection and user adjustments
__DEVICE__ float default_center_from_region(int region, float center_shift, int input_space) {
    ColorSpace cs = get_color_space(input_space);

    // Convert region's center stops to DI code value.
    // Center Shift is scaled to cover the full region width in stops.
    float center_stops = remap_center_stops(region, center_shift);
    if (region == 3) {
        center_stops = center_shift * k_custom_center_range_stops * 2.0f;
    }
    return stops_to_di_code(center_stops, cs);
}

// Calculate region width in DI code from stop-based definition
__DEVICE__ float default_width_from_region(int region, int input_space, float user_width) {
    if (region == 3) {
        return user_width;
    }

    ColorSpace cs = get_color_space(input_space);
    TonaRegion tr = get_tonal_region(region);

    float half_w = 0.5f * tr.width_stops;
    float low_code = stops_to_di_code(tr.center_stops - half_w, cs);
    float high_code = stops_to_di_code(tr.center_stops + half_w, cs);
    return _fmaxf(0.001f, high_code - low_code);
}

// Center in stops for tone-group logic and custom mode behavior.
__DEVICE__ float center_stops_from_region(int region, float center_shift) {
    TonaRegion tr = get_tonal_region(region);
    float center_stops = remap_center_stops(region, center_shift);
    if (region == 3) {
        center_stops = center_shift * k_custom_center_range_stops * 2.0f;
    }
    return center_stops;
}

// Compute center position in stops from midgray using DI code center.
__DEVICE__ float center_stops_from_center_di(float center_di, int input_space) {
    ColorSpace cs = get_color_space(input_space);
    float center_lin = di_to_linear(center_di);
    return _log2f(_fmaxf(center_lin, 1e-6f) / _fmaxf(cs.midgray_lin, 1e-6f));
}

// Amount scaling by tonal group. Shadows/highlights are more constrained.
__DEVICE__ float amount_scale_for_center(float center_stops, float safety) {
    float abs_c = _fabs(center_stops);
    if (abs_c <= 0.5f) {
        return k_amount_scale_mid;
    }
    // Smoothly ramp down to shadow/highlight scale.
    float t = _fminf((abs_c - 0.75f) / 1.25f, 1.0f);
    t = smootherstep01(t);
    float base = k_amount_scale_mid + (k_amount_scale_sh - k_amount_scale_mid) * t;
    // Additional smooth taper into deep extremes (starts after ~2.0 stops).
    float t2 = _fminf(_fmaxf((abs_c - 2.0f) / 4.0f, 0.0f), 1.0f);
    t2 = smootherstep01(t2);
    float scale = base + (k_amount_scale_extreme - base) * t2;
    // At higher Safety, relax taper slightly to allow more creative headroom.
    float s = (safety - k_safety_min) / _fmaxf(k_safety_max - k_safety_min, 1e-6f);
    s = _fminf(_fmaxf(s, 0.0f), 1.0f);
    scale = scale + (1.0f - scale) * (k_safety_taper_relax * s);
    // Safety slider floor: 0.25 keeps a 0.4 floor, 1.0 allows floor down to 0.0.
    float min_scale = 0.4f * (1.0f - s);
    return _fmaxf(scale, min_scale);
}

// Custom mode width-based amount attenuation:
// width=min -> 20% amount, width=max -> 100% amount.
__DEVICE__ float custom_amount_scale_from_width(float width_user) {
    float t = (width_user - k_custom_width_min) / _fmaxf(k_custom_width_max - k_custom_width_min, 1e-6f);
    t = _fminf(_fmaxf(t, 0.0f), 1.0f);
    return k_custom_amount_min_scale + (1.0f - k_custom_amount_min_scale) * t;
}

// Range expansion as amount increases (gradual, exponential-like).
__DEVICE__ float expand_width_by_amount(float width, float amount) {
    float a = _fabs(amount);
    float e = _expf(k_range_expand_power * a);
    float denom = _expf(k_range_expand_power) - 1.0f;
    float w = 1.0f + k_range_expand * (e - 1.0f) / _fmaxf(denom, 1e-6f);
    return width * w;
}

// Inverse of expand_width_by_amount for |amount| using target expanded width.
__DEVICE__ float amount_from_target_width(float base_width, float target_width) {
    float b = _fmaxf(base_width, 1e-6f);
    float t = _fmaxf(target_width, 0.0f) / b;
    float max_factor = 1.0f + k_range_expand;
    t = _fminf(_fmaxf(t, 1.0f), max_factor);
    float s = (t - 1.0f) / _fmaxf(k_range_expand, 1e-6f);
    s = _fminf(_fmaxf(s, 0.0f), 1.0f);
    float exp_base = _expf(k_range_expand_power);
    float e = 1.0f + s * (exp_base - 1.0f);
    return _logf(_fmaxf(e, 1e-6f)) / _fmaxf(k_range_expand_power, 1e-6f);
}

// Smoothly limit effective amount by current width to prevent local slope inversion.
__DEVICE__ float limit_amount_for_stability(float amount, float width, float symmetry_bias, float safety) {
    float s = (safety - k_safety_min) / _fmaxf(k_safety_max - k_safety_min, 1e-6f);
    s = _fminf(_fmaxf(s, 0.0f), 1.0f);
    float k_amount_width_limit = k_amount_width_limit_safe + (k_amount_width_limit_max - k_amount_width_limit_safe) * s;
    float side_factor = 1.0f + _fabs(symmetry_bias);
    float cap = _fmaxf(0.02f, (k_amount_width_limit * width) / _fmaxf(side_factor, 1e-6f));
    float a = _fabs(amount);
    // Smooth saturation: linear at low values, asymptotically approaches cap.
    float a_limited = cap * (1.0f - _expf(-a / _fmaxf(cap, 1e-6f)));
    return _copysignf(a_limited, amount);
}

__DEVICE__ float localized_s_curve(float x, float amount, float center, float width, float symmetry_bias) {
    // x, center in DI domain. width is normalized full-width (0..1).
    // Compact-support odd polynomial shape:
    // - zero effect at center crossing (no luminance offset)
    // - smooth roll-in/out to zero at range boundaries
    // - positive amount => local contrast increase around selected range

    float halfW = _fmaxf(0.0005f, 0.5f * width);
    float t = (x - center) / halfW;      // nominal active range: t in [-1, 1]
    // Smooth odd polynomial envelope with zero slope at |t|=1 and t=0.
    float t2 = t * t;
    float env = saturatef(1.0f - t2); // 1 at center, 0 at edges/outside
    env = env * env;                  // smooth falloff without sign flips

    float b = _fminf(_fmaxf(symmetry_bias, -1.0f), 1.0f);
    // Smooth side-bias around pivot to avoid a derivative kink at t=0.
    const float k_symmetry_softness = 0.20f;
    float t_softsign = t / _sqrtf(t * t + k_symmetry_softness * k_symmetry_softness);
    float side_gain = 1.0f + b * t_softsign;
    float delta_raw = amount * t * env * side_gain * 0.5f;

    // Intrinsic soft output-bounds limiter:
    // keep x+delta in [0,1] smoothly to avoid hard clipping artifacts at extreme settings.
    const float k_out_margin = 1e-4f;
    float room_down = _fmaxf(x - k_out_margin, 1e-6f);
    float room_up = _fmaxf((1.0f - k_out_margin) - x, 1e-6f);
    float delta = delta_raw;
    if (delta_raw < 0.0f) {
        float z = (-delta_raw) / room_down;
        delta = -room_down * (z / (1.0f + z));
    } else {
        float z = delta_raw / room_up;
        delta = room_up * (z / (1.0f + z));
    }
    return x + delta;
}

// ============================================================================
// Guide overlay (stepped gradient + clipping proximity warning)
// ============================================================================
__CONSTANT__ float k_guide_strip_height = 0.08f;
__CONSTANT__ float k_guide_ramp_height = 0.06f;
__CONSTANT__ int k_guide_steps = 21;
__CONSTANT__ float k_guide_midgray_lin = 0.18f;
__CONSTANT__ float k_guide_close_thresh = 1.0f / 256.0f;
// Flat-curve warning threshold for the ramp (smaller = more sensitive).
__CONSTANT__ float k_guide_flat_thresh = 1.0f / 28.0f;
// Shadow sensitivity scaling (lower = less sensitive in shadows).
__CONSTANT__ float k_guide_shadow_sensitivity = 0.5f;
// Curve overlay settings
__CONSTANT__ float k_curve_thickness = 0.003f;
// Black bar detection (used for overlay drawing area), in DI code space.
__CONSTANT__ float k_black_threshold = 0.01f;
__CONSTANT__ int k_assume_centered = 1;

// Guide step value in DI code space (internal working space)
__DEVICE__ float guide_step_value_di(int step) {
    int middle = k_guide_steps / 2;
    float stops = (float)(step - middle);
    float lin = k_guide_midgray_lin * _exp2f(stops);
    return linear_to_di(lin);
}

__DEVICE__ float3 encode_warn_color(float3 lin_rgb, int input_space) {
    return make_float3(
        linear_to_code_space(lin_rgb.x, input_space),
        linear_to_code_space(lin_rgb.y, input_space),
        linear_to_code_space(lin_rgb.z, input_space)
    );
}

// Convert DI code value to selected output space (via linear)
__DEVICE__ float di_code_to_space(float di_code, int output_space) {
    float lin = di_to_linear(di_code);
    return linear_to_code_space(lin, output_space);
}

__DEVICE__ float3 guide_step_color(float code_val, int too_close, int flat_warn, int input_space) {
    float v = saturatef(code_val);
    if (too_close) {
        return encode_warn_color(make_float3(1.0f, 0.15f, 0.15f), input_space);
    }
    if (flat_warn) {
        return encode_warn_color(make_float3(1.0f, 0.95f, 0.2f), input_space);
    }
    return make_float3(v, v, v);
}

// Apply the tool's processing to a given input color (in selected input space).
// ============================================================================
// Post-contrast cohesion controls (code-level tuning)
// ============================================================================
// Max local separation in stops after contrast. Lower = tighter tonal spacing.
__CONSTANT__ float k_max_separation_stops = 4.0f;
// Softness of the limiter knee. Higher = softer roll-off into the limit.
__CONSTANT__ float k_limit_softness = 2.0f;
// Expansion factor beyond the limit (0..1). Higher = more gradual expansion.
__CONSTANT__ float k_limit_expand = 0.6f;
// Cohesion blend toward original after limiting. 0 = off, 1 = full return.
__CONSTANT__ float k_cohesion = 0.1f;

// Soft limit contrast-induced separation by stops in linear light, with gradual expansion.
// Uses a smooth rational knee to avoid harsh clipping and numerical instability.
__DEVICE__ float soft_limit_stops(float stops, float max_stops) {
    float abs_s = _fabs(stops);
    if (abs_s <= max_stops) {
        return stops;
    }

    float over = abs_s - max_stops;
    // Soft knee: asymptotically increases, no hard corner.
    float soft_over = (over * k_limit_expand) / (1.0f + over / _fmaxf(1e-6f, k_limit_softness));
    float abs_out = max_stops + soft_over;
    return _copysignf(abs_out, stops);
}

__DEVICE__ ProcessInput make_process_input(int input_space, int region, float center_shift, float width_user, float amount, float amount_ui, float symmetry_bias, float safety, int preserve_mid_gray) {
    ProcessInput p;
    p.input_space = input_space;
    p.region = region;
    p.center_shift = center_shift;
    p.width_user = width_user;
    p.amount = amount;
    p.amount_ui = amount_ui;
    p.symmetry_bias = symmetry_bias;
    p.safety = safety;
    p.preserve_mid_gray = preserve_mid_gray;
    return p;
}

// Rec.709 luma in linear -> DI code for scene sampling / overlays.
__DEVICE__ float luminance_di_from_code(float3 code_rgb, int input_space) {
    float3 linRGB = make_float3(
        code_to_linear_space(code_rgb.x, input_space),
        code_to_linear_space(code_rgb.y, input_space),
        code_to_linear_space(code_rgb.z, input_space)
    );
    const float3 rec709Y = make_float3(0.2126f, 0.7152f, 0.0722f);
    float Ylin = _fmaxf(1e-6f, linRGB.x * rec709Y.x + linRGB.y * rec709Y.y + linRGB.z * rec709Y.z);
    return linear_to_di(Ylin);
}

// Derive center/width/amount and support bounds once, shared by processing and overlays.
__DEVICE__ CurveState solve_curve_state(ProcessInput p) {
    CurveState s;

    float center = default_center_from_region(p.region, p.center_shift, p.input_space);
    center = _fmaxf(center, 0.0f);

    float center_stops = center_stops_from_center_di(center, p.input_space);
    float amount_scale = amount_scale_for_center(center_stops, p.safety);
    float amount_scaled_base = p.amount * amount_scale;
    float amount_scaled = amount_scaled_base;
    float amount_for_width = amount_scaled_base;
    if (p.region == 3) {
        float custom_scale = custom_amount_scale_from_width(p.width_user);
        amount_scaled *= custom_scale;
        amount_for_width *= custom_scale;
    }

    float base_width = default_width_from_region(p.region, p.input_space, p.width_user);
    float width = expand_width_by_amount(base_width, amount_for_width);

    const float dmin = 0.0f + k_curve_domain_margin;
    const float dmax = 1.0f - k_curve_domain_margin;
    ColorSpace cs_bounds = get_color_space(p.input_space);
    float midgray_di = stops_to_di_code(0.0f, cs_bounds);
    float bmin = dmin;
    float bmax = dmax;
    if (p.region == 0) {
        bmax = midgray_di;
    } else if (p.region == 2) {
        bmin = midgray_di;
    }
    float region_max_width = _fmaxf(0.001f, bmax - bmin);

    if (width > region_max_width) {
        float a_cap = amount_from_target_width(base_width, region_max_width);
        float a_abs_w = _fabs(amount_for_width);
        if (a_cap < a_abs_w) {
            amount_for_width = _copysignf(a_cap, amount_for_width);
        }
        float a_abs_s = _fabs(amount_scaled);
        if (a_cap < a_abs_s) {
            amount_scaled = _copysignf(a_cap, amount_scaled);
        }
        width = _fminf(expand_width_by_amount(base_width, amount_for_width), region_max_width);
    }

    float halfW = 0.5f * width;
    float cmin = bmin + halfW;
    float cmax = bmax - halfW;
    if (p.region == 1) {
        // Midtones: allow support overhang near domain edges so center can travel farther.
        center = _fminf(_fmaxf(center, bmin), bmax);
    } else if (cmin <= cmax) {
        center = _fminf(_fmaxf(center, cmin), cmax);
    } else {
        width = region_max_width;
        halfW = 0.5f * width;
        center = 0.5f * (bmin + bmax);
    }

    amount_scaled = limit_amount_for_stability(amount_scaled, width, p.symmetry_bias, p.safety);

    s.center = center;
    s.width = width;
    s.amount_scaled = amount_scaled;
    s.halfW = 0.5f * width;
    s.bmin = bmin;
    s.bmax = bmax;
    return s;
}

// Pivot highlight band: use effective width, capped to +-1 stop around pivot.
__DEVICE__ float pivot_half_range_di(CurveState s, int input_space) {
    float center_stops = center_stops_from_center_di(s.center, input_space);
    ColorSpace cs = get_color_space(input_space);
    float lo = stops_to_di_code(center_stops - 1.0f, cs);
    float hi = stops_to_di_code(center_stops + 1.0f, cs);
    float one_stop_half = 0.5f * _fabs(hi - lo);
    return _fmaxf(0.001f, _fminf(s.halfW, one_stop_half));
}

// Compute linear gain that restores processed mid gray to original mid gray.
__DEVICE__ float midgray_preserve_gain(ProcessInput p, CurveState s) {
    ColorSpace cs = get_color_space(p.input_space);
    float mid_code_in = linear_to_code_space(cs.midgray_lin, p.input_space);
    float mid_lin_in = _fmaxf(1e-6f, code_to_linear_space(mid_code_in, p.input_space));

    float mid_di = linear_to_di(mid_lin_in);
    float mid_di_shaped = _fmaxf(0.0f, localized_s_curve(mid_di, s.amount_scaled, s.center, s.width, p.symmetry_bias));
    float mid_lin_shaped = di_to_linear(mid_di_shaped);
    mid_lin_shaped = _fminf(_fmaxf(mid_lin_shaped, 1e-6f), 1e6f);

    float ratio = mid_lin_shaped / mid_lin_in;
    float stops = _log2f(ratio);
    float stops_soft = soft_limit_stops(stops, k_max_separation_stops);
    float ratio_soft = _exp2f(stops_soft);
    float mid_lin_luma = mid_lin_in + (mid_lin_in * ratio_soft - mid_lin_in) * (1.0f - k_cohesion);

    float mid_lin_rgb = di_to_linear(_fmaxf(0.0f, localized_s_curve(mid_di, s.amount_scaled, s.center, s.width, p.symmetry_bias)));

    float blend = (p.amount >= 0.0f) ? 1.0f : 0.0f;
    float mid_lin_out = mid_lin_rgb + (mid_lin_luma - mid_lin_rgb) * blend;
    mid_lin_out = _fmaxf(mid_lin_out, 1e-6f);

    return mid_lin_in / mid_lin_out;
}

// Apply the tool's processing to a given input color (in selected input space).
__DEVICE__ float3 process_color(float3 inRGB, ProcessInput p) {
    // Assume DWG primaries. Process luminance in linear light for hue stability.
    float3 linRGB = make_float3(
        code_to_linear_space(inRGB.x, p.input_space),
        code_to_linear_space(inRGB.y, p.input_space),
        code_to_linear_space(inRGB.z, p.input_space)
    );

    // Luma-like Y computed from linearized RGB using Rec.709 coefficients.
    const float3 rec709Y = make_float3(0.2126f, 0.7152f, 0.0722f);

    float Ylin = _fmaxf(1e-6f, linRGB.x * rec709Y.x + linRGB.y * rec709Y.y + linRGB.z * rec709Y.z);
    float Ydi = linear_to_di(Ylin);
    CurveState s = solve_curve_state(p);

    float YdiShaped = localized_s_curve(Ydi, s.amount_scaled, s.center, s.width, p.symmetry_bias);
    // Cohesion control: limit separation in stops, then blend back toward original.
    YdiShaped = _fmaxf(0.0f, YdiShaped);
    float YlinShaped = di_to_linear(YdiShaped);
    YlinShaped = _fminf(_fmaxf(YlinShaped, 1e-6f), 1e6f);
    float YlinSafe = _fmaxf(Ylin, 1e-6f);
    float ratio = YlinShaped / YlinSafe;
    float stops = _log2f(ratio);
    float stops_soft = soft_limit_stops(stops, k_max_separation_stops);
    float ratio_soft = _exp2f(stops_soft);
    float YlinLimited = YlinSafe * ratio_soft;
    float YlinCohesive = YlinSafe + (YlinLimited - YlinSafe) * (1.0f - k_cohesion);

    float gain = YlinCohesive / YlinSafe;
    float3 lumaShapedLin = linRGB * gain;

    // RGB-path shaping: apply the same curve per channel in DI code space.
    float r_di = linear_to_di(linRGB.x);
    float g_di = linear_to_di(linRGB.y);
    float b_di = linear_to_di(linRGB.z);
    float r_di_s = localized_s_curve(r_di, s.amount_scaled, s.center, s.width, p.symmetry_bias);
    float g_di_s = localized_s_curve(g_di, s.amount_scaled, s.center, s.width, p.symmetry_bias);
    float b_di_s = localized_s_curve(b_di, s.amount_scaled, s.center, s.width, p.symmetry_bias);
    float3 rgbShapedLin = make_float3(
        di_to_linear(_fmaxf(0.0f, r_di_s)),
        di_to_linear(_fmaxf(0.0f, g_di_s)),
        di_to_linear(_fmaxf(0.0f, b_di_s))
    );

    // Blend between RGB shaping and luma-only shaping.
    float blend = (p.amount >= 0.0f) ? 1.0f : 0.0f;
    if (p.region == 0 || p.region == 2) {
        float gap = (p.region == 0) ? (s.bmax - (s.center + s.halfW)) : ((s.center - s.halfW) - s.bmin);
        gap = _fmaxf(gap, 0.0f);
        float fade = _fmaxf(1e-6f, k_chroma_protect_boundary_fraction * s.halfW);
        float near_boundary = 1.0f - smootherstep01(_fminf(gap / fade, 1.0f));
        float amount_stress = _fminf(_fabs(s.amount_scaled) / _fmaxf(0.8f * s.width, 1e-6f), 1.0f);
        amount_stress = smootherstep01(amount_stress);
        float protect = k_chroma_protect_strength * near_boundary * amount_stress;
        blend = blend + (1.0f - blend) * protect;
    }
    float3 shapedLin = make_float3(
        rgbShapedLin.x + (lumaShapedLin.x - rgbShapedLin.x) * blend,
        rgbShapedLin.y + (lumaShapedLin.y - rgbShapedLin.y) * blend,
        rgbShapedLin.z + (lumaShapedLin.z - rgbShapedLin.z) * blend
    );

    float3 mixedLin = shapedLin;
    float3 sourceLinForMix = linRGB;

    // Preserve exposure first so any later source-vs-processed mixing happens at matched exposure.
    float g_mid = 1.0f;
    if (p.preserve_mid_gray) {
        g_mid = midgray_preserve_gain(p, s);
        mixedLin = make_float3(mixedLin.x * g_mid, mixedLin.y * g_mid, mixedLin.z * g_mid);
        sourceLinForMix = make_float3(sourceLinForMix.x * g_mid, sourceLinForMix.y * g_mid, sourceLinForMix.z * g_mid);
    }

    // Negative-amount chroma recovery with smooth luminance split:
    // - below mid gray uses stronger min/max mix bounds
    // - above mid gray uses gentler min/max mix bounds
    // Stage 1 (Safety at minimum): amount drives 0 -> local min.
    // Stage 2 (Safety above minimum): add from local min toward local max.
    if (p.amount_ui < 0.0f) {
        float Yproc = _fmaxf(1e-6f, mixedLin.x * rec709Y.x + mixedLin.y * rec709Y.y + mixedLin.z * rec709Y.z);
        float Ysrc = _fmaxf(1e-6f, sourceLinForMix.x * rec709Y.x + sourceLinForMix.y * rec709Y.y + sourceLinForMix.z * rec709Y.z);
        float y_stops = _log2f(Ysrc / 0.18f);
        float split_t = saturatef(((y_stops - k_neg_hs_split_center_stops) + k_neg_hs_split_soft_stops) / _fmaxf(2.0f * k_neg_hs_split_soft_stops, 1e-6f));
        split_t = smootherstep01(split_t); // 0=below-mid side, 1=above-mid side
        float min_mix_zone = k_neg_hs_min_below_mid + (k_neg_hs_min_above_mid - k_neg_hs_min_below_mid) * split_t;
        float max_mix_zone = k_neg_hs_max_below_mid + (k_neg_hs_max_above_mid - k_neg_hs_max_below_mid) * split_t;

        float amount_t = smootherstep01(saturatef(-p.amount_ui));
        float mix_at_safety_min = min_mix_zone * amount_t;
        float safety_t = smootherstep01(saturatef((p.safety - k_safety_min) / _fmaxf(k_safety_max - k_safety_min, 1e-6f)));
        float hs_mix = mix_at_safety_min + (max_mix_zone - mix_at_safety_min) * safety_t;
        // Fade recovery smoothly toward black to avoid unstable color behavior.
        float black_t = smootherstep01(saturatef((Ysrc - k_neg_hs_black_y0) / _fmaxf(k_neg_hs_black_y1 - k_neg_hs_black_y0, 1e-6f)));
        hs_mix *= black_t;

        if (hs_mix > 0.0f) {
            float3 Cproc = make_float3(mixedLin.x - Yproc, mixedLin.y - Yproc, mixedLin.z - Yproc);
            float3 Csrc = make_float3(sourceLinForMix.x - Ysrc, sourceLinForMix.y - Ysrc, sourceLinForMix.z - Ysrc);

            // Mix regularized relative chroma using Yn = sqrt(Y^2 + k^2) (no singularity at black).
            float Yn_proc = _sqrtf(Yproc * Yproc + k_neg_hs_rel_k * k_neg_hs_rel_k);
            float Yn_src = _sqrtf(Ysrc * Ysrc + k_neg_hs_rel_k * k_neg_hs_rel_k);
            float invYproc = 1.0f / _fmaxf(Yn_proc, 1e-6f);
            float invYsrc = 1.0f / _fmaxf(Yn_src, 1e-6f);
            float3 Cproc_rel = make_float3(Cproc.x * invYproc, Cproc.y * invYproc, Cproc.z * invYproc);
            float3 Csrc_rel = make_float3(Csrc.x * invYsrc, Csrc.y * invYsrc, Csrc.z * invYsrc);
            float3 Cmix_rel = make_float3(
                Cproc_rel.x + (Csrc_rel.x - Cproc_rel.x) * hs_mix,
                Cproc_rel.y + (Csrc_rel.y - Cproc_rel.y) * hs_mix,
                Cproc_rel.z + (Csrc_rel.z - Cproc_rel.z) * hs_mix
            );
            // Soft-bound relative chroma (smooth rational saturation, no hard clamp).
            float s = _fmaxf(k_neg_hs_rel_soft_limit, 1e-6f);
            float3 Cmix_rel_soft = make_float3(
                (s * Cmix_rel.x) / _sqrtf(s * s + Cmix_rel.x * Cmix_rel.x),
                (s * Cmix_rel.y) / _sqrtf(s * s + Cmix_rel.y * Cmix_rel.y),
                (s * Cmix_rel.z) / _sqrtf(s * s + Cmix_rel.z * Cmix_rel.z)
            );
            float3 Cmix = make_float3(Cmix_rel_soft.x * Yn_proc, Cmix_rel_soft.y * Yn_proc, Cmix_rel_soft.z * Yn_proc);
            mixedLin = make_float3(Yproc + Cmix.x, Yproc + Cmix.y, Yproc + Cmix.z);
        }
    }

    return make_float3(
        linear_to_code_space(mixedLin.x, p.input_space),
        linear_to_code_space(mixedLin.y, p.input_space),
        linear_to_code_space(mixedLin.z, p.input_space)
    );
}

// Detect black bar thickness (left, top, right, bottom)
__DEVICE__ int4 get_black_bar_thickness(int p_Width, int p_Height, __TEXTURE__ p_TexR, __TEXTURE__ p_TexG, __TEXTURE__ p_TexB, float black_threshold, int input_space) {
    int4 thickness = make_int4(0, 0, 0, 0);

    int left = 0;
    int right = p_Height / 2;
    int center_x = p_Width / 2;

    while (left < right) {
        int mid = (left + right) / 2;
        float r = linear_to_di(code_to_linear_space(_tex2D(p_TexR, center_x, mid), input_space));
        float g = linear_to_di(code_to_linear_space(_tex2D(p_TexG, center_x, mid), input_space));
        float b = linear_to_di(code_to_linear_space(_tex2D(p_TexB, center_x, mid), input_space));
        if (_fabs(r) > black_threshold || _fabs(g) > black_threshold || _fabs(b) > black_threshold) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    thickness.y = left;

    left = 0;
    right = p_Height / 2;
    while (left < right) {
        int mid = (left + right) / 2;
        float r = linear_to_di(code_to_linear_space(_tex2D(p_TexR, center_x, p_Height - 1 - mid), input_space));
        float g = linear_to_di(code_to_linear_space(_tex2D(p_TexG, center_x, p_Height - 1 - mid), input_space));
        float b = linear_to_di(code_to_linear_space(_tex2D(p_TexB, center_x, p_Height - 1 - mid), input_space));
        if (_fabs(r) > black_threshold || _fabs(g) > black_threshold || _fabs(b) > black_threshold) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    thickness.w = left;

    left = 0;
    right = p_Width / 2;
    int center_y = p_Height / 2;
    while (left < right) {
        int mid = (left + right) / 2;
        float r = linear_to_di(code_to_linear_space(_tex2D(p_TexR, mid, center_y), input_space));
        float g = linear_to_di(code_to_linear_space(_tex2D(p_TexG, mid, center_y), input_space));
        float b = linear_to_di(code_to_linear_space(_tex2D(p_TexB, mid, center_y), input_space));
        if (_fabs(r) > black_threshold || _fabs(g) > black_threshold || _fabs(b) > black_threshold) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    thickness.x = left;

    left = 0;
    right = p_Width / 2;
    while (left < right) {
        int mid = (left + right) / 2;
        float r = linear_to_di(code_to_linear_space(_tex2D(p_TexR, p_Width - 1 - mid, center_y), input_space));
        float g = linear_to_di(code_to_linear_space(_tex2D(p_TexG, p_Width - 1 - mid, center_y), input_space));
        float b = linear_to_di(code_to_linear_space(_tex2D(p_TexB, p_Width - 1 - mid, center_y), input_space));
        if (_fabs(r) > black_threshold || _fabs(g) > black_threshold || _fabs(b) > black_threshold) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    thickness.z = left;

    return thickness;
}

__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, __TEXTURE__ p_TexR, __TEXTURE__ p_TexG, __TEXTURE__ p_TexB) {
    float3 inRGB = make_float3(_tex2D(p_TexR, p_X, p_Y), _tex2D(p_TexG, p_X, p_Y), _tex2D(p_TexB, p_X, p_Y));

    float amount_use = p_amount * p_safety;
    float overlay_amount = p_bypass ? 0.0f : amount_use;
    ProcessInput p_proc = make_process_input(p_input_space, p_region, p_center_shift, p_width, amount_use, p_amount, p_symmetry_bias, p_safety, p_preserve_mid_gray);
    ProcessInput p_overlay = make_process_input(p_input_space, p_region, p_center_shift, p_width, overlay_amount, p_amount, p_symmetry_bias, p_safety, p_preserve_mid_gray);
    ProcessInput p_overlay_di = make_process_input(SPACE_DI, p_region, p_center_shift, p_width, overlay_amount, p_amount, p_symmetry_bias, p_safety, p_preserve_mid_gray);
    float3 out_color = p_bypass ? inRGB : process_color(inRGB, p_proc);

    if (p_guide || p_curve || p_highlight_pivot_point) {
        int4 bar = get_black_bar_thickness(p_Width, p_Height, p_TexR, p_TexG, p_TexB, k_black_threshold, p_input_space);
        if (k_assume_centered) {
            int min_lr = (int)_fminf((float)bar.x, (float)bar.z);
            int min_tb = (int)_fminf((float)bar.y, (float)bar.w);
            bar = make_int4(min_lr, min_tb, min_lr, min_tb);
        }

        int eff_w = p_Width - bar.x - bar.z;
        int eff_h = p_Height - bar.y - bar.w;
        if (eff_w < 2 || eff_h < 2) {
            return out_color;
        }

        int x_in = p_X - bar.x;
        int y_in = p_Y - bar.y;
        if (x_in < 0 || y_in < 0 || x_in >= eff_w || y_in >= eff_h) {
            return out_color;
        }

        float x = (float)x_in / (float)(eff_w - 1);
        float y = (float)y_in / (float)(eff_h - 1);
        float guide_top = 1.0f - (k_guide_strip_height + k_guide_ramp_height);

        if (p_highlight_pivot_point) {
            CurveState s_overlay = solve_curve_state(p_overlay);
            float ydi_px = luminance_di_from_code(inRGB, p_input_space);
            float pivot_half = pivot_half_range_di(s_overlay, p_input_space);
            float center_stops = center_stops_from_center_di(s_overlay.center, p_input_space);
            float y_stops = center_stops_from_center_di(ydi_px, p_input_space);
            float dist_stops = _fabs(y_stops - center_stops);

            float hi_stops = center_stops_from_center_di(s_overlay.center + pivot_half, p_input_space);
            float lo_stops = center_stops_from_center_di(s_overlay.center - pivot_half, p_input_space);
            float edge_stops = 0.5f * _fabs(hi_stops - lo_stops);

            // Solid center band: +-0.5 stop. Outer half fades smoothly to zero.
            const float core_stops = 0.5f;
            float alpha = 0.0f;
            int in_core = dist_stops <= core_stops;
            if (dist_stops <= core_stops) {
                alpha = k_pivot_overlay_alpha;
            } else {
                float fade_span = _fmaxf(edge_stops - core_stops, 1e-6f);
                float t = saturatef((dist_stops - core_stops) / fade_span);
                alpha = k_pivot_overlay_alpha * (1.0f - smootherstep01(t));
            }

            if (alpha > 0.0f) {
                float3 pivot_green = encode_warn_color(make_float3(0.08f, 0.95f, 0.08f), p_input_space);
                // Yellow-green for smoother transition from the core band.
                float3 pivot_yellow = encode_warn_color(make_float3(0.78f, 0.95f, 0.10f), p_input_space);
                float3 pivot_color = pivot_yellow;
                if (in_core) {
                    float core_t = smootherstep01(saturatef(dist_stops / _fmaxf(core_stops, 1e-6f)));
                    pivot_color = make_float3(
                        pivot_green.x + (pivot_yellow.x - pivot_green.x) * core_t,
                        pivot_green.y + (pivot_yellow.y - pivot_green.y) * core_t,
                        pivot_green.z + (pivot_yellow.z - pivot_green.z) * core_t
                    );
                }
                out_color = make_float3(
                    out_color.x + (pivot_color.x - out_color.x) * alpha,
                    out_color.y + (pivot_color.y - out_color.y) * alpha,
                    out_color.z + (pivot_color.z - out_color.z) * alpha
                );
            }
        }

        if (p_curve) {
            // Fixed linear reference (identity) curve: dashed, 50% alpha, slightly dimmer than white.
            float y_ref = 1.0f - x;
            if (_fabs(y - y_ref) < k_curve_thickness) {
                int dash = ((int)(x * 60.0f)) & 1;
                if (dash == 0) {
                    float w_lin = 0.85f;
                    float w = linear_to_code_space(w_lin, p_input_space);
                    float3 ref = make_float3(w, w, w);
                    out_color = make_float3(
                        out_color.x + (ref.x - out_color.x) * 0.5f,
                        out_color.y + (ref.y - out_color.y) * 0.5f,
                        out_color.z + (ref.z - out_color.z) * 0.5f
                    );
                }
            }
            // Full-frame curve overlay in DI code domain (internal working space).
            float3 c = process_color(make_float3(x, x, x), p_overlay_di);
            // Do not clamp for display: values above/below visible range naturally go off-screen.
            float o_di = c.x;
            float y_curve = 1.0f - o_di;
            if (_fabs(y - y_curve) < k_curve_thickness) {
                float w = linear_to_code_space(1.0f, p_input_space);
                return make_float3(w, w, w);
            }
        }

        if (p_guide && y >= guide_top && y <= (guide_top + k_guide_strip_height)) {
            int middle = k_guide_steps / 2;
            int step = (int)_fminf((float)k_guide_steps - 1.0f, _fmaxf(0.0f, x * k_guide_steps));
            float v0 = guide_step_value_di(step);
            float v1 = guide_step_value_di(_fminf(step + 1, k_guide_steps - 1));
            float v_1 = guide_step_value_di(_fmaxf(step - 1, 0));

            float3 c0 = process_color(make_float3(v0, v0, v0), p_overlay_di);
            float3 c1 = process_color(make_float3(v1, v1, v1), p_overlay_di);
            float3 c_1 = process_color(make_float3(v_1, v_1, v_1), p_overlay_di);

            float o0 = c0.x;
            float o1 = c1.x;
            float o_1 = c_1.x;
            int interior = (step > 0) && (step < (k_guide_steps - 1));
            float step_stops = (float)(step - middle);
            float shadow_t = saturatef((-step_stops) / 7.0f); // 0 at mid/highs, 1 at ~7 stops below midgray
            shadow_t = smootherstep01(shadow_t);
            // Reduce sensitivity more in deep shadows
            float deep_shadow_scale = k_guide_shadow_sensitivity * k_guide_shadow_sensitivity;
            float shadow_scale = 1.0f + (deep_shadow_scale - 1.0f) * shadow_t;
            float close_thresh = k_guide_close_thresh * shadow_scale;
            float flat_thresh = k_guide_flat_thresh * shadow_scale;

            int too_close = interior && ((_fabs(o1 - o0) < close_thresh) || (_fabs(o0 - o_1) < close_thresh));
            float slope_avg = 0.5f * (_fabs(o0 - o_1) + _fabs(o1 - o0));
            int deep_shadow = step_stops <= -8.0f;
            int flat_warn = interior && !deep_shadow && (slope_avg < flat_thresh);
            float disp = di_code_to_space(o0, p_input_space);
            return guide_step_color(disp, too_close, flat_warn, p_input_space);
        } else if (p_guide && y >= (guide_top + k_guide_strip_height) && y <= (guide_top + k_guide_strip_height + k_guide_ramp_height)) {
            int middle = k_guide_steps / 2;
            float steps_range = (float)(k_guide_steps - 1);
            float stops = (x * steps_range) - (float)middle;
            float lin = k_guide_midgray_lin * _exp2f(stops);
            float v = linear_to_di(lin);
            float3 c = process_color(make_float3(v, v, v), p_overlay_di);
            float o = c.x;
            float disp = di_code_to_space(o, p_input_space);
            return make_float3(disp, disp, disp);
        }
    }

    return out_color;
}
