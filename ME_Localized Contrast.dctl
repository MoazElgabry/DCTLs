#line 2
/*
ME Localized Contrast v1.2.2
by Moaz Elgabry
moazelgabry.com
buymeacoffee.com/moazelgabry

Localized, smooth, range-limited contrast shaping.

Changelog:
v1.2.2 - *Refactored the codebase for better compaaibility with Opencl/Metal systems.
V1.2.1 - *Refined the chroma protection logic for negative Amount settings to better preserve color integrity while still allowing effective contrast shaping, especially in shadow regions. 
v1.2   - *Added a new Highlight Pivot Point toggle that draws a green guide over the pivot-centered middle band to help align exposure targets when shaping contrast.
         *Improved the chroma/luma protection logic in constrained shadow/highlight regions to better preserve color integrity while still allowing effective contrast shaping.
         *Better mapping of regional amount limits to the safety slider, with more gradual relaxation of constraints as safety increases.
v1.1   - *Reworked the tool for safer contrast shaping under extreme pushes: substantial tuning was added so results stay controlled and image integrity is protected, even at aggressive settings.
         *Replaced the old Safe Range toggle with a new Safety Fader: a smooth, gradual control that expands freedom progressively instead of hard-jumping between constrained/unconstrained behavior.
         *Added stability logic that keeps contrast growth usable and avoids "breaking" the image when pushing Amount/Center/Width in difficult regions.
v1.0   - Initial release


*/

DEFINE_UI_PARAMS(p_amount, Amount, DCTLUI_SLIDER_FLOAT, 0.0, -1.0, 1.0, 0.001)
DEFINE_UI_PARAMS(p_region, Region, DCTLUI_COMBO_BOX, 1, {shadows, mids, highlights, custom}, {Shadows, Midtones, Highlights, Custom})
DEFINE_UI_PARAMS(p_center_shift, Center Shift, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.001)
DEFINE_UI_PARAMS(p_width, Range Width, DCTLUI_SLIDER_FLOAT, 0.35, 0.1, 1.0, 0.001)
DEFINE_UI_PARAMS(p_symmetry_bias, Symmetry Bias, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.001)
DEFINE_UI_PARAMS(p_safety, Safety Fader, DCTLUI_SLIDER_FLOAT, 0.25, 0.25, 1.0, 0.001)
DEFINE_UI_PARAMS(p_preserve_mid_gray, Preserve Exposure, DCTLUI_CHECK_BOX, 1)
DEFINE_UI_PARAMS(p_highlight_pivot_point, Highlight Pivot Point, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(p_guide, Guide Ramp, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(p_curve, Curve Overlay, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(p_bypass, Bypass, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(p_input_space, Input Space, DCTLUI_COMBO_BOX, 1, {Linear, DI, ACEScct, LogC3}, {Linear, DaVinci Intermediate, ACEScct, ARRI LogC3})
DEFINE_UI_PARAMS(p_shoulder_smooth, Shoulder Smoothness, DCTLUI_SLIDER_FLOAT, 0.0, 0.0, 1.0, 0.001)

/*----------- Tooltips -----------------*/
#if ((__RESOLVE_VER_MAJOR__ > 19)) || ((__RESOLVE_VER_MAJOR__ == 19) && (__RESOLVE_VER_MINOR__ >= 1))
DEFINE_UI_TOOLTIP(Amount, "Local contrast strength. Positive increases separation, negative compresses.")
DEFINE_UI_TOOLTIP(Region, "Target tonal band. Shadows/Midtones/Highlights use stop-based ranges around midgray; Custom centers on the Center Shift value.")
DEFINE_UI_TOOLTIP(Center Shift, "Moves the center in stops. Shadows/Highlights are constrained to avoid crossing midgray; Custom spans a wider stop range.")
DEFINE_UI_TOOLTIP(Range Width, "Width of the affected range available only in custom mode. Auto-expands with higher Amount for smoother roll-off.")
DEFINE_UI_TOOLTIP(Input Space, "this should match the color space of the input footage for correct tonal targeting.")
DEFINE_UI_TOOLTIP(Bypass, "Disables processing (passes input through).")
DEFINE_UI_TOOLTIP(Symmetry Bias, "Biases localized contrast toward one side of the center. 0 = symmetric, + favors highlights side, - favors shadows side.")
DEFINE_UI_TOOLTIP(Preserve Exposure, "Applies a global linear gain so the processed image mid-gray returns to its original working-space value.")
DEFINE_UI_TOOLTIP(Highlight Pivot Point, "Draws a green guide over the pivot-centered middle band to help you align the operation around your targets when the image subject is not exactly at mid gray.")
DEFINE_UI_TOOLTIP(Guide Ramp, "Shows stepped/ramp guide. Red = steps too close (risk of clipping/flat areas). Yellow = low slope (flat curve warning).")
DEFINE_UI_TOOLTIP(Curve Overlay, "Draws the curve response on the image to visualize the current settings. the curve is encoded in the output space of the tool, so it reflects the actual applied contrast shaping.")
DEFINE_UI_TOOLTIP(Safety Fader, "Controls how tightly Amount is constrained. Lower values are safer; higher values allow more range.")
DEFINE_UI_TOOLTIP(Shoulder Smoothness, "Global shoulder feel. 0 = stronger shoulder, 1 = smoother shoulder roll-off.")
#endif

#define SPACE_LINEAR 0
#define SPACE_DI 1
#define SPACE_ACEScct 2
#define SPACE_LOGC3 3

// NOTE:
// Keep helpers scalar + return-value based in this branch.
// OpenCL/Metal proved fragile with some void/pointer helper patterns in earlier versions.

// Custom mode center travel in stops (+/- from mid gray).
#define k_custom_center_range_stops 11.0f
// Base amount scaling by tonal distance from mid gray.
#define k_amount_scale_mid 1.0f
#define k_amount_scale_sh 0.6f
#define k_amount_scale_extreme 0.4f
// At high Safety, relax taper to open more creative range.
#define k_safety_taper_relax 0.25f
// Custom mode: narrow widths get attenuated amount.
#define k_custom_amount_min_scale 0.2f
#define k_custom_width_min 0.05f
#define k_custom_width_max 1.0f
// Width auto-expansion response vs amount push.
#define k_range_expand 0.6f
#define k_range_expand_power 2.0f
#define k_width_expand_softness 0.65f
#define k_width_expand_log_beta 6.0f
#define k_width_expand_input_smooth 0.70f
#define k_amount_smooth_knee 0.03f
// Stability limiter envelope for amount vs width.
#define k_amount_width_limit_safe 0.8f
#define k_amount_width_limit_max 1.0f
// Keep support slightly inside DI domain edges.
#define k_curve_domain_margin 0.01f
// Safety slider normalization endpoints.
#define k_safety_min 0.25f
#define k_safety_max 1.0f
// Practical DI headroom around mid gray (stops).
#define k_di_above_midgray_stops 9.12f
#define k_di_below_midgray_stops 9.0f
// Soft zone near headroom limits to avoid hard wall feel.
#define k_di_headroom_soft_stops 0.35f
// Negative mode chroma recovery bounds (below/above mid behavior).
#define k_neg_hs_min_below_mid 0.5f
#define k_neg_hs_max_below_mid 0.70f
#define k_neg_hs_min_above_mid 0.08f
#define k_neg_hs_max_above_mid 0.16f
// Split position + transition softness in stops for HS recovery.
#define k_neg_hs_split_center_stops 0.7f
#define k_neg_hs_split_soft_stops 1.2f
// Regularization / soft-limit for relative chroma recovery.
#define k_neg_hs_rel_k 0.02f
#define k_neg_hs_rel_soft_limit 4.0f
// Fade HS recovery near black for stability.
#define k_neg_hs_black_y0 0.005f
#define k_neg_hs_black_y1 0.03f
// Region-boundary chroma protection strength and fade range.
#define k_chroma_protect_strength 0.9f
#define k_chroma_protect_boundary_fraction 0.35f
// Pivot overlay and dashed identity reference opacity.
#define k_pivot_overlay_alpha 0.35f
#define k_curve_ref_alpha 0.75f
// Black-bar detection threshold + centered bars assumption.
#define k_black_threshold 0.01f
#define k_assume_centered 1
// Guide strip layout.
#define k_guide_strip_height 0.08f
#define k_guide_ramp_height 0.06f
#define k_guide_steps 21
#define k_guide_midgray_lin 0.18f
// Guide warning thresholds.
#define k_guide_close_thresh (1.0f / 256.0f)
#define k_guide_flat_thresh (1.0f / 28.0f)
#define k_guide_shadow_sensitivity 0.5f
// Curve drawing thickness.
#define k_curve_thickness 0.003f
// Post-shape cohesion limiter controls.
#define k_max_separation_stops 4.0f
#define k_limit_softness 2.0f
#define k_limit_expand 0.6f
#define k_cohesion 0.1f

__DEVICE__ float saturatef(float x) { return _fminf(_fmaxf(x, 0.0f), 1.0f); }
__DEVICE__ float smootherstep01(float x) { x = saturatef(x); return x * x * x * (x * (x * 6.0f - 15.0f) + 10.0f); }
__DEVICE__ float smooth_absf(float x, float knee) {
    float k = _fmaxf(knee, 1e-6f);
    return _sqrtf(x * x + k * k) - k;
}
__DEVICE__ float stops_to_di_code(float stops, int input_space);

__DEVICE__ float di_to_linear(float t) {
    const float a = 0.0075f, b = 7.0f, c = 0.07329248f, m = 10.44426855f, log_cut = 0.02740668f;
    return (t > log_cut) ? _exp2f((t / c) - b) - a : t / m;
}
__DEVICE__ float linear_to_di(float x) {
    const float a = 0.0075f, b = 7.0f, c = 0.07329248f, m = 10.44426855f, lin_cut = 0.00262409f;
    x = _fmaxf(x, 0.0f);
    return (x > lin_cut) ? (_log2f(x + a) + b) * c : x * m;
}
__DEVICE__ float acescct_to_linear(float x) {
    const float cut2 = 0.155251141552511f;
    const float A = 10.5402377416545f, B = 0.0729055341958355f, C = 9.72f, D = 17.52f;
    return (x <= cut2) ? (x - B) / A : _exp2f(x * D - C);
}
__DEVICE__ float linear_to_acescct(float x) {
    const float cut1 = 0.0078125f;
    const float A = 10.5402377416545f, B = 0.0729055341958355f, C = 9.72f, D = 17.52f;
    x = _fmaxf(x, 0.0f);
    return (x <= cut1) ? A * x + B : (_log2f(x) + C) / D;
}
__DEVICE__ float logc3_to_linear(float x) {
    const float cut = 0.010591f, a = 5.555556f, b = 0.052272f, c = 0.247190f, d = 0.385537f, e = 5.367655f, f = 0.092809f;
    const float cut_code = e * cut + f;
    return _fmaxf((x < cut_code) ? ((x - f) / e) : ((_exp10f((x - d) / c) - b) / a), 0.0f);
}
__DEVICE__ float linear_to_logc3(float x) {
    const float cut = 0.010591f, a = 5.555556f, b = 0.052272f, c = 0.247190f, d = 0.385537f, e = 5.367655f, f = 0.092809f;
    x = _fmaxf(x, 0.0f);
    return (x < cut) ? (e * x + f) : (c * _log10f(a * x + b) + d);
}
__DEVICE__ float code_to_linear_space(float code, int s) {
    if (s == SPACE_LINEAR) return code;
    if (s == SPACE_DI) return di_to_linear(code);
    if (s == SPACE_ACEScct) return acescct_to_linear(code);
    if (s == SPACE_LOGC3) return logc3_to_linear(code);
    return code;
}
__DEVICE__ float linear_to_code_space(float lin, int s) {
    if (s == SPACE_LINEAR) return lin;
    if (s == SPACE_DI) return linear_to_di(lin);
    if (s == SPACE_ACEScct) return linear_to_acescct(lin);
    if (s == SPACE_LOGC3) return linear_to_logc3(lin);
    return lin;
}

__DEVICE__ float region_center_stops(int region) {
    if (region == 0) return -2.5f;
    if (region == 1) return 0.0f;
    if (region == 2) return 2.0f;
    return 0.5f;
}
__DEVICE__ float region_width_stops(int region) {
    if (region == 0) return 4.0f;
    if (region == 1) return 8.0f;
    if (region == 2) return 6.0f;
    return 6.0f;
}
__DEVICE__ float remap_center_stops(int region, float center_shift) {
    // Center Shift remap is region-aware and headroom-aware.
    // This keeps slider travel useful without letting centers jump into invalid tone areas.
    float base = region_center_stops(region);
    float half_range = 0.5f * region_width_stops(region);
    float min_s = base - half_range;
    float max_s = base + half_range;
    if (region == 2) min_s = 0.0f;
    if (region == 0) max_s = 0.0f;
    min_s = _fmaxf(min_s, -k_di_below_midgray_stops);
    max_s = _fminf(max_s, k_di_above_midgray_stops);
    if (base <= min_s) {
        base = min_s;
    } else if (base >= max_s) {
        base = max_s;
    } else {
        float soft = _fmaxf(k_di_headroom_soft_stops, 1e-6f);
        if (base < (min_s + soft)) {
            float t = (base - min_s) / soft;
            float s = smootherstep01(t);
            base = min_s + (base - min_s) * s;
        } else if (base > (max_s - soft)) {
            float d = (max_s - base);
            float t = d / soft;
            float s = smootherstep01(t);
            base = max_s - (max_s - base) * s;
        }
    }
    float u = _fminf(_fmaxf(center_shift / 0.5f, -1.0f), 1.0f);
    return (u >= 0.0f) ? (base + u * (max_s - base)) : (base + u * (base - min_s));
}
__DEVICE__ float amount_scale_for_center(float center_stops, float safety) {
    // Regional sensitivity model:
    // near mids = full response, extremes = progressively damped.
    // Safety then relaxes part of that damping so the slider opens up smoothly.
    float abs_c = _fabs(center_stops);
    if (abs_c <= 0.5f) return k_amount_scale_mid;
    float t = smootherstep01(_fminf((abs_c - 0.75f) / 1.25f, 1.0f));
    float base = k_amount_scale_mid + (k_amount_scale_sh - k_amount_scale_mid) * t;
    float t2 = smootherstep01(_fminf(_fmaxf((abs_c - 2.0f) / 4.0f, 0.0f), 1.0f));
    float scale = base + (k_amount_scale_extreme - base) * t2;
    float s = _fminf(_fmaxf((safety - k_safety_min) / (k_safety_max - k_safety_min), 0.0f), 1.0f);
    scale = scale + (1.0f - scale) * (k_safety_taper_relax * s);
    float min_scale = 0.4f * (1.0f - s);
    return _fmaxf(scale, min_scale);
}
__DEVICE__ float default_width_from_region(int region, int input_space, float user_width) {
    if (region == 3) return user_width;
    float half_w = 0.5f * region_width_stops(region);
    float c = region_center_stops(region);
    float low_code = stops_to_di_code(c - half_w, input_space);
    float high_code = stops_to_di_code(c + half_w, input_space);
    return _fmaxf(0.001f, high_code - low_code);
}
__DEVICE__ float custom_amount_scale_from_width(float width_user) {
    float t = (width_user - k_custom_width_min) / _fmaxf(k_custom_width_max - k_custom_width_min, 1e-6f);
    t = _fminf(_fmaxf(t, 0.0f), 1.0f);
    return k_custom_amount_min_scale + (1.0f - k_custom_amount_min_scale) * t;
}
__DEVICE__ float expand_width_by_amount(float width, float amount) {
    float a = smooth_absf(amount, k_amount_smooth_knee);
    a = saturatef(a);
    float a_quintic = smootherstep01(a);
    a = a + (a_quintic - a) * saturatef(k_width_expand_input_smooth);
    float e = _expf(k_range_expand_power * a);
    float denom = _expf(k_range_expand_power) - 1.0f;
    float w_exp = 1.0f + k_range_expand * (e - 1.0f) / _fmaxf(denom, 1e-6f);
    float beta = _fmaxf(k_width_expand_log_beta, 1e-6f);
    float w_log = 1.0f + k_range_expand * (_logf(1.0f + beta * a) / _fmaxf(_logf(1.0f + beta), 1e-6f));
    float soft_t = saturatef(k_width_expand_softness);
    float w = w_exp + (w_log - w_exp) * soft_t;
    return width * w;
}
__DEVICE__ float amount_from_target_width(float base_width, float target_width) {
    float b = _fmaxf(base_width, 1e-6f);
    float t = _fmaxf(target_width, 0.0f) / b;
    float max_factor = 1.0f + k_range_expand;
    t = _fminf(_fmaxf(t, 1.0f), max_factor);
    float s = (t - 1.0f) / _fmaxf(k_range_expand, 1e-6f);
    s = _fminf(_fmaxf(s, 0.0f), 1.0f);
    float exp_base = _expf(k_range_expand_power);
    float e = 1.0f + s * (exp_base - 1.0f);
    return _logf(_fmaxf(e, 1e-6f)) / _fmaxf(k_range_expand_power, 1e-6f);
}
__DEVICE__ float limit_amount_for_stability(float amount, float width, float symmetry_bias, float safety) {
    float s = (safety - k_safety_min) / _fmaxf(k_safety_max - k_safety_min, 1e-6f);
    s = _fminf(_fmaxf(s, 0.0f), 1.0f);
    float k_amount_width_limit = k_amount_width_limit_safe + (k_amount_width_limit_max - k_amount_width_limit_safe) * s;
    float side_factor = 1.0f + _fabs(symmetry_bias);
    float cap = _fmaxf(0.02f, (k_amount_width_limit * width) / _fmaxf(side_factor, 1e-6f));
    float a = _fabs(amount);
    float a_limited = cap * (1.0f - _expf(-a / _fmaxf(cap, 1e-6f)));
    return _copysignf(a_limited, amount);
}
__DEVICE__ float localized_s_curve(float x, float amount, float center, float width, float symmetry_bias, float shoulder_t) {
    // Localized odd curve with compact support.
    // Symmetry bias tips influence to one side around the pivot.
    float halfW = _fmaxf(0.0005f, 0.5f * width);
    float t = (x - center) / halfW;
    float u = saturatef(1.0f - t * t);
    float env = smootherstep01(u);
    float env_soft = u * u;
    env = env + (env_soft - env) * saturatef(shoulder_t);
    float b = _fminf(_fmaxf(symmetry_bias, -1.0f), 1.0f);
    const float k_symmetry_softness = 0.28f;
    float t_softsign = t / _sqrtf(t * t + k_symmetry_softness * k_symmetry_softness);
    float side_gain = 1.0f + b * t_softsign;
    float delta_raw = amount * t * env * side_gain * 0.5f;
    // Soft output limiter keeps the DI-domain mapping stable near hard bounds.
    const float k_out_margin = 1e-4f;
    float room_down = _fmaxf(x - k_out_margin, 1e-6f);
    float room_up = _fmaxf((1.0f - k_out_margin) - x, 1e-6f);
    float delta = delta_raw;
    if (delta_raw < 0.0f) {
        float z = (-delta_raw) / room_down;
        delta = -room_down * (z / (1.0f + z));
    } else {
        float z = delta_raw / room_up;
        delta = room_up * (z / (1.0f + z));
    }
    return x + delta;
}
__DEVICE__ float soft_limit_stops(float stops, float max_stops) {
    float abs_s = _fabs(stops);
    if (abs_s <= max_stops) return stops;
    float over = abs_s - max_stops;
    float soft_over = (over * k_limit_expand) / (1.0f + over / _fmaxf(1e-6f, k_limit_softness));
    float abs_out = max_stops + soft_over;
    return _copysignf(abs_out, stops);
}
__DEVICE__ float stops_to_di_code(float stops, int input_space) {
    float target_lin = 0.18f * _powf(2.0f, stops);
    float target_code = linear_to_code_space(target_lin, input_space);
    return linear_to_di(code_to_linear_space(target_code, input_space));
}
__DEVICE__ float preserve_midgray_gain(float amount, float center, float width, float symmetry_bias, float shoulder_t) {
    float mid_in = 0.18f;
    float mid_di = linear_to_di(mid_in);
    float mid_di_shaped = localized_s_curve(mid_di, amount, center, width, symmetry_bias, shoulder_t);
    float mid_out = di_to_linear(_fmaxf(0.0f, mid_di_shaped));
    float ratio = mid_out / _fmaxf(mid_in, 1e-6f);
    float stops = _log2f(_fmaxf(ratio, 1e-6f));
    float stops_soft = soft_limit_stops(stops, k_max_separation_stops);
    float ratio_soft = _exp2f(stops_soft);
    float mid_cohesive = mid_in + (mid_in * ratio_soft - mid_in) * (1.0f - k_cohesion);
    return mid_in / _fmaxf(mid_cohesive, 1e-6f);
}
__DEVICE__ float apply_preserve_to_di(float di_v, float g_mid) {
    float lin = di_to_linear(_fmaxf(0.0f, di_v));
    lin = _fmaxf(0.0f, lin * g_mid);
    return linear_to_di(lin);
}
__DEVICE__ float luminance_di_from_code(float r, float g, float b, int input_space) {
    float lr = code_to_linear_space(r, input_space);
    float lg = code_to_linear_space(g, input_space);
    float lb = code_to_linear_space(b, input_space);
    float y = _fmaxf(1e-6f, 0.2126f * lr + 0.7152f * lg + 0.0722f * lb);
    return linear_to_di(y);
}
__DEVICE__ float guide_step_value_di(int step) {
    int middle = k_guide_steps / 2;
    float stops = (float)(step - middle);
    float lin = k_guide_midgray_lin * _exp2f(stops);
    return linear_to_di(lin);
}
__DEVICE__ float di_code_to_space(float di_code, int output_space) {
    float lin = di_to_linear(di_code);
    return linear_to_code_space(lin, output_space);
}
__DEVICE__ int4 get_black_bar_thickness(int p_Width, int p_Height, __TEXTURE__ p_TexR, __TEXTURE__ p_TexG, __TEXTURE__ p_TexB, float black_threshold, int input_space) {
    int4 thickness = make_int4(0, 0, 0, 0);

    int left = 0;
    int right = p_Height / 2;
    int center_x = p_Width / 2;

    while (left < right) {
        int mid = (left + right) / 2;
        float r = linear_to_di(code_to_linear_space(_tex2D(p_TexR, center_x, mid), input_space));
        float g = linear_to_di(code_to_linear_space(_tex2D(p_TexG, center_x, mid), input_space));
        float b = linear_to_di(code_to_linear_space(_tex2D(p_TexB, center_x, mid), input_space));
        if (_fabs(r) > black_threshold || _fabs(g) > black_threshold || _fabs(b) > black_threshold) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    thickness.y = left;

    left = 0;
    right = p_Height / 2;
    while (left < right) {
        int mid = (left + right) / 2;
        float r = linear_to_di(code_to_linear_space(_tex2D(p_TexR, center_x, p_Height - 1 - mid), input_space));
        float g = linear_to_di(code_to_linear_space(_tex2D(p_TexG, center_x, p_Height - 1 - mid), input_space));
        float b = linear_to_di(code_to_linear_space(_tex2D(p_TexB, center_x, p_Height - 1 - mid), input_space));
        if (_fabs(r) > black_threshold || _fabs(g) > black_threshold || _fabs(b) > black_threshold) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    thickness.w = left;

    left = 0;
    right = p_Width / 2;
    int center_y = p_Height / 2;
    while (left < right) {
        int mid = (left + right) / 2;
        float r = linear_to_di(code_to_linear_space(_tex2D(p_TexR, mid, center_y), input_space));
        float g = linear_to_di(code_to_linear_space(_tex2D(p_TexG, mid, center_y), input_space));
        float b = linear_to_di(code_to_linear_space(_tex2D(p_TexB, mid, center_y), input_space));
        if (_fabs(r) > black_threshold || _fabs(g) > black_threshold || _fabs(b) > black_threshold) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    thickness.x = left;

    left = 0;
    right = p_Width / 2;
    while (left < right) {
        int mid = (left + right) / 2;
        float r = linear_to_di(code_to_linear_space(_tex2D(p_TexR, p_Width - 1 - mid, center_y), input_space));
        float g = linear_to_di(code_to_linear_space(_tex2D(p_TexG, p_Width - 1 - mid, center_y), input_space));
        float b = linear_to_di(code_to_linear_space(_tex2D(p_TexB, p_Width - 1 - mid, center_y), input_space));
        if (_fabs(r) > black_threshold || _fabs(g) > black_threshold || _fabs(b) > black_threshold) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    thickness.z = left;

    return thickness;
}

__DEVICE__ float process_gain_scalar(float lr, float lg, float lb, float center, float width, float amount, float symmetry_bias, float shoulder_t) {
    // Luma-domain shaping gain (cohesion-limited), returned as scalar for stability.
    float Y = _fmaxf(1e-6f, 0.2126f * lr + 0.7152f * lg + 0.0722f * lb);
    float Ydi = linear_to_di(Y);
    float YdiS = localized_s_curve(Ydi, amount, center, width, symmetry_bias, shoulder_t);
    float Y2 = di_to_linear(_fmaxf(0.0f, YdiS));
    float ratio = Y2 / _fmaxf(Y, 1e-6f);
    float stops = _log2f(_fmaxf(ratio, 1e-6f));
    float stops_soft = soft_limit_stops(stops, k_max_separation_stops);
    float ratio_soft = _exp2f(stops_soft);
    float Ylimited = Y * ratio_soft;
    float Ycohesive = Y + (Ylimited - Y) * (1.0f - k_cohesion);
    return Ycohesive / _fmaxf(Y, 1e-6f);
}

__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, __TEXTURE__ p_TexR, __TEXTURE__ p_TexG, __TEXTURE__ p_TexB) {
    float3 inRGB = make_float3(_tex2D(p_TexR, p_X, p_Y), _tex2D(p_TexG, p_X, p_Y), _tex2D(p_TexB, p_X, p_Y));
    float lr = code_to_linear_space(inRGB.x, p_input_space);
    float lg = code_to_linear_space(inRGB.y, p_input_space);
    float lb = code_to_linear_space(inRGB.z, p_input_space);
    float shoulder_t = saturatef(p_shoulder_smooth);
    // Processing amount is safety-weighted by design.
    float amount_use = p_amount * p_safety;
    float cst = remap_center_stops(p_region, p_center_shift);
    if (p_region == 3) cst = p_center_shift * k_custom_center_range_stops * 2.0f;
    float center = stops_to_di_code(cst, p_input_space);
    float base_width = default_width_from_region(p_region, p_input_space, p_width);
    float amount_scaled = amount_use * amount_scale_for_center(cst, p_safety);
    float amount_for_width = amount_scaled;
    if (p_region == 3) {
        float custom_scale = custom_amount_scale_from_width(p_width);
        amount_scaled = amount_scaled * custom_scale;
        amount_for_width = amount_for_width * custom_scale;
    }
    float width = expand_width_by_amount(base_width, amount_for_width);

    // Support bounds + center clamping:
    // keep the active band inside valid domain and regional constraints.
    float dmin = 0.0f + k_curve_domain_margin;
    float dmax = 1.0f - k_curve_domain_margin;
    float midgray_di = stops_to_di_code(0.0f, p_input_space);
    float bmin = dmin;
    float bmax = dmax;
    if (p_region == 0) bmax = midgray_di;
    if (p_region == 2) bmin = midgray_di;
    float region_max_width = _fmaxf(0.001f, bmax - bmin);

    if (width > region_max_width) {
        float a_cap = amount_from_target_width(base_width, region_max_width);
        float a_abs_w = _fabs(amount_for_width);
        if (a_cap < a_abs_w) amount_for_width = _copysignf(a_cap, amount_for_width);
        float a_abs_s = _fabs(amount_scaled);
        if (a_cap < a_abs_s) amount_scaled = _copysignf(a_cap, amount_scaled);
        width = _fminf(expand_width_by_amount(base_width, amount_for_width), region_max_width);
    }

    float halfW = 0.5f * width;
    float cmin = bmin + halfW;
    float cmax = bmax - halfW;
    if (p_region == 1) {
        center = _fminf(_fmaxf(center, bmin), bmax);
    } else if (cmin <= cmax) {
        center = _fminf(_fmaxf(center, cmin), cmax);
    } else {
        width = region_max_width;
        center = 0.5f * (bmin + bmax);
    }

    amount_scaled = limit_amount_for_stability(amount_scaled, width, p_symmetry_bias, p_safety);

    float g_proc = process_gain_scalar(lr, lg, lb, center, width, amount_scaled, p_symmetry_bias, shoulder_t);
    float luma_lr = lr * g_proc;
    float luma_lg = lg * g_proc;
    float luma_lb = lb * g_proc;

    float r_di = linear_to_di(lr);
    float g_di = linear_to_di(lg);
    float b_di = linear_to_di(lb);
    float rgb_lr = di_to_linear(_fmaxf(0.0f, localized_s_curve(r_di, amount_scaled, center, width, p_symmetry_bias, shoulder_t)));
    float rgb_lg = di_to_linear(_fmaxf(0.0f, localized_s_curve(g_di, amount_scaled, center, width, p_symmetry_bias, shoulder_t)));
    float rgb_lb = di_to_linear(_fmaxf(0.0f, localized_s_curve(b_di, amount_scaled, center, width, p_symmetry_bias, shoulder_t)));

    // Positive amount favors RGB-path shaping; negative amount leans toward luma coherence.
    float blend = (amount_use >= 0.0f) ? 1.0f : 0.0f;
    if (p_region == 0 || p_region == 2) {
        float gap = (p_region == 0) ? (bmax - (center + halfW)) : ((center - halfW) - bmin);
        gap = _fmaxf(gap, 0.0f);
        float fade = _fmaxf(1e-6f, k_chroma_protect_boundary_fraction * halfW);
        float near_boundary = 1.0f - smootherstep01(_fminf(gap / fade, 1.0f));
        float amount_stress = _fminf(_fabs(amount_scaled) / _fmaxf(0.8f * width, 1e-6f), 1.0f);
        amount_stress = smootherstep01(amount_stress);
        float protect = k_chroma_protect_strength * near_boundary * amount_stress;
        blend = blend + (1.0f - blend) * protect;
    }

    float out_lr = rgb_lr + (luma_lr - rgb_lr) * blend;
    float out_lg = rgb_lg + (luma_lg - rgb_lg) * blend;
    float out_lb = rgb_lb + (luma_lb - rgb_lb) * blend;
    float src_lr = lr;
    float src_lg = lg;
    float src_lb = lb;
    if (p_preserve_mid_gray != 0) {
        float g_mid = preserve_midgray_gain(amount_scaled, center, width, p_symmetry_bias, shoulder_t);
        out_lr = out_lr * g_mid;
        out_lg = out_lg * g_mid;
        out_lb = out_lb * g_mid;
        src_lr = src_lr * g_mid;
        src_lg = src_lg * g_mid;
        src_lb = src_lb * g_mid;
    }

    // Step-2: negative-amount chroma recovery (scalar form, no pointer helpers).
        if (p_amount < 0.0f) {
            // Negative mode chroma recovery:
            // restore controlled color energy with a luminance/safety-aware mix.
            float Yproc = _fmaxf(1e-6f, 0.2126f * out_lr + 0.7152f * out_lg + 0.0722f * out_lb);
        float Ysrc = _fmaxf(1e-6f, 0.2126f * src_lr + 0.7152f * src_lg + 0.0722f * src_lb);
        float y_stops = _log2f(Ysrc / 0.18f);
        float split_t = saturatef(((y_stops - k_neg_hs_split_center_stops) + k_neg_hs_split_soft_stops) / _fmaxf(2.0f * k_neg_hs_split_soft_stops, 1e-6f));
        split_t = smootherstep01(split_t);
        float min_mix_zone = k_neg_hs_min_below_mid + (k_neg_hs_min_above_mid - k_neg_hs_min_below_mid) * split_t;
        float max_mix_zone = k_neg_hs_max_below_mid + (k_neg_hs_max_above_mid - k_neg_hs_max_below_mid) * split_t;

        float amount_t = smootherstep01(saturatef(-p_amount));
        float mix_at_safety_min = min_mix_zone * amount_t;
        float safety_t = smootherstep01(saturatef((p_safety - k_safety_min) / _fmaxf(k_safety_max - k_safety_min, 1e-6f)));
        float hs_mix = mix_at_safety_min + (max_mix_zone - mix_at_safety_min) * safety_t;
        float black_t = smootherstep01(saturatef((Ysrc - k_neg_hs_black_y0) / _fmaxf(k_neg_hs_black_y1 - k_neg_hs_black_y0, 1e-6f)));
        hs_mix *= black_t;

        if (hs_mix > 0.0f) {
            float Cproc_r = out_lr - Yproc;
            float Cproc_g = out_lg - Yproc;
            float Cproc_b = out_lb - Yproc;
            float Csrc_r = src_lr - Ysrc;
            float Csrc_g = src_lg - Ysrc;
            float Csrc_b = src_lb - Ysrc;

            float Yn_proc = _sqrtf(Yproc * Yproc + k_neg_hs_rel_k * k_neg_hs_rel_k);
            float Yn_src = _sqrtf(Ysrc * Ysrc + k_neg_hs_rel_k * k_neg_hs_rel_k);
            float invYproc = 1.0f / _fmaxf(Yn_proc, 1e-6f);
            float invYsrc = 1.0f / _fmaxf(Yn_src, 1e-6f);
            float Cproc_rel_r = Cproc_r * invYproc;
            float Cproc_rel_g = Cproc_g * invYproc;
            float Cproc_rel_b = Cproc_b * invYproc;
            float Csrc_rel_r = Csrc_r * invYsrc;
            float Csrc_rel_g = Csrc_g * invYsrc;
            float Csrc_rel_b = Csrc_b * invYsrc;

            float Cmix_rel_r = Cproc_rel_r + (Csrc_rel_r - Cproc_rel_r) * hs_mix;
            float Cmix_rel_g = Cproc_rel_g + (Csrc_rel_g - Cproc_rel_g) * hs_mix;
            float Cmix_rel_b = Cproc_rel_b + (Csrc_rel_b - Cproc_rel_b) * hs_mix;

            float s_rel = _fmaxf(k_neg_hs_rel_soft_limit, 1e-6f);
            float Cmix_rel_soft_r = (s_rel * Cmix_rel_r) / _sqrtf(s_rel * s_rel + Cmix_rel_r * Cmix_rel_r);
            float Cmix_rel_soft_g = (s_rel * Cmix_rel_g) / _sqrtf(s_rel * s_rel + Cmix_rel_g * Cmix_rel_g);
            float Cmix_rel_soft_b = (s_rel * Cmix_rel_b) / _sqrtf(s_rel * s_rel + Cmix_rel_b * Cmix_rel_b);

            float Cmix_r = Cmix_rel_soft_r * Yn_proc;
            float Cmix_g = Cmix_rel_soft_g * Yn_proc;
            float Cmix_b = Cmix_rel_soft_b * Yn_proc;

            out_lr = Yproc + Cmix_r;
            out_lg = Yproc + Cmix_g;
            out_lb = Yproc + Cmix_b;
        }
    }

    float3 outColor = (p_bypass != 0) ? inRGB : make_float3(
        linear_to_code_space(out_lr, p_input_space),
        linear_to_code_space(out_lg, p_input_space),
        linear_to_code_space(out_lb, p_input_space)
    );
    float amount_scaled_overlay = (p_bypass != 0) ? 0.0f : amount_scaled;
    float width_overlay = (p_bypass != 0) ? base_width : width;
    float halfW_overlay = 0.5f * width_overlay;
    float center_overlay = center;
    float g_mid_overlay = 1.0f;
    if (p_preserve_mid_gray != 0) {
        g_mid_overlay = preserve_midgray_gain(amount_scaled_overlay, center_overlay, width_overlay, p_symmetry_bias, shoulder_t);
    }

    if (p_highlight_pivot_point != 0) {
        int4 bar = get_black_bar_thickness(p_Width, p_Height, p_TexR, p_TexG, p_TexB, k_black_threshold, p_input_space);
        if (k_assume_centered) {
            int min_lr = (int)_fminf((float)bar.x, (float)bar.z);
            int min_tb = (int)_fminf((float)bar.y, (float)bar.w);
            bar = make_int4(min_lr, min_tb, min_lr, min_tb);
        }
        int eff_w = p_Width - bar.x - bar.z;
        int eff_h = p_Height - bar.y - bar.w;
        int x_in = p_X - bar.x;
        int y_in = p_Y - bar.y;
        if (eff_w > 1 && eff_h > 1 && x_in >= 0 && y_in >= 0 && x_in < eff_w && y_in < eff_h) {
            float y_stops = _log2f(_fmaxf(1e-6f, di_to_linear(luminance_di_from_code(inRGB.x, inRGB.y, inRGB.z, p_input_space))) / 0.18f);
            float center_stops_overlay = _log2f(_fmaxf(1e-6f, di_to_linear(center_overlay)) / 0.18f);
            float dist_stops = _fabs(y_stops - center_stops_overlay);
            float lo1 = stops_to_di_code(center_stops_overlay - 1.0f, p_input_space);
            float hi1 = stops_to_di_code(center_stops_overlay + 1.0f, p_input_space);
            float one_stop_half = 0.5f * _fabs(hi1 - lo1);
            float pivot_half = _fmaxf(0.001f, _fminf(halfW_overlay, one_stop_half));
                    float hi_stops = _log2f(_fmaxf(1e-6f, di_to_linear(center_overlay + pivot_half)) / 0.18f);
                    float lo_stops = _log2f(_fmaxf(1e-6f, di_to_linear(center_overlay - pivot_half)) / 0.18f);
                    // Keep highlight span capped to 2 stops total (+-1 stop).
                    float edge_stops = _fminf(1.0f, 0.5f * _fabs(hi_stops - lo_stops));
                    // +25% wider solid core for better visibility.
                    float core_stops = 0.625f;
                    float alpha = 0.0f;
                    if (dist_stops <= core_stops) {
                        alpha = k_pivot_overlay_alpha;
                    } else {
                        // Extend outer fade range for softer feathering in the outer band.
                        float outer_fade_end = edge_stops + 0.35f * _fmaxf(edge_stops - core_stops, 1e-6f);
                        float t = saturatef((dist_stops - core_stops) / _fmaxf(outer_fade_end - core_stops, 1e-6f));
                        alpha = k_pivot_overlay_alpha * (1.0f - smootherstep01(t));
            }
            if (alpha > 0.0f) {
                        float3 pivot_green = make_float3(
                            linear_to_di(0.00f),
                            linear_to_di(0.55f),
                            linear_to_di(0.03f)
                        );
                        float3 pivot_blue = make_float3(
                            linear_to_di(0.00f),
                            linear_to_di(0.35f),
                            linear_to_di(0.50f)
                        );
                        // Widen and soften green->blue transition around the core boundary.
                        float core_blend_start = core_stops * 0.20f;
                        float core_blend_end = _fmaxf(core_stops * 1.35f, core_stops + 1e-6f);
                        float core_blend_t = saturatef((dist_stops - core_blend_start) / _fmaxf(core_blend_end - core_blend_start, 1e-6f));
                        core_blend_t = smootherstep01(core_blend_t);
                        core_blend_t = smootherstep01(core_blend_t);
                        float3 pivot_color = make_float3(
                            pivot_green.x + (pivot_blue.x - pivot_green.x) * core_blend_t,
                            pivot_green.y + (pivot_blue.y - pivot_green.y) * core_blend_t,
                            pivot_green.z + (pivot_blue.z - pivot_green.z) * core_blend_t
                        );
                // Additive tint reference (not compositing): keeps visibility stronger in highlights.
                float pivot_n = (pivot_color.x + pivot_color.y + pivot_color.z) / 3.0f;
                float tint_r = pivot_color.x - pivot_n;
                float tint_g = pivot_color.y - pivot_n;
                float tint_b = pivot_color.z - pivot_n;
                float mix_lin_r = saturatef(outColor.x + tint_r * alpha * 1.5f);
                float mix_lin_g = saturatef(outColor.y + tint_g * alpha * 1.5f);
                float mix_lin_b = saturatef(outColor.z + tint_b * alpha * 1.5f);
                outColor = make_float3(
                    mix_lin_r,
                    mix_lin_g,
                    mix_lin_b
                );
            }
        }
    }

    if (p_guide != 0 || p_curve != 0) {
        // Draw overlays in active image area only (ignore letterbox bars).
        int4 bar2 = get_black_bar_thickness(p_Width, p_Height, p_TexR, p_TexG, p_TexB, k_black_threshold, p_input_space);
        if (k_assume_centered) {
            int min_lr2 = (int)_fminf((float)bar2.x, (float)bar2.z);
            int min_tb2 = (int)_fminf((float)bar2.y, (float)bar2.w);
            bar2 = make_int4(min_lr2, min_tb2, min_lr2, min_tb2);
        }

        int eff_w2 = p_Width - bar2.x - bar2.z;
        int eff_h2 = p_Height - bar2.y - bar2.w;
        int x_in2 = p_X - bar2.x;
        int y_in2 = p_Y - bar2.y;
        if (eff_w2 > 1 && eff_h2 > 1 && x_in2 >= 0 && y_in2 >= 0 && x_in2 < eff_w2 && y_in2 < eff_h2) {
            float x = (float)x_in2 / (float)(eff_w2 - 1);
            float y = (float)y_in2 / (float)(eff_h2 - 1);
            float guide_top = 1.0f - (k_guide_strip_height + k_guide_ramp_height);

            if (p_curve != 0) {
                float y_ref = 1.0f - x;
                if (_fabs(y - y_ref) < k_curve_thickness) {
                    int dash = ((int)(x * 60.0f)) & 1;
                    if (dash == 0) {
                        // Dashed identity reference: intentionally darker + more transparent than main curve.
                        float w_ref = linear_to_di(0.65f);
                        outColor = make_float3(
                            outColor.x + (w_ref - outColor.x) * k_curve_ref_alpha,
                            outColor.y + (w_ref - outColor.y) * k_curve_ref_alpha,
                            outColor.z + (w_ref - outColor.z) * k_curve_ref_alpha
                        );
                    }
                }
                float o_di = localized_s_curve(x, amount_scaled_overlay, center_overlay, width_overlay, p_symmetry_bias, shoulder_t);
                if (p_preserve_mid_gray != 0) {
                    o_di = apply_preserve_to_di(o_di, g_mid_overlay);
                }
                float y_curve = 1.0f - o_di;
                if (_fabs(y - y_curve) < k_curve_thickness) {
                    // Main response curve: brighter DI-encoded white for quick read.
                    float w = linear_to_di(0.95f);
                    return make_float3(w, w, w);
                }
            }

            if (p_guide != 0 && y >= guide_top && y <= (guide_top + k_guide_strip_height)) {
                int middle = k_guide_steps / 2;
                int step = (int)_fminf((float)k_guide_steps - 1.0f, _fmaxf(0.0f, x * k_guide_steps));
                float v0 = guide_step_value_di(step);
                float v1 = guide_step_value_di(_fminf(step + 1, k_guide_steps - 1));
                float v_1 = guide_step_value_di(_fmaxf(step - 1, 0));
                float o0 = localized_s_curve(v0, amount_scaled_overlay, center_overlay, width_overlay, p_symmetry_bias, shoulder_t);
                float o1 = localized_s_curve(v1, amount_scaled_overlay, center_overlay, width_overlay, p_symmetry_bias, shoulder_t);
                float o_1 = localized_s_curve(v_1, amount_scaled_overlay, center_overlay, width_overlay, p_symmetry_bias, shoulder_t);
                if (p_preserve_mid_gray != 0) {
                    o0 = apply_preserve_to_di(o0, g_mid_overlay);
                    o1 = apply_preserve_to_di(o1, g_mid_overlay);
                    o_1 = apply_preserve_to_di(o_1, g_mid_overlay);
                }

                int interior = (step > 0) && (step < (k_guide_steps - 1));
                float step_stops = (float)(step - middle);
                float shadow_t = saturatef((-step_stops) / 7.0f);
                shadow_t = smootherstep01(shadow_t);
                float deep_shadow_scale = k_guide_shadow_sensitivity * k_guide_shadow_sensitivity;
                float shadow_scale = 1.0f + (deep_shadow_scale - 1.0f) * shadow_t;
                float close_thresh = k_guide_close_thresh * shadow_scale;
                float flat_thresh = k_guide_flat_thresh * shadow_scale;

                int too_close = interior && ((_fabs(o1 - o0) < close_thresh) || (_fabs(o0 - o_1) < close_thresh));
                float slope_avg = 0.5f * (_fabs(o0 - o_1) + _fabs(o1 - o0));
                int deep_shadow = step_stops <= -8.0f;
                int flat_warn = interior && !deep_shadow && (slope_avg < flat_thresh);
                float disp = di_code_to_space(o0, p_input_space);
                if (too_close) {
                    return make_float3(
                        linear_to_code_space(1.0f, p_input_space),
                        linear_to_code_space(0.15f, p_input_space),
                        linear_to_code_space(0.15f, p_input_space)
                    );
                }
                if (flat_warn) {
                    return make_float3(
                        linear_to_code_space(1.0f, p_input_space),
                        linear_to_code_space(0.95f, p_input_space),
                        linear_to_code_space(0.2f, p_input_space)
                    );
                }
                return make_float3(disp, disp, disp);
            } else if (p_guide != 0 && y >= (guide_top + k_guide_strip_height) && y <= (guide_top + k_guide_strip_height + k_guide_ramp_height)) {
                int middle = k_guide_steps / 2;
                float steps_range = (float)(k_guide_steps - 1);
                float stops = (x * steps_range) - (float)middle;
                float lin = k_guide_midgray_lin * _exp2f(stops);
                float v = linear_to_di(lin);
                float o = localized_s_curve(v, amount_scaled_overlay, center_overlay, width_overlay, p_symmetry_bias, shoulder_t);
                if (p_preserve_mid_gray != 0) {
                    o = apply_preserve_to_di(o, g_mid_overlay);
                }
                float disp = di_code_to_space(o, p_input_space);
                return make_float3(disp, disp, disp);
            }
        }
    }

    return outColor;
}
