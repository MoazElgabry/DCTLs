//Flimic Contrast
// Created by Moaz Elgabry on 11 May 2023
//


//functions for Transfer function conversion
 __DEVICE__ float3 LinToLogC3 (float3 in) {
    float3 out;

    float cut = 0.010591;
    float a = 5.555556;
    float b = 0.052272;
    float c = 0.247190;
    float d = 0.385537;
    float e = 5.367655;
    float f = 0.092809;

    out.x = (in.x > cut) ? c * log10(a * in.x + b) + d: e * in.x + f;
    out.y = (in.y > cut) ? c * log10(a * in.y + b) + d: e * in.y + f;
    out.z = (in.z > cut) ? c * log10(a * in.z + b) + d: e * in.z + f;

    return out;
    }
 
 __DEVICE__ float3 LogC3ToLin (float3 in) {
    float3 out;

    float cut = 0.010591;
    float a = 5.555556;
    float b = 0.052272;
    float c = 0.247190;
    float d = 0.385537;
    float e = 5.367655;
    float f = 0.092809;

    out.x = (in.x > e * cut + f) ? (_powf(10, (in.x - d) / c) - b) / a : (in.x - f) / e;
    out.y = (in.y > e * cut + f) ? (_powf(10, (in.y - d) / c) - b) / a : (in.y - f) / e;
    out.z = (in.z > e * cut + f) ? (_powf(10, (in.z - d) / c) - b) / a : (in.z - f) / e;

    return out;
    }//0
 
 __DEVICE__ float3 LinToDI (float3 in) {
    float3 out;

    float a = 0.0075;
    float b = 7.0;
    float c = 0.07329248;
    float m = 10.44426855;
    float lin_cut = 0.00262409;

    out.x = in.x > lin_cut ? (_log2f(in.x + a) + b) * c : out.x = in.x * m;
    out.y = in.y > lin_cut ? (_log2f(in.y + a) + b) * c : out.y = in.y * m;
    out.z = in.z > lin_cut ? (_log2f(in.z + a) + b) * c : out.z = in.z * m;

    return out;
    }
 
 __DEVICE__ float3 DItoLin (float3 in) {
    float3 out;

    float a = 0.0075;
    float b = 7.0;
    float c = 0.07329248;
    float m = 10.44426855;
    float log_cut = 0.02740668;

    out.x = in.x > log_cut ? _powf(2.f, (in.x / c) - b) - a : in.x / m;
    out.y = in.y > log_cut ? _powf(2.f, (in.y / c) - b) - a : in.y / m;
    out.z = in.z > log_cut ? _powf(2.f, (in.z / c) - b) - a : in.z / m;

    return out;
    }//2
 
 __DEVICE__ float3 LinToACEScct (float3 in) {
    float3 out;

    float a = 10.5402377416545;
    float b = 0.0729055341958355;
    float c = 9.72;
    float d = 17.52;
    float e = 0.0078125;

    out.x = in.x <= e ? a * in.x + b : (_log2f(in.x) + c) / d;
    out.y = in.y <= e ? a * in.y + b : (_log2f(in.y) + c) / d;
    out.z = in.z <= e ? a * in.z + b : (_log2f(in.z) + c) / d;

    return out;
    }
 
 __DEVICE__ float3 ACEScctToLin (float3 in) {
    float3 out;

    float a = 10.5402377416545;
    float b = 0.0729055341958355;
    float c = 9.72;
    float d = 17.52;
    float e = _log2f(65504);
    float lin_cut = 0.155251141552511;

    out.x = in.x <= lin_cut ? (in.x - b) / a : in.x < (e + c) / d ? _powf(2, in.x*d-c) : 65504;
    out.y = in.y <= lin_cut ? (in.y - b) / a : in.y < (e + c) / d ? _powf(2, in.y*d-c) : 65504;
    out.z = in.z <= lin_cut ? (in.z - b) / a : in.z < (e + c) / d ? _powf(2, in.z*d-c) : 65504;

    return out;
    }//3
 
 __DEVICE__ float3 LinToLogC4 (float3 in) {
    float3 out;

    float a = (_powf(2.0, 18.0) - 16.0) / 117.45;
    float b = (1023.0 - 95.0) / 1023.0;
    float c = 95.0 / 1023.0;
    float s = (7 * _logf(2) * _powf(2.0, 7 - 14 * c / b)) / (a * b);
    float t = (_powf(2.0, 14.0 * (-c / b) + 6.0) - 64.0) / a;

    out.x = in.x < t ? (in.x - t) / s : (_log2f( a * in.x + 64.0) - 6.0) / 14.0 * b + c;
    out.y = in.y < t ? (in.y - t) / s : (_log2f( a * in.y + 64.0) - 6.0) / 14.0 * b + c;
    out.z = in.z < t ? (in.z - t) / s : (_log2f( a * in.z + 64.0) - 6.0) / 14.0 * b + c;

    return out;
    }
 
 __DEVICE__ float3 LogC4ToLin (float3 in) {
    float3 out;

    float a = (_powf(2.0, 18.0) - 16.0) / 117.45;
    float b = (1023.0 - 95.0) / 1023.0;
    float c = 95.0 / 1023.0;
    float s = (7 * _logf(2) * _powf(2.0, 7 - 14 * c / b)) / (a * b);
    float t = (_powf(2.0, 14.0 * (-c / b) + 6.0) - 64.0) / a;

    out.x = in.x < 0.0 ? in.x * s + t : (_powf(2.0, 14.0 * (in.x - c) / b + 6.0) - 64.0) / a;
    out.y = in.y < 0.0 ? in.y * s + t : (_powf(2.0, 14.0 * (in.y - c) / b + 6.0) - 64.0) / a;
    out.z = in.z < 0.0 ? in.z * s + t : (_powf(2.0, 14.0 * (in.z - c) / b + 6.0) - 64.0) / a;

    return out;
    }//1
 
 __DEVICE__ float3 LinToDLog (float3 in) {
    float3 out;

    out.x = in.x <= 0.0078 ? 6.025 * in.x + 0.0929 : (_log10f(in.x * 0.9892 + 0.0108)) * 0.256663 + 0.584555;
    out.y = in.y <= 0.0078 ? 6.025 * in.y + 0.0929 : (_log10f(in.y * 0.9892 + 0.0108)) * 0.256663 + 0.584555;
    out.z = in.z <= 0.0078 ? 6.025 * in.z + 0.0929 : (_log10f(in.z * 0.9892 + 0.0108)) * 0.256663 + 0.584555;

    return out;
    }
 
 __DEVICE__ float3 DLogToLin (float3 in) {
    float3 out;

    out.x = in.x <= 0.14 ? (in.x - 0.0929) / 6.025 : (_powf(10, 3.89616 * in.x - 2.27752) - 0.0108) / 0.9892;
    out.y = in.y <= 0.14 ? (in.y - 0.0929) / 6.025 : (_powf(10, 3.89616 * in.y - 2.27752) - 0.0108) / 0.9892;
    out.z = in.z <= 0.14 ? (in.z - 0.0929) / 6.025 : (_powf(10, 3.89616 * in.z - 2.27752) - 0.0108) / 0.9892;

    return out;
    }
 
 __DEVICE__ float3 LinToFLog (float3 in) {
    float3 out;

    float a = 0.555556;
    float b = 0.009468;
    float c = 0.344676;
    float d = 0.790453;
    float e = 8.735631;
    float f = 0.092864;
    float cut = 0.00089;

    out.x = in.x >= cut ? c * _log10f(a * in.x + b) + d : e * in.x + f;
    out.y = in.y >= cut ? c * _log10f(a * in.y + b) + d : e * in.y + f;
    out.z = in.z >= cut ? c * _log10f(a * in.z + b) + d : e * in.z + f;

    return out;
    }
 
 __DEVICE__ float3 FLogToLin (float3 in) {
    float3 out;

    float a = 0.555556;
    float b = 0.009468;
    float c = 0.344676;
    float d = 0.790453;
    float e = 8.735631;
    float f = 0.092864;
    float cut = 0.100537775223865;

    out.x = in.x >= cut ? _powf(10, ((in.x - d) / c)) / a - b / a : (in.x - f) / e;
    out.y = in.y >= cut ? _powf(10, ((in.y - d) / c)) / a - b / a : (in.y - f) / e;
    out.z = in.z >= cut ? _powf(10, ((in.z - d) / c)) / a - b / a : (in.z - f) / e;

    return out;
    }
 
 __DEVICE__ float3 LinToFLog2 (float3 in) {
    float3 out;

    float a = 5.555556;
    float b = 0.064829;
    float c = 0.245281;
    float d = 0.384316;
    float e = 8.799461;
    float f = 0.092864;
    float cut = 0.000889;

    out.x = in.x >= cut ? c * _log10f(a * in.x + b) + d : e * in.x + f;
    out.y = in.y >= cut ? c * _log10f(a * in.y + b) + d : e * in.y + f;
    out.z = in.z >= cut ? c * _log10f(a * in.z + b) + d : e * in.z + f;

    return out;
    }
 
 __DEVICE__ float3 FLog2ToLin (float3 in) {
    float3 out;

    float a = 5.555556;
    float b = 0.064829;
    float c = 0.245281;
    float d = 0.384316;
    float e = 8.799461;
    float f = 0.092864;
    float cut = 0.100686685370811;

    out.x = in.x >= cut ? _powf(10, ((in.x - d) / c)) / a - b / a : (in.x - f) / e;
    out.y = in.y >= cut ? _powf(10, ((in.y - d) / c)) / a - b / a : (in.y - f) / e;
    out.z = in.z >= cut ? _powf(10, ((in.z - d) / c)) / a - b / a : (in.z - f) / e;

    return out;
    }
 
 __DEVICE__ float3 LinToVLog (float3 in) {
    float3 out;

    float cut = 0.01;
    float b = 0.00873;
    float c = 0.241514;
    float d = 0.598206;

    out.x = in.x < cut ? 5.6 * in.x + 0.125 : c * _log10f(in.x + b) + d;
    out.y = in.y < cut ? 5.6 * in.y + 0.125 : c * _log10f(in.y + b) + d;
    out.z = in.z < cut ? 5.6 * in.z + 0.125 : c * _log10f(in.z + b) + d;

    return out;
    }
 
 __DEVICE__ float3 VLogToLin (float3 in) {
    float3 out;

    float cut = 0.181;
    float b = 0.00873;
    float c = 0.241514;
    float d = 0.598206;

    out.x = in.x < cut ? (in.x - 0.125) / 5.6 : _powf(10.0, ((in.x - d) / c)) - b;
    out.y = in.y < cut ? (in.y - 0.125) / 5.6 : _powf(10.0, ((in.y - d) / c)) - b;
    out.z = in.z < cut ? (in.z - 0.125) / 5.6 : _powf(10.0, ((in.z - d) / c)) - b;

    return out;
    }
 
 __DEVICE__ float3 LinToLog3G10 (float3 in) {
    float3 out;

    float a = 0.224282f;
    float b = 155.975327f;
    float c = 0.01f;
    float g = 15.1927f;

    in.x += c;
    in.y += c;
    in.z += c;

    out.x = in.x < 0.0f ? in.x * g : a * _log10f((in.x * b) + 1.0f);
    out.y = in.y < 0.0f ? in.y * g : a * _log10f((in.y * b) + 1.0f);
    out.z = in.z < 0.0f ? in.z * g : a * _log10f((in.z * b) + 1.0f);

    return out;
    }
 
 __DEVICE__ float3 Log3G10toLin (float3 in) {
    float3 out;

    float a = 0.224282f;
    float b = 155.975327f;
    float c = 0.01f;
    float g = 15.1927f;

    out.x = in.x < 0.0f ? (in.x / g) - c : (_powf(10.0f, in.x / a) - 1.0f) / b;
    out.y = in.y < 0.0f ? (in.y / g) - c : (_powf(10.0f, in.y / a) - 1.0f) / b;
    out.z = in.z < 0.0f ? (in.z / g) - c : (_powf(10.0f, in.z / a) - 1.0f) / b;

    out.x -= c;
    out.y -= c;
    out.z -= c;

    return out;
    }
 
 __DEVICE__ float3 LinToSLog3 (float3 in) {
    float3 out;

    out.x = in.x >= 0.01125000 ? (420.0 + _log10f((in.x + 0.01) / (0.18 + 0.01)) * 261.5) / 1023.0 : (in.x * (171.2102946929 - 95.0)/0.01125000 + 95.0) / 1023.0;
    out.y = in.y >= 0.01125000 ? (420.0 + _log10f((in.y + 0.01) / (0.18 + 0.01)) * 261.5) / 1023.0 : (in.y * (171.2102946929 - 95.0)/0.01125000 + 95.0) / 1023.0;
    out.z = in.z >= 0.01125000 ? (420.0 + _log10f((in.z + 0.01) / (0.18 + 0.01)) * 261.5) / 1023.0 : (in.z * (171.2102946929 - 95.0)/0.01125000 + 95.0) / 1023.0;    

    return out;
    }
 
 __DEVICE__ float3 SLog3ToLin (float3 in) {
    float3 out;

    out.x = in.x >= 171.2102946929 / 1023.0 ? (_powf(10.0, ((in.x * 1023.0 - 420.0) / 261.5))) * (0.18 + 0.01) - 0.01 : (in.x * 1023.0 - 95.0) * 0.01125000 / (171.2102946929 - 95.0);
    out.y = in.y >= 171.2102946929 / 1023.0 ? (_powf(10.0, ((in.y * 1023.0 - 420.0) / 261.5))) * (0.18 + 0.01) - 0.01 : (in.y * 1023.0 - 95.0) * 0.01125000 / (171.2102946929 - 95.0);
    out.z = in.z >= 171.2102946929 / 1023.0 ? (_powf(10.0, ((in.z * 1023.0 - 420.0) / 261.5))) * (0.18 + 0.01) - 0.01 : (in.z * 1023.0 - 95.0) * 0.01125000 / (171.2102946929 - 95.0);

    return out;
    }
 
 __DEVICE__ float3 LinToBMDFilmGen5(float3 in) {
    float3 out;

    float a = 8.283605932402494f;
    float b = 0.09246575342465753f;
    float c = 0.5300133392291939f;
    float d = 0.08692876065491224f;
    float e = 0.005494072432257808f;
    float cut = 0.005f;

    out.x = in.x < cut ? a * in.x + b : d * _logf(in.x + e) + c;
    out.y = in.y < cut ? a * in.y + b : d * _logf(in.y + e) + c;
    out.z = in.z < cut ? a * in.z + b : d * _logf(in.z + e) + c;

    return out;
    }
 
 __DEVICE__ float3 BMDFilmGen5ToLin(float3 in) {
    float3 out;

    float a = 8.283605932402494f;
    float b = 0.09246575342465753f;
    float c = 0.5300133392291939f;
    float d = 0.08692876065491224f;
    float e = 0.005494072432257808f;
    float cut = a * 0.005f + b;

    out.x = in.x < (a * 0.005f + b) ? (in.x - b) / a : _expf((in.x - c) / d) - e;
    out.y = in.y < (a * 0.005f + b) ? (in.y - b) / a : _expf((in.y - c) / d) - e;
    out.z = in.z < (a * 0.005f + b) ? (in.z - b) / a : _expf((in.z - c) / d) - e;

    return out;
    }
 
 __DEVICE__ float3 LinToCLog (float3 in) {
    float3 out;

    out.x = in.x < 0 ? -.529136 * _log10f(1 - 10.1596 * in.x) + 0.0730597 : .529136 * _log10f(10.1596 * in.x + 1) + 0.0730597;
    out.y = in.y < 0 ? -.529136 * _log10f(1 - 10.1596 * in.y) + 0.0730597 : .529136 * _log10f(10.1596 * in.y + 1) + 0.0730597;
    out.z = in.z < 0 ? -.529136 * _log10f(1 - 10.1596 * in.z) + 0.0730597 : .529136 * _log10f(10.1596 * in.z + 1) + 0.0730597;

    return out;
    }
 
 __DEVICE__ float3 CLogToLin (float3 in) {
    float3 out;

    out.x = in.x < 0.0730597 ? -(_powf(10, (0.0730597 - in.x) / .529136) - 1) / 10.1596 : (_powf(10, (in.x - 0.0730597) / .529136) - 1) / 10.1596;
    out.y = in.y < 0.0730597 ? -(_powf(10, (0.0730597 - in.y) / .529136) - 1) / 10.1596 : (_powf(10, (in.y - 0.0730597) / .529136) - 1) / 10.1596;
    out.z = in.z < 0.0730597 ? -(_powf(10, (0.0730597 - in.z) / .529136) - 1) / 10.1596 : (_powf(10, (in.z - 0.0730597) / .529136) - 1) / 10.1596;

    return out;
    }
 
 __DEVICE__ float3 LinToCLog2 (float3 in) {
    float3 out;

    out.x = in.x < 0 ? -0.24136077 * _log10f(1 - 87.099375 * in.x) + 0.092864125 : 0.24136077 * _log10f(87.099375 * in.x + 1) + 0.092864125;
    out.y = in.y < 0 ? -0.24136077 * _log10f(1 - 87.099375 * in.y) + 0.092864125 : 0.24136077 * _log10f(87.099375 * in.y + 1) + 0.092864125;
    out.z = in.z < 0 ? -0.24136077 * _log10f(1 - 87.099375 * in.z) + 0.092864125 : 0.24136077 * _log10f(87.099375 * in.z + 1) + 0.092864125;

    return out;
    }
 
 __DEVICE__ float3 CLog2ToLin (float3 in) {
    float3 out;

    out.x = in.x < 0.092864125 ? -(_powf(10, (0.092864125 - in.x) / 0.24136077) - 1) / 87.099375 : (_powf(10, (in.x - 0.092864125) / 0.24136077) - 1) / 87.099375;
    out.y = in.y < 0.092864125 ? -(_powf(10, (0.092864125 - in.y) / 0.24136077) - 1) / 87.099375 : (_powf(10, (in.y - 0.092864125) / 0.24136077) - 1) / 87.099375;
    out.z = in.z < 0.092864125 ? -(_powf(10, (0.092864125 - in.z) / 0.24136077) - 1) / 87.099375 : (_powf(10, (in.z - 0.092864125) / 0.24136077) - 1) / 87.099375;

    return out;
    }
 
 __DEVICE__ float3 LinToCLog3 (float3 in) {
    float3 out;

    out.x = in.x < -0.014 ? -0.36726845 * _log10f(1 - 14.98325 * in.x) + 0.12783901 : in.x <= 0.014 ? 1.9754798 * in.x + 0.12512219 : 0.36726845 * _log10f(14.98325 * in.x + 1) + 0.12240537;
    out.y = in.y < -0.014 ? -0.36726845 * _log10f(1 - 14.98325 * in.y) + 0.12783901 : in.y <= 0.014 ? 1.9754798 * in.y + 0.12512219 : 0.36726845 * _log10f(14.98325 * in.y + 1) + 0.12240537;
    out.z = in.z < -0.014 ? -0.36726845 * _log10f(1 - 14.98325 * in.z) + 0.12783901 : in.z <= 0.014 ? 1.9754798 * in.z + 0.12512219 : 0.36726845 * _log10f(14.98325 * in.z + 1) + 0.12240537;

    return out;
    }
 
 __DEVICE__ float3 CLog3ToLin (float3 in) {
    float3 out;

    out.x = in.x < 0.097465473 ? -(_powf(10, (0.12783901 - in.x) / 0.36726845) - 1) / 14.98325 : in.x <= 0.15277891 ? (in.x - 0.12512219) / 1.9754798 : (_powf(10, (in.x - 0.12240537) / 0.36726845) - 1) / 14.98325;
    out.y = in.y < 0.097465473 ? -(_powf(10, (0.12783901 - in.y) / 0.36726845) - 1) / 14.98325 : in.y <= 0.15277891 ? (in.y - 0.12512219) / 1.9754798 : (_powf(10, (in.y - 0.12240537) / 0.36726845) - 1) / 14.98325;
    out.z = in.z < 0.097465473 ? -(_powf(10, (0.12783901 - in.z) / 0.36726845) - 1) / 14.98325 : in.z <= 0.15277891 ? (in.z - 0.12512219) / 1.9754798 : (_powf(10, (in.z - 0.12240537) / 0.36726845) - 1) / 14.98325;

    return out;
    }
 
 
 __DEVICE__ float3 GammaCurveToLin (float3 in, float gamma) {
    float3 out;

    out.x = _powf(_fmaxf(in.x, 0.0f), gamma);
    out.y = _powf(_fmaxf(in.y, 0.0f), gamma);
    out.z = _powf(_fmaxf(in.z, 0.0f), gamma);

    return out;
    }  
 
 __DEVICE__ float3 LinToGammaCurve (float3 in, float gamma) {
    float3 out;

    out.x = _powf(_fmaxf(in.x, 0.0f), (1 / gamma));
    out.y = _powf(_fmaxf(in.y, 0.0f), (1 / gamma));
    out.z = _powf(_fmaxf(in.z, 0.0f), (1 / gamma));

    return out;
    }
 
 
//functions that convert between color models

 __DEVICE__ float3 RGB_to_HSV(float3 RGB) {
    float3 HSV;
    float min = _fminf(_fminf(RGB.x, RGB.y), RGB.z);
    float max = _fmaxf(_fmaxf(RGB.x, RGB.y), RGB.z);
    HSV.z = max;
    float delta = max - min;
    if (max != 0.0f) {
    HSV.y = delta / max;
    } else {
    HSV.y = 0.0f;
    HSV.x = 0.0f;
    return HSV;
    }
    if (delta == 0.0f) {
    HSV.x = 0.0f;
    } else if (RGB.x == max) {
    HSV.x = (RGB.y - RGB.z) / delta;
    } else if (RGB.y == max) {
    HSV.x = 2.0f + (RGB.z - RGB.x) / delta;
    } else {
    HSV.x = 4.0f + (RGB.x - RGB.y) / delta;
    }
    HSV.x *= 1.0f / 6.0f;
    if (HSV.x < 0.0f)
    HSV.x += 1.0f;
    return HSV;
    } //Convert to HSV
 
 __DEVICE__ float3 HSV_to_RGB(float3 HSV) {
    float3 RGB;
    if (HSV.y == 0.0f) {
    RGB.x = RGB.y = RGB.z = HSV.z;
    } else {
    HSV.x *= 6.0f;
    int i = floor(HSV.x);
    float f = HSV.x - i;
    i = (i >= 0) ? (i % 6) : (i % 6) + 6;
    float p = HSV.z * (1.0f - HSV.y);
    float q = HSV.z * (1.0f - HSV.y * f);
    float t = HSV.z * (1.0f - HSV.y * (1.0f - f));
    RGB.x = i == 0 ? HSV.z : i == 1 ? q : i == 2 ? p : i == 3 ? p : i == 4 ? t : HSV.z;
    RGB.y = i == 0 ? t : i == 1 ? HSV.z : i == 2 ? HSV.z : i == 3 ? q : i == 4 ? p : p;
    RGB.z = i == 0 ? p : i == 1 ? p : i == 2 ? t : i == 3 ? HSV.z : i == 4 ? HSV.z : q;
    }
    return RGB;
    } //Convert from HSV to RGB
 

//A function to mix saturation channel of HSV between image state before and after applying contrast
 
 __DEVICE__ float3 HSV_sat_mixed (float3 in_1, float3 in_2, float mix_sat, float contrast_mix) {
    //float3 out = in;
    float3 HSV_1 = in_1;
    float3 HSV_2 = in_2;


    HSV_1 = RGB_to_HSV(in_1);//clean
    HSV_2 = RGB_to_HSV(in_2);//mixed contrast
        if ( mix_sat < 1.f && contrast_mix < 1.f) {
  
        //in_2 = RGB_to_HSV(in_2);
        //HSV_2.y = in_2.y * (mix_sat + 1.f);
        //HSV_2.y = _mix(HSV_1.y, HSV_3.y, mix_sat);
        HSV_2.y = HSV_2.y * (mix_sat* .4f +.6f);
       // HSV_2.z = HSV_2.z;    
     }
     else {
    float new_sat = _mix(HSV_1.y, HSV_2.y, mix_sat);
    float new_hue = _mix(HSV_1.x, HSV_2.x, mix_sat);
    HSV_2.x = new_hue;
    HSV_2.y = new_sat;

        }



    return HSV_to_RGB(HSV_2);
    
    }
 


//functions to apply transfer function conversions
 
 __DEVICE__ float3 GammaToLin (float3 in, int gamma) {

    if (gamma ==  0) return LogC3ToLin(in);
    if (gamma ==  1) return LogC4ToLin(in);
    if (gamma ==  2) return DItoLin(in);
    if (gamma ==  3) return ACEScctToLin (in);
    if (gamma ==  4) return Log3G10toLin(in);
    if (gamma ==  5) return SLog3ToLin(in);
    if (gamma ==  6) return BMDFilmGen5ToLin(in);
    if (gamma ==  7) return CLog3ToLin(in);
    if (gamma ==  8) return DLogToLin(in);
    if (gamma ==  9) return FLogToLin(in);
    if (gamma == 10) return FLog2ToLin(in);
    if (gamma == 11) return VLogToLin(in);
    if (gamma == 12) return GammaCurveToLin(in, 2.2);
    if (gamma == 13) return GammaCurveToLin(in, 2.4);
    if (gamma == 14) return GammaCurveToLin(in, 2.6);
    if (gamma == 15) return in; // Lin


    return make_float3(0, 0, 1); // Blue on error
    }
 
 __DEVICE__ float3 LinToGamma (float3 in, int gamma) {
    if (gamma ==  0) return LinToLogC3(in);
    if (gamma ==  1) return LinToLogC4(in);
    if (gamma ==  2) return LinToDI(in);
    if (gamma ==  3) return LinToACEScct(in);
    if (gamma ==  4) return LinToLog3G10(in);
    if (gamma ==  5) return LinToSLog3(in);
    if (gamma ==  6) return LinToBMDFilmGen5(in);
    if (gamma ==  7) return LinToCLog3(in);
    if (gamma ==  8) return LinToDLog(in);
    if (gamma ==  9) return LinToFLog(in);
    if (gamma == 10) return LinToFLog2(in);
    if (gamma == 11) return LinToVLog(in);
    if (gamma == 12) return LinToGammaCurve(in, 2.2);
    if (gamma == 13) return LinToGammaCurve(in, 2.4);
    if (gamma == 14) return LinToGammaCurve(in, 2.6);
    if (gamma == 15) return in; // Lin


    
    return make_float3(0, 1, 0); // Green on error
    }
 
 __DEVICE__ float set_pivot (float pivot, int gamma) {
    float p_transfer_f = gamma;
    float midgray;
    const float logc3_gray = 0.39101f;
    const float logc4_gray = 0.2784f;
    const float DI_gray = 0.33604f;
    const float ACEScct_gray = 0.41359f;
    const float log3g10_gray = 0.3333f;
    const float slog3_gray = 0.41056f;
    const float bmd_f5_gray = 0.38356f;
    const float clog3_gray = 0.34339f;
    const float dlog_gray = 0.39876f;
    const float fLog_gray = 0.45932f;
    const float fLog2_gray = 0.39101f;
    const float vlog_gray = 0.42331f;
    const float g22_gray = 0.45866f;
    const float g24_gray = 0.48944f;
    const float g25_gray = 0.50363f;
    const float g26_gray = 0.51709f;
    const float linear_gray = 0.18f;

    if (p_transfer_f ==  0) { midgray = logc3_gray;}
    if (p_transfer_f ==  1) { midgray = logc4_gray; }
    if (p_transfer_f ==  2) { midgray = DI_gray;}
    if (p_transfer_f ==  3) { midgray = ACEScct_gray;}
    if (p_transfer_f ==  4) { midgray = log3g10_gray;}
    if (p_transfer_f ==  5) { midgray = slog3_gray;}
    if (p_transfer_f ==  6) { midgray = bmd_f5_gray;}
    if (p_transfer_f ==  7) { midgray = clog3_gray;}
    if (p_transfer_f ==  8) { midgray = dlog_gray;}
    if (p_transfer_f ==  9) { midgray = fLog_gray;}
    if (p_transfer_f == 10) { midgray = fLog2_gray;}
    if (p_transfer_f == 11) { midgray = vlog_gray;}
    if (p_transfer_f == 12) { midgray = g22_gray;}
    if (p_transfer_f == 13) { midgray = g24_gray;}
    if (p_transfer_f == 14) { midgray = g26_gray;}
    if (p_transfer_f == 15) { midgray = linear_gray;}


    pivot = _clampf(( pivot + midgray), 0.02f, 1.0f); //clamping to 0 caused artifacts
    
    return pivot;
    }



//functions for the main functionality of contrast and split toning

 __DEVICE__ float3 apply_linear_contrastf3 (float3 in, float contrast, float pivot) {
    
    float3 out = in;
    //offsetting the user slider to set stratingpoints at zero
    contrast = contrast+1.f;
    //limit user input to zero
    if (contrast <0.f) {contrast = _fmaxf(contrast, 0.0f);}

    
    out.x = (in.x - pivot) * contrast + pivot;
    out.y = (in.y - pivot) * contrast + pivot;
    out.z = (in.z - pivot) * contrast + pivot;
    

    return out;
    }
 
 __DEVICE__ float3 apply_rolling_contrastf3 (float3 in, float contrast, float pivot) {
    
    float3 out = in;
    //offsett the user slider to set the starting point at zero instead of 1
    contrast = contrast + 1.f;

    // apply rolling contrast
    if (in.x <= pivot) {out.x = _copysignf((_powf(_fabs((in.x / pivot)) , contrast) * pivot),(in.x / pivot));} 
        if (in.x > pivot) {
            in.x = 1 - in.x; 
            pivot = 1 - pivot;
            out.x = _copysignf((_powf(_fabs((in.x / pivot)) , contrast) * pivot),(in.x / pivot));
            out.x = 1 - out.x;
            pivot = 1 - pivot;
        }

    if (in.y <= pivot ) {out.y = _copysignf((_powf(_fabs((in.y / pivot)) , contrast) * pivot),(in.y / pivot));}
        if (in.y > pivot) {
            in.y = 1 - in.y; 
            pivot = 1 - pivot;
            out.y = _copysignf((_powf(_fabs((in.y / pivot)) , contrast) * pivot),(in.y / pivot));
            out.y = 1 - out.y;
            pivot = 1 - pivot;
        }

    if (in.z <= pivot) {out.z = _copysignf((_powf(_fabs((in.z / pivot)) , contrast) * pivot),(in.z / pivot));}
    
        if (in.z > pivot) {
            in.z = 1 - in.z; 
            pivot = 1 - pivot;
            out.z = _copysignf((_powf(_fabs((in.z / pivot)) , contrast) * pivot),(in.z / pivot));
            out.z = 1 - out.z;
        }
    
    return out;

    }
 
 __DEVICE__ float3 apply_white_point (float3 in, float white_point, float pivot, float shoulder_strength) {

float3 out = in; 
float scale_factor;

if (in.x > pivot) {
    scale_factor = (1.0f - pivot) / _powf(_powf((white_point - pivot) / (1.0f - pivot), -1.0f*shoulder_strength) - 1.0f, 1.0f/shoulder_strength);
    
    out.x = pivot + scale_factor *((in.x - pivot) / scale_factor) / (_powf(1.0f + _powf((in.x - pivot) / scale_factor, shoulder_strength), 1.0f / shoulder_strength));

    }

        else {
           
        out.x = in.x;
        
        }

if (in.y > pivot) {
    scale_factor = (1.0f - pivot) / _powf(_powf((white_point - pivot) / (1.0f - pivot), -1.0f*shoulder_strength) - 1.0f, 1.0f/shoulder_strength);
    
    out.y = pivot + scale_factor *((in.y - pivot) / scale_factor) / (_powf(1.0f + _powf((in.y - pivot) / scale_factor, shoulder_strength), 1.0f / shoulder_strength));

    }

        else {
           
        out.y = in.y;
        
        }

if (in.z > pivot) {
    scale_factor = (1.0f - pivot) / _powf(_powf((white_point - pivot) / (1.0f - pivot), -1.0f*shoulder_strength) - 1.0f, 1.0f/shoulder_strength);
    
    out.z = pivot + scale_factor *((in.z - pivot) / scale_factor) / (_powf(1.0f + _powf((in.z - pivot) / scale_factor, shoulder_strength), 1.0f / shoulder_strength));

    }

        else {
           
        out.z = in.z;
        
        }

    return out;

    }
 
 __DEVICE__ float3 apply_black_point (float3 in, float black_point, float pivot, float toe_str) {

float3 out = in; 

in.x = 1.0f - in.x;
in.y = 1.0f - in.y ;
in.z = 1.0f - in.z ;

float scale_factor;

    if (in.x > pivot) {
    scale_factor = (1.0f - pivot) / _powf(_powf((black_point - pivot) / (1.0f - pivot), -1.0f*toe_str) - 1.0f, 1.0f/toe_str);
    
    out.x = pivot + scale_factor *((in.x - pivot) / scale_factor) / (_powf(1.0f + _powf((in.x - pivot) / scale_factor, toe_str), 1.0f / toe_str));
    }
    
            else {
           
        out.x = in.x;
        
        }
    
    if (in.y > pivot) {

    scale_factor = (1.0f - pivot) / _powf(_powf((black_point - pivot) / (1.0f - pivot), -1.0f*toe_str) - 1.0f, 1.0f/toe_str);
    
    out.y = pivot + scale_factor *((in.y - pivot) / scale_factor) / (_powf(1.0f + _powf((in.y - pivot) / scale_factor, toe_str), 1.0f / toe_str));

    }
    
            else {
           
        out.y = in.y;
        
        }
    
    if (in.z > pivot) {
    scale_factor = (1.0f - pivot) / _powf(_powf((black_point - pivot) / (1.0f - pivot), -1.0f*toe_str) - 1.0f, 1.0f/toe_str);
    
    out.z = pivot + scale_factor *((in.z - pivot) / scale_factor) / (_powf(1.0f + _powf((in.z - pivot) / scale_factor, toe_str), 1.0f / toe_str));

    }
    
            else {
           
        out.z = in.z;
        
        }

 out.x = 1 - out.x;
 out.y = 1 - out.y;
 out.z = 1 - out.z;

return out;

    }





DEFINE_UI_PARAMS(contrast, Contrast 🌓, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 2, 0.001)
DEFINE_UI_PARAMS(pivot, Relative Pivot 📌, DCTLUI_SLIDER_FLOAT, 0.0, -1, 1, 0.001)
DEFINE_UI_PARAMS(P_exposure,  Exposure 🌞, DCTLUI_SLIDER_FLOAT, 0.0f, -0.955f, 4.0f, 0.001f)
DEFINE_UI_PARAMS(p_mix_sat, Saturation mix:🖍️ , DCTLUI_SLIDER_FLOAT, 0.5f, 0.0f, 1.0f, 0.01f)

DEFINE_UI_PARAMS(p_white_point, ⚪White Point ⚪ :, DCTLUI_SLIDER_FLOAT, 0.999, 0.0, 0.999, 0.0001)
DEFINE_UI_PARAMS(p_w_p_pivot, ├ Shoulder  ╭, DCTLUI_SLIDER_FLOAT, 0.6, 0.2, 1, 0.1)
DEFINE_UI_PARAMS(p_shoulder_str, └ Fall off ╭   , DCTLUI_SLIDER_FLOAT, 4, 0.3, 10.0, 0.001)

DEFINE_UI_PARAMS(p_black_point, ⚫Black Point ⚫ :, DCTLUI_SLIDER_FLOAT, 0.0001, 0.0001, .25, 0.0001)
DEFINE_UI_PARAMS(p_b_p_pivot, ├ Toe     ⌣  , DCTLUI_SLIDER_FLOAT, 0.37, 0.0, 0.8, 0.001)
DEFINE_UI_PARAMS(p_toe_str, └ Fall off   ⌣   , DCTLUI_SLIDER_FLOAT, 5.0, 0.135, 10.0, 0.001)


DEFINE_UI_PARAMS(p_mix_contrast, Linear / S curve: , DCTLUI_SLIDER_FLOAT, 1.0f, 0.0f, 1.0f, 0.1f)


DEFINE_UI_PARAMS(bypass, 🚫 Bypass, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(opt_showcurve, 📈 Show Curve, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(opt_ramp, 📏 Show Ramp, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(p_transfer_f, Transfer function, DCTLUI_COMBO_BOX, 2, {logc3, logc4, di, aces_cct, log3g10, slog3, bmd_f5, clog3, dlog, fLog, fLog2, vlog, g22, g24, g26, linear}, {ARRI LogC3, ARRI LogC4,  DaVinci Intermediate, ACEScct, RED Log3G10, Sony S-Log3, BMD Film Gen 5, Canon Log 3, DJI D-Log, FujiFilm F-Log, FujiFilm F-Log2, Panasonic V-Log, Gamma 2.2, Gamma 2.4, Gamma 2.6, Linear})




__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B) {

    float3 clean = make_float3(p_R, p_G, p_B);
    float3 in_RGB = make_float3(p_R, p_G, p_B);
    pivot = set_pivot(pivot, p_transfer_f);
    float3 out;


    //create a linear ramp to enable the view graph control
    float width = (float)p_Width;
    float height = (float)p_Height;
    float X = (float)p_X;
    float Y = height - (float)p_Y;
    //Relative X,Y 
    float rY = Y / height;
    float rX = X / width;
    float3 ramp = {rX, rX, rX};

    
    //sanitize black and white points

    p_w_p_pivot = p_w_p_pivot >= .5f ? _fmaxf(_fminf((p_white_point - 0.01f), p_w_p_pivot ), 0.05f) : _fmaxf(_fminf((p_white_point + 0.35f), p_w_p_pivot ), 0.05f);

    p_black_point = 1.0f - p_black_point;
    p_b_p_pivot = _fminf((p_black_point - 0.01f), p_b_p_pivot );
    p_white_point = _fmaxf(p_white_point*.5f + 0.49f,0.67f);
    //p_white_point = _fmaxf(p_white_point , 0.5f);
    p_black_point = _fmaxf(p_black_point , 0.8f);
    

//bypass option that outputs untouched image when activated
    if (bypass ==1 ) {
        //float3 clean = {p_R, p_G, p_B};

     out = clean;
    //Optional show curve functionality
     if (opt_showcurve == 1) {
    
        float overlayR = ramp.x >= (Y - 5.0f) / height && ramp.x <= (Y + 5.0f) / height ? 1.0f : 0.0f;
        float overlayG = ramp.y >= (Y - 5.0f) / height && ramp.y <= (Y + 5.0f) / height ? 1.0f : 0.0f;
        float overlayB = ramp.z >= (Y - 5.0f) / height && ramp.z <= (Y + 5.0f) / height ? 1.0f : 0.0f;
        out.x = overlayR == 0.0f ? out.x : overlayR;
        out.y = overlayG == 0.0f ? out.y : overlayG;
        out.z = overlayB == 0.0f ? out.z : overlayB;
            if (rX < pivot+0.0025f && rX > pivot- 0.0025f) {
                out.x = .8f;
                out.y = .8f;
                out.z = .8f;
            }

                else {
                    if (rX < p_w_p_pivot+0.001f && rX > p_w_p_pivot- 0.001f) {
                    out.x = 0.8f;
                    out.y = 0.1f;
                    out.z = 0.01f;
                        }

                    if (rX < p_b_p_pivot+0.001f && rX > p_b_p_pivot- 0.001f) {
                    out.x = 0.01f;
                    out.y = 0.3f;
                    out.z = 0.7f;
                    }
                }
    }

    //option to overlay a grayscale ramp on the bottom edge of the frame
        if (opt_ramp) {

        if( rY < 0.1f) {out = ramp;}

    
    }

    return out;
    }


              

//apply compression to the white and black points
     in_RGB = apply_white_point(in_RGB, p_white_point, p_w_p_pivot, p_shoulder_str);
     ramp = apply_white_point(ramp, p_white_point, p_w_p_pivot, p_shoulder_str);

     in_RGB = apply_black_point(in_RGB, p_black_point, p_b_p_pivot, p_toe_str);           
     ramp = apply_black_point(ramp, p_black_point, p_b_p_pivot, p_toe_str);


        //apply contrast operations
     float3 lin_contrast = apply_linear_contrastf3 (in_RGB, contrast, pivot);
     float3 ramp_linear = apply_linear_contrastf3 (ramp, contrast, pivot);

     float3 roll_contrast = apply_rolling_contrastf3 (in_RGB, contrast, pivot);
     float3 ramp_rolling = apply_rolling_contrastf3 (ramp, contrast, pivot);

     float3 mix_con = _mix(lin_contrast, roll_contrast, p_mix_contrast);
     float3 mix_ramp = _mix(ramp_linear, ramp_rolling, p_mix_contrast);

 //mix back the original saturation channel in HSV to preserve saturation
     mix_con = HSV_sat_mixed (in_RGB, mix_con, p_mix_sat, p_mix_contrast);


 // exposure slider that works in linear
    P_exposure = P_exposure + 1.0f;
    mix_con = GammaToLin(mix_con, p_transfer_f);
    mix_ramp = GammaToLin(mix_ramp, p_transfer_f);
    
     //if (P_exposure == 1) { return LinToGamma(make_float3 (0.18f, .18f, .18f), p_transfer_f);}
    
 // Apply linear gain
    mix_con = mix_con * P_exposure;
    mix_ramp = mix_ramp * P_exposure;
    
    mix_con = LinToGamma(mix_con, p_transfer_f);
    mix_ramp = LinToGamma(mix_ramp, p_transfer_f);
    out = mix_con;
    ramp = mix_ramp;

    

//Optional show curve functionality
    if (opt_showcurve == 1) {
    
        float overlayR = ramp.x >= (Y - 5.0f) / height && ramp.x <= (Y + 5.0f) / height ? 1.0f : 0.0f;
        float overlayG = ramp.y >= (Y - 5.0f) / height && ramp.y <= (Y + 5.0f) / height ? 1.0f : 0.0f;
        float overlayB = ramp.z >= (Y - 5.0f) / height && ramp.z <= (Y + 5.0f) / height ? 1.0f : 0.0f;
        out.x = overlayR == 0.0f ? out.x : overlayR;
        out.y = overlayG == 0.0f ? out.y : overlayG;
        out.z = overlayB == 0.0f ? out.z : overlayB;
            if (rX < pivot+0.0025f && rX > pivot- 0.0025f) {
                out.x = .8f;
                out.y = .8f;
                out.z = .8f;
            }

                else {
                    if (rX < p_w_p_pivot+0.001f && rX > p_w_p_pivot- 0.001f) {
                    out.x = 0.8f;
                    out.y = 0.1f;
                    out.z = 0.01f;
                        }

                    if (rX < p_b_p_pivot+0.001f && rX > p_b_p_pivot- 0.001f) {
                    out.x = 0.01f;
                    out.y = 0.3f;
                    out.z = 0.7f;
                    }
                }
    }

//option to overlay a grayscale ramp on the bottom edge of the frame
    if (opt_ramp) {

        if( rY < 0.1f) {out = ramp;}

    
    }

    
return out;
    }