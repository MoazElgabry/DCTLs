//Flimic Contrast

__DEVICE__ float3 apply_linear_contrastf3(float3 in, float contrast, float pivot) {
    
    float3 out = in;
    //offsetting the user slider to set stratingpoints at zero
    contrast = contrast+1.f;
    //limit user input to zero
    if (contrast <0.f) {contrast = _fmaxf(contrast, 0.0f);}

    
    out.x = (in.x - pivot) * contrast + pivot;
    out.y = (in.y - pivot) * contrast + pivot;
    out.z = (in.z - pivot) * contrast + pivot;
    

    return out;
    }

__DEVICE__ float3 apply_rolling_contrastf3(float3 in, float contrast, float pivot) {
    
    float3 out = in;
    //offsett the user slider to set the starting point at zero instead of 1
    contrast = contrast + 1.f;

    // apply rolling contrast
    if (in.x <= pivot) {out.x = _copysignf((_powf(_fabs((in.x / pivot)) , contrast) * pivot),(in.x / pivot));} 
        if (in.x > pivot) {
            in.x = 1 - in.x; 
            pivot = 1 - pivot;
            out.x = _copysignf((_powf(_fabs((in.x / pivot)) , contrast) * pivot),(in.x / pivot));
            out.x = 1 - out.x;
            pivot = 1 - pivot;
        }

    if (in.y <= pivot ) {out.y = _copysignf((_powf(_fabs((in.y / pivot)) , contrast) * pivot),(in.y / pivot));}
        if (in.y > pivot) {
            in.y = 1 - in.y; 
            pivot = 1 - pivot;
            out.y = _copysignf((_powf(_fabs((in.y / pivot)) , contrast) * pivot),(in.y / pivot));
            out.y = 1 - out.y;
            pivot = 1 - pivot;
        }

    if (in.z <= pivot) {out.z = _copysignf((_powf(_fabs((in.z / pivot)) , contrast) * pivot),(in.z / pivot));}
    
        if (in.z > pivot) {
            in.z = 1 - in.z; 
            pivot = 1 - pivot;
            out.z = _copysignf((_powf(_fabs((in.z / pivot)) , contrast) * pivot),(in.z / pivot));
            out.z = 1 - out.z;
        }
    
    return out;

    }

__DEVICE__ float3 apply_white_point (float3 in, float white_point, float pivot, float shoulder_strength) {

float3 out = in; 
float scale_factor;

if (in.x > pivot) {
    scale_factor = (1.0f - pivot) / _powf(_powf((white_point - pivot) / (1.0f - pivot), -1.0f*shoulder_strength) - 1.0f, 1.0f/shoulder_strength);
    
    out.x = pivot + scale_factor *((in.x - pivot) / scale_factor) / (_powf(1.0f + _powf((in.x - pivot) / scale_factor, shoulder_strength), 1.0f / shoulder_strength));

    }

        else {
           
        out.x = in.x;
        
        }

if (in.y > pivot) {
    scale_factor = (1.0f - pivot) / _powf(_powf((white_point - pivot) / (1.0f - pivot), -1.0f*shoulder_strength) - 1.0f, 1.0f/shoulder_strength);
    
    out.y = pivot + scale_factor *((in.y - pivot) / scale_factor) / (_powf(1.0f + _powf((in.y - pivot) / scale_factor, shoulder_strength), 1.0f / shoulder_strength));

    }

        else {
           
        out.y = in.y;
        
        }

if (in.z > pivot) {
    scale_factor = (1.0f - pivot) / _powf(_powf((white_point - pivot) / (1.0f - pivot), -1.0f*shoulder_strength) - 1.0f, 1.0f/shoulder_strength);
    
    out.z = pivot + scale_factor *((in.z - pivot) / scale_factor) / (_powf(1.0f + _powf((in.z - pivot) / scale_factor, shoulder_strength), 1.0f / shoulder_strength));

    }

        else {
           
        out.z = in.z;
        
        }

    return out;

    }

__DEVICE__ float3 apply_black_point (float3 in, float black_point, float pivot, float toe_str) {

float3 out = in; 

in.x = 1.0f - in.x;
in.y = 1.0f - in.y ;
in.z = 1.0f - in.z ;

float scale_factor;

    if (in.x > pivot) {
    scale_factor = (1.0f - pivot) / _powf(_powf((black_point - pivot) / (1.0f - pivot), -1.0f*toe_str) - 1.0f, 1.0f/toe_str);
    
    out.x = pivot + scale_factor *((in.x - pivot) / scale_factor) / (_powf(1.0f + _powf((in.x - pivot) / scale_factor, toe_str), 1.0f / toe_str));
    }
    
            else {
           
        out.x = in.x;
        
        }
    
    if (in.y > pivot) {

    scale_factor = (1.0f - pivot) / _powf(_powf((black_point - pivot) / (1.0f - pivot), -1.0f*toe_str) - 1.0f, 1.0f/toe_str);
    
    out.y = pivot + scale_factor *((in.y - pivot) / scale_factor) / (_powf(1.0f + _powf((in.y - pivot) / scale_factor, toe_str), 1.0f / toe_str));

    }
    
            else {
           
        out.y = in.y;
        
        }
    
    if (in.z > pivot) {
    scale_factor = (1.0f - pivot) / _powf(_powf((black_point - pivot) / (1.0f - pivot), -1.0f*toe_str) - 1.0f, 1.0f/toe_str);
    
    out.z = pivot + scale_factor *((in.z - pivot) / scale_factor) / (_powf(1.0f + _powf((in.z - pivot) / scale_factor, toe_str), 1.0f / toe_str));

    }
    
            else {
           
        out.z = in.z;
        
        }

 out.x = 1 - out.x;
 out.y = 1 - out.y;
 out.z = 1 - out.z;

return out;

    }

__DEVICE__ float3 apply_highlight_split(float3 in, float strength, float color_mix) {
  float3 out = in;
  float red_strength = ((1 - color_mix) * strength) + 1.f;
  float green_strength = (color_mix * strength) + 1.f;

  out.x = in.x * red_strength;
  out.y = in.y * green_strength;
  out.z = in.z;
  out /= (_fmaxf(red_strength, green_strength));

  return out;
  }

__DEVICE__ float3 apply_shadow_split(float3 in, float strength, float color_mix) {

  float3 out = in;

  in.x = (1 - in.x);
  in.y = (1 - in.y);
  in.z = (1 - in.z);
  
  float green_strength = ((1 - color_mix) * strength) + 1.f;
  float blue_strength = (color_mix * strength) + 1.f;
  
  out.x = in.x;
  out.y = in.y * (1.0f / green_strength);
  out.z = in.z * (1.0f / blue_strength);
  out *= (_fminf(green_strength, blue_strength));

  out.x = (1 - out.x);
  out.y = (1 - out.y);
  out.z = (1 - out.z);
  

  return out;
  }


DEFINE_UI_PARAMS(contrast, Contrast üåì, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 2, 0.001)
DEFINE_UI_PARAMS(pivot, Contrast Pivot üìå, DCTLUI_SLIDER_FLOAT, 0.435, 0.0, 1.0, 0.001)


DEFINE_UI_PARAMS(p_white_point, ‚ö™White Point ‚ö™ :, DCTLUI_SLIDER_FLOAT, 0.999, 0.0, 0.999, 0.1)
DEFINE_UI_PARAMS(p_w_p_pivot, ‚îú Shoulder ‚ÄÄ‚ï≠, DCTLUI_SLIDER_FLOAT, 0.8, 0.4, 1, 0.1)
DEFINE_UI_PARAMS(p_shoulder_str, ‚îî Roll off ‚ï≠ ‚ÄÄ‚ÄÄ, DCTLUI_SLIDER_FLOAT, 2.0, 0.05, 5.0, 0.001)

DEFINE_UI_PARAMS(p_black_point, ‚ö´Black Point ‚ö´ :, DCTLUI_SLIDER_FLOAT, 0.0001, 0.0001, .25, 0.0001)
DEFINE_UI_PARAMS(p_b_p_pivot, ‚îú‚ÄÄToe ‚ÄÄ‚ÄÄ‚ÄÄ‚ÄÄ‚å£‚ÄÄ‚ÄÄ, DCTLUI_SLIDER_FLOAT, 0.2, 0.0, 0.5, 0.001)
DEFINE_UI_PARAMS(p_toe_str, ‚îî Roll off‚ÄÄ  ‚å£ ‚ÄÄ‚ÄÄ, DCTLUI_SLIDER_FLOAT, 2.0, 0.08, 5.0, 0.001)

DEFINE_UI_PARAMS(p_mix_contrast, Linear / S curve: , DCTLUI_SLIDER_FLOAT, 1.0f, 0.0f, 1.0f, 0.1f)

DEFINE_UI_PARAMS(split_strength, Split Tone Strengthüí™, DCTLUI_SLIDER_FLOAT, 0.0, 0.0, 1.0, 0.001)
DEFINE_UI_PARAMS(split_highlight_color_mix, Hi üî¥<--->üü¢, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 1.0, 0.001)
DEFINE_UI_PARAMS(split_shadow_color_mix, Lo üü¢<--->üîµ, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 1.0, 0.001)
DEFINE_UI_PARAMS(bypass, üö´ Bypass, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(bypass_contrast, ‚ÄÄ‚ÄÄ‚ÄÄ‚§∑ Contrast üåì, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(bypass_splittone, ‚ÄÄ‚ÄÄ‚ÄÄ‚§∑ Split toning üî∞, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(opt_showcurve, üìà Show Curve, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(opt_ramp, üìè Show Ramp, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(limiter, üîß Limit input to 0-1, DCTLUI_CHECK_BOX, 0)



__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B) {

    float3 in_RGB = make_float3(p_R, p_G, p_B);



    //create a linear ramp to enable the view graph control
    float width = (float)p_Width;
    float height = (float)p_Height;
    float X = (float)p_X;
    float Y = height - (float)p_Y;
    //Relative X,Y 
    float rY = Y / height;
    float rX = X / width;
    float3 ramp = {rX, rX, rX};


    //scales down the strength slider to limit the effective range to a range that produces pleasing results
    split_strength = split_strength * .2f;
    split_shadow_color_mix = (split_shadow_color_mix * .3f) + .5f;
    split_highlight_color_mix = (split_highlight_color_mix * .3f) + .1f;
    //Limit pivot to above zero value as this caused artifacts
    if( pivot < 0.05f ){ pivot = _fmaxf(pivot,.02f);}

    
    //sanitize black and white points

    p_w_p_pivot = _fminf((p_white_point - 0.01f), p_w_p_pivot );
    p_black_point = 1.0f - p_black_point;
    p_b_p_pivot = _fminf((p_black_point - 0.01f), p_b_p_pivot );
    p_white_point = _fmaxf(p_white_point , 0.5f);
    p_black_point = _fmaxf(p_black_point , 0.8f);
    
    //clamp check box functionality
    if(limiter == 1) {
    in_RGB.x = _clampf(in_RGB.x, 0.f, 1.0f);
    in_RGB.y = _clampf(in_RGB.y, 0.f, 1.0f);
    in_RGB.z = _clampf(in_RGB.z, 0.f, 1.0f);    
    }

    float3 out;
    //bypass option that outputs untouched image when activated
    if (bypass ==1 && bypass_contrast == 1 && bypass_splittone == 1 || bypass ==1 && bypass_contrast == 0 && bypass_splittone == 0) {
        float3 clean = {p_R, p_G, p_B};

    return clean;
    }


    //bypass option limited to the contrast operations
    if (bypass ==1 && bypass_contrast == 0 || bypass == 0 && bypass_contrast == 1 || bypass == 0 && bypass_contrast == 0) {
        //apply contrast operations
    
             float3 lin_contrast = apply_linear_contrastf3 (in_RGB, contrast, pivot);
             float3 ramp_linear = apply_linear_contrastf3 (ramp, contrast, pivot);

             float3 roll_contrast = apply_rolling_contrastf3 (in_RGB, contrast, pivot);
             float3 ramp_rolling = apply_rolling_contrastf3 (ramp, contrast, pivot);

             float3 mix_con = _mix(lin_contrast, roll_contrast, p_mix_contrast);
             float3 mix_ramp = _mix(ramp_linear, ramp_rolling, p_mix_contrast);
    
            float3 White_p = apply_white_point(mix_con, p_white_point, p_w_p_pivot, p_shoulder_str);
            float3 ramp_White_p = apply_white_point(mix_ramp, p_white_point, p_w_p_pivot, p_shoulder_str);

            float3 black_p = apply_black_point(White_p, p_black_point, p_b_p_pivot, p_toe_str);           
            float3 ramp_black_p = apply_black_point(ramp_White_p, p_black_point, p_b_p_pivot, p_toe_str);

            out = black_p;
            ramp = ramp_black_p;
    }

    //applies the split toning inclusindg the bypass functionality
    if (bypass ==1 && bypass_splittone == 0 || bypass == 0 && bypass_splittone == 1 || bypass == 0 && bypass_splittone == 0) {
        out = apply_shadow_split(out, split_strength, split_shadow_color_mix);
        out = apply_highlight_split(out, split_strength, split_highlight_color_mix);
        ramp = apply_shadow_split(ramp, split_strength, split_shadow_color_mix);
        ramp = apply_highlight_split(ramp, split_strength, split_highlight_color_mix);
    }
    
    //option to overlay a grayscale ramp on the bottom edge of the frame
    if (opt_ramp) {

        if( rY < 0.1f) {out = ramp;}

    
    }


    //Optional show curve functionality
    if (opt_showcurve == 1) {
    
        float overlayR = ramp.x >= (Y - 5.0f) / height && ramp.x <= (Y + 5.0f) / height ? 1.0f : 0.0f;
        float overlayG = ramp.y >= (Y - 5.0f) / height && ramp.y <= (Y + 5.0f) / height ? 1.0f : 0.0f;
        float overlayB = ramp.z >= (Y - 5.0f) / height && ramp.z <= (Y + 5.0f) / height ? 1.0f : 0.0f;
        out.x = overlayR == 0.0f ? out.x : overlayR;
        out.y = overlayG == 0.0f ? out.y : overlayG;
        out.z = overlayB == 0.0f ? out.z : overlayB;
            if (rX < pivot+0.002f && rX > pivot- 0.002f) {
                out.x = .6f;
                out.y = .6f;
                out.z = .6f;
            }

                else {
                    if (rX < p_w_p_pivot+0.002f && rX > p_w_p_pivot- 0.002f) {
                    out.x = 0.8f;
                    out.y = 0.1f;
                    out.z = 0.01f;
                        }

                    if (rX < p_b_p_pivot+0.002f && rX > p_b_p_pivot- 0.002f) {
                    out.x = 0.01f;
                    out.y = 0.3f;
                    out.z = 0.7f;
                    }
                }
    }
    


    return out;
}