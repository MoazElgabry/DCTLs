//Flimic Contrast
// Created by Moaz Elgabry on 11 May 2023
//


//functions for Transfer function conversion
__DEVICE__ float3 LinToLogC3 (float3 in) {
    float3 out;

    float cut = 0.010591;
    float a = 5.555556;
    float b = 0.052272;
    float c = 0.247190;
    float d = 0.385537;
    float e = 5.367655;
    float f = 0.092809;

    out.x = (in.x > cut) ? c * log10(a * in.x + b) + d: e * in.x + f;
    out.y = (in.y > cut) ? c * log10(a * in.y + b) + d: e * in.y + f;
    out.z = (in.z > cut) ? c * log10(a * in.z + b) + d: e * in.z + f;

    return out;
    }

__DEVICE__ float3 LogC3ToLin (float3 in) {
    float3 out;

    float cut = 0.010591;
    float a = 5.555556;
    float b = 0.052272;
    float c = 0.247190;
    float d = 0.385537;
    float e = 5.367655;
    float f = 0.092809;

    out.x = (in.x > e * cut + f) ? (_powf(10, (in.x - d) / c) - b) / a : (in.x - f) / e;
    out.y = (in.y > e * cut + f) ? (_powf(10, (in.y - d) / c) - b) / a : (in.y - f) / e;
    out.z = (in.z > e * cut + f) ? (_powf(10, (in.z - d) / c) - b) / a : (in.z - f) / e;

    return out;
    }

__DEVICE__ float3 LinToDI (float3 in) {
    float3 out;

    float a = 0.0075;
    float b = 7.0;
    float c = 0.07329248;
    float m = 10.44426855;
    float lin_cut = 0.00262409;

    out.x = in.x > lin_cut ? (_log2f(in.x + a) + b) * c : out.x = in.x * m;
    out.y = in.y > lin_cut ? (_log2f(in.y + a) + b) * c : out.y = in.y * m;
    out.z = in.z > lin_cut ? (_log2f(in.z + a) + b) * c : out.z = in.z * m;

    return out;
    }

__DEVICE__ float3 DItoLin (float3 in) {
    float3 out;

    float a = 0.0075;
    float b = 7.0;
    float c = 0.07329248;
    float m = 10.44426855;
    float log_cut = 0.02740668;

    out.x = in.x > log_cut ? _powf(2.f, (in.x / c) - b) - a : in.x / m;
    out.y = in.y > log_cut ? _powf(2.f, (in.y / c) - b) - a : in.y / m;
    out.z = in.z > log_cut ? _powf(2.f, (in.z / c) - b) - a : in.z / m;

    return out;
    }

__DEVICE__ float3 LinToACEScct (float3 in) {
    float3 out;

    float a = 10.5402377416545;
    float b = 0.0729055341958355;
    float c = 9.72;
    float d = 17.52;
    float e = 0.0078125;

    out.x = in.x <= e ? a * in.x + b : (_log2f(in.x) + c) / d;
    out.y = in.y <= e ? a * in.y + b : (_log2f(in.y) + c) / d;
    out.z = in.z <= e ? a * in.z + b : (_log2f(in.z) + c) / d;

    return out;
    }

__DEVICE__ float3 ACEScctToLin (float3 in) {
    float3 out;

    float a = 10.5402377416545;
    float b = 0.0729055341958355;
    float c = 9.72;
    float d = 17.52;
    float e = _log2f(65504);
    float lin_cut = 0.155251141552511;

    out.x = in.x <= lin_cut ? (in.x - b) / a : in.x < (e + c) / d ? _powf(2, in.x*d-c) : 65504;
    out.y = in.y <= lin_cut ? (in.y - b) / a : in.y < (e + c) / d ? _powf(2, in.y*d-c) : 65504;
    out.z = in.z <= lin_cut ? (in.z - b) / a : in.z < (e + c) / d ? _powf(2, in.z*d-c) : 65504;

    return out;
    }

__DEVICE__ float3 LinToLogC4 (float3 in) {
    float3 out;

    float a = (_powf(2.0, 18.0) - 16.0) / 117.45;
    float b = (1023.0 - 95.0) / 1023.0;
    float c = 95.0 / 1023.0;
    float s = (7 * _logf(2) * _powf(2.0, 7 - 14 * c / b)) / (a * b);
    float t = (_powf(2.0, 14.0 * (-c / b) + 6.0) - 64.0) / a;

    out.x = in.x < t ? (in.x - t) / s : (_log2f( a * in.x + 64.0) - 6.0) / 14.0 * b + c;
    out.y = in.y < t ? (in.y - t) / s : (_log2f( a * in.y + 64.0) - 6.0) / 14.0 * b + c;
    out.z = in.z < t ? (in.z - t) / s : (_log2f( a * in.z + 64.0) - 6.0) / 14.0 * b + c;

    return out;
    }

__DEVICE__ float3 LogC4ToLin (float3 in) {
    float3 out;

    float a = (_powf(2.0, 18.0) - 16.0) / 117.45;
    float b = (1023.0 - 95.0) / 1023.0;
    float c = 95.0 / 1023.0;
    float s = (7 * _logf(2) * _powf(2.0, 7 - 14 * c / b)) / (a * b);
    float t = (_powf(2.0, 14.0 * (-c / b) + 6.0) - 64.0) / a;

    out.x = in.x < 0.0 ? in.x * s + t : (_powf(2.0, 14.0 * (in.x - c) / b + 6.0) - 64.0) / a;
    out.y = in.y < 0.0 ? in.y * s + t : (_powf(2.0, 14.0 * (in.y - c) / b + 6.0) - 64.0) / a;
    out.z = in.z < 0.0 ? in.z * s + t : (_powf(2.0, 14.0 * (in.z - c) / b + 6.0) - 64.0) / a;

    return out;
    }

__DEVICE__ float3 RGB_to_HSV(float3 RGB) {
    float3 HSV;
    float min = _fminf(_fminf(RGB.x, RGB.y), RGB.z);
    float max = _fmaxf(_fmaxf(RGB.x, RGB.y), RGB.z);
    HSV.z = max;
    float delta = max - min;
    if (max != 0.0f) {
    HSV.y = delta / max;
    } else {
    HSV.y = 0.0f;
    HSV.x = 0.0f;
    return HSV;
    }
    if (delta == 0.0f) {
    HSV.x = 0.0f;
    } else if (RGB.x == max) {
    HSV.x = (RGB.y - RGB.z) / delta;
    } else if (RGB.y == max) {
    HSV.x = 2.0f + (RGB.z - RGB.x) / delta;
    } else {
    HSV.x = 4.0f + (RGB.x - RGB.y) / delta;
    }
    HSV.x *= 1.0f / 6.0f;
    if (HSV.x < 0.0f)
    HSV.x += 1.0f;
    return HSV;
    } //Convert to HSV

__DEVICE__ float3 HSV_to_RGB(float3 HSV) {
    float3 RGB;
    if (HSV.y == 0.0f) {
    RGB.x = RGB.y = RGB.z = HSV.z;
    } else {
    HSV.x *= 6.0f;
    int i = floor(HSV.x);
    float f = HSV.x - i;
    i = (i >= 0) ? (i % 6) : (i % 6) + 6;
    float p = HSV.z * (1.0f - HSV.y);
    float q = HSV.z * (1.0f - HSV.y * f);
    float t = HSV.z * (1.0f - HSV.y * (1.0f - f));
    RGB.x = i == 0 ? HSV.z : i == 1 ? q : i == 2 ? p : i == 3 ? p : i == 4 ? t : HSV.z;
    RGB.y = i == 0 ? t : i == 1 ? HSV.z : i == 2 ? HSV.z : i == 3 ? q : i == 4 ? p : p;
    RGB.z = i == 0 ? p : i == 1 ? p : i == 2 ? t : i == 3 ? HSV.z : i == 4 ? HSV.z : q;
    }
    return RGB;
    } //Convert from HSV to RGB

__DEVICE__ float HSV_sat_mixed (float3 in_1, float3 in_2, float mix_sat) {
    //float3 out = in;
    float3 HSV_1 = in_1;
    float3 HSV_2 = in_2;


    HSV_1 = RGB_to_HSV(in_1);
    HSV_2 = RGB_to_HSV(in_2);
    float clean_sat = HSV_1.y;
    float new_sat = HSV_2.y;
    float saturation = _mix(clean_sat, new_sat, mix_sat);

    return saturation;
    }

//functions to apply transfer function conversions

__DEVICE__ float3 GammaToLin (float3 in, int gamma) {

    if (gamma ==  0) return LogC3ToLin(in);
    if (gamma ==  1) return LogC4ToLin(in);
    if (gamma ==  2) return DItoLin(in);
    if (gamma ==  3) return ACEScctToLin (in);
    return make_float3(0, 0, 1); // Blue on error
    }

__DEVICE__ float3 LinToGamma (float3 in, int gamma) {
    if (gamma ==  0) return LinToLogC3(in);
    if (gamma ==  1) return LinToLogC4(in);
    if (gamma ==  2) return LinToDI(in);
    if (gamma ==  3) return LinToACEScct(in);
    return make_float3(0, 1, 0); // Green on error
    }

__DEVICE__ float set_pivot (float pivot, int gamma) {
    float p_transfer_f = gamma;
    const float logc3_gray = 0.391f;
    const float logc4_gray = 0.278f;
    const float DI_gray = 0.336f;
    const float ACEScct_gray = 0.414f;

    if (p_transfer_f ==  0) { pivot = _clampf(( pivot + logc3_gray), 0.02f, 1.0f);}
    if (p_transfer_f ==  1) { pivot = _clampf(( pivot + logc4_gray), 0.02f, 1.0f);}
    if (p_transfer_f ==  2) { pivot = _clampf(( pivot + DI_gray), 0.02f, 1.0f);}
    if (p_transfer_f ==  3) { pivot = _clampf(( pivot + ACEScct_gray), 0.02f, 1.0f);}
    //else { pivot;}
    return pivot;
    }

//functions for the main functionality of contrast and split toning

__DEVICE__ float3 apply_linear_contrastf3 (float3 in, float contrast, float pivot) {
    
    float3 out = in;
    //offsetting the user slider to set stratingpoints at zero
    contrast = contrast+1.f;
    //limit user input to zero
    if (contrast <0.f) {contrast = _fmaxf(contrast, 0.0f);}

    
    out.x = (in.x - pivot) * contrast + pivot;
    out.y = (in.y - pivot) * contrast + pivot;
    out.z = (in.z - pivot) * contrast + pivot;
    

    return out;
    }

__DEVICE__ float3 apply_rolling_contrastf3 (float3 in, float contrast, float pivot) {
    
    float3 out = in;
    //offsett the user slider to set the starting point at zero instead of 1
    contrast = contrast + 1.f;

    // apply rolling contrast
    if (in.x <= pivot) {out.x = _copysignf((_powf(_fabs((in.x / pivot)) , contrast) * pivot),(in.x / pivot));} 
        if (in.x > pivot) {
            in.x = 1 - in.x; 
            pivot = 1 - pivot;
            out.x = _copysignf((_powf(_fabs((in.x / pivot)) , contrast) * pivot),(in.x / pivot));
            out.x = 1 - out.x;
            pivot = 1 - pivot;
        }

    if (in.y <= pivot ) {out.y = _copysignf((_powf(_fabs((in.y / pivot)) , contrast) * pivot),(in.y / pivot));}
        if (in.y > pivot) {
            in.y = 1 - in.y; 
            pivot = 1 - pivot;
            out.y = _copysignf((_powf(_fabs((in.y / pivot)) , contrast) * pivot),(in.y / pivot));
            out.y = 1 - out.y;
            pivot = 1 - pivot;
        }

    if (in.z <= pivot) {out.z = _copysignf((_powf(_fabs((in.z / pivot)) , contrast) * pivot),(in.z / pivot));}
    
        if (in.z > pivot) {
            in.z = 1 - in.z; 
            pivot = 1 - pivot;
            out.z = _copysignf((_powf(_fabs((in.z / pivot)) , contrast) * pivot),(in.z / pivot));
            out.z = 1 - out.z;
        }
    
    return out;

    }

__DEVICE__ float3 apply_white_point (float3 in, float white_point, float pivot, float shoulder_strength) {

float3 out = in; 
float scale_factor;

if (in.x > pivot) {
    scale_factor = (1.0f - pivot) / _powf(_powf((white_point - pivot) / (1.0f - pivot), -1.0f*shoulder_strength) - 1.0f, 1.0f/shoulder_strength);
    
    out.x = pivot + scale_factor *((in.x - pivot) / scale_factor) / (_powf(1.0f + _powf((in.x - pivot) / scale_factor, shoulder_strength), 1.0f / shoulder_strength));

    }

        else {
           
        out.x = in.x;
        
        }

if (in.y > pivot) {
    scale_factor = (1.0f - pivot) / _powf(_powf((white_point - pivot) / (1.0f - pivot), -1.0f*shoulder_strength) - 1.0f, 1.0f/shoulder_strength);
    
    out.y = pivot + scale_factor *((in.y - pivot) / scale_factor) / (_powf(1.0f + _powf((in.y - pivot) / scale_factor, shoulder_strength), 1.0f / shoulder_strength));

    }

        else {
           
        out.y = in.y;
        
        }

if (in.z > pivot) {
    scale_factor = (1.0f - pivot) / _powf(_powf((white_point - pivot) / (1.0f - pivot), -1.0f*shoulder_strength) - 1.0f, 1.0f/shoulder_strength);
    
    out.z = pivot + scale_factor *((in.z - pivot) / scale_factor) / (_powf(1.0f + _powf((in.z - pivot) / scale_factor, shoulder_strength), 1.0f / shoulder_strength));

    }

        else {
           
        out.z = in.z;
        
        }

    return out;

    }

__DEVICE__ float3 apply_black_point (float3 in, float black_point, float pivot, float toe_str) {

float3 out = in; 

in.x = 1.0f - in.x;
in.y = 1.0f - in.y ;
in.z = 1.0f - in.z ;

float scale_factor;

    if (in.x > pivot) {
    scale_factor = (1.0f - pivot) / _powf(_powf((black_point - pivot) / (1.0f - pivot), -1.0f*toe_str) - 1.0f, 1.0f/toe_str);
    
    out.x = pivot + scale_factor *((in.x - pivot) / scale_factor) / (_powf(1.0f + _powf((in.x - pivot) / scale_factor, toe_str), 1.0f / toe_str));
    }
    
            else {
           
        out.x = in.x;
        
        }
    
    if (in.y > pivot) {

    scale_factor = (1.0f - pivot) / _powf(_powf((black_point - pivot) / (1.0f - pivot), -1.0f*toe_str) - 1.0f, 1.0f/toe_str);
    
    out.y = pivot + scale_factor *((in.y - pivot) / scale_factor) / (_powf(1.0f + _powf((in.y - pivot) / scale_factor, toe_str), 1.0f / toe_str));

    }
    
            else {
           
        out.y = in.y;
        
        }
    
    if (in.z > pivot) {
    scale_factor = (1.0f - pivot) / _powf(_powf((black_point - pivot) / (1.0f - pivot), -1.0f*toe_str) - 1.0f, 1.0f/toe_str);
    
    out.z = pivot + scale_factor *((in.z - pivot) / scale_factor) / (_powf(1.0f + _powf((in.z - pivot) / scale_factor, toe_str), 1.0f / toe_str));

    }
    
            else {
           
        out.z = in.z;
        
        }

 out.x = 1 - out.x;
 out.y = 1 - out.y;
 out.z = 1 - out.z;

return out;

    }

__DEVICE__ float3 apply_highlight_split (float3 in, float strength, float color_mix) {
  float3 out = in;
  float red_strength = ((1 - color_mix) * strength) + 1.f;
  float green_strength = (color_mix * strength) + 1.f;

  out.x = in.x * red_strength;
  out.y = in.y * green_strength;
  out.z = in.z;
  out /= (_fmaxf(red_strength, green_strength));

  return out;
  }

__DEVICE__ float3 apply_shadow_split (float3 in, float strength, float color_mix) {

  float3 out = in;

  in.x = (1 - in.x);
  in.y = (1 - in.y);
  in.z = (1 - in.z);
  
  float green_strength = ((1 - color_mix) * strength) + 1.f;
  float blue_strength = (color_mix * strength) + 1.f;
  
  out.x = in.x;
  out.y = in.y * (1.0f / green_strength);
  out.z = in.z * (1.0f / blue_strength);
  out *= (_fminf(green_strength, blue_strength));

  out.x = (1 - out.x);
  out.y = (1 - out.y);
  out.z = (1 - out.z);
  

  return out;
  }



DEFINE_UI_PARAMS(contrast, Contrast üåì, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 2, 0.001)
DEFINE_UI_PARAMS(pivot, Relative Pivot üìå, DCTLUI_SLIDER_FLOAT, 0.0, -1, 1, 0.001)
DEFINE_UI_PARAMS(P_exposure,  Exposure üåû, DCTLUI_SLIDER_FLOAT, 0.0f, -0.7f, 2.0f, 0.001f)
DEFINE_UI_PARAMS(p_mix_sat, Saturation mix:üñçÔ∏è , DCTLUI_SLIDER_FLOAT, 0.5f, 0.0f, 1.0f, 0.01f)

DEFINE_UI_PARAMS(p_white_point, ‚ö™White Point ‚ö™ :, DCTLUI_SLIDER_FLOAT, 0.999, 0.0, 0.999, 0.0001)
DEFINE_UI_PARAMS(p_w_p_pivot, ‚îú Shoulder ‚ÄÄ‚ï≠, DCTLUI_SLIDER_FLOAT, 0.6, 0.41, 1, 0.1)
DEFINE_UI_PARAMS(p_shoulder_str, ‚îî Fall off ‚ï≠ ‚ÄÄ‚ÄÄ, DCTLUI_SLIDER_FLOAT, 2.0, 0.2, 5.0, 0.001)

DEFINE_UI_PARAMS(p_black_point, ‚ö´Black Point ‚ö´ :, DCTLUI_SLIDER_FLOAT, 0.0001, 0.0001, .25, 0.0001)
DEFINE_UI_PARAMS(p_b_p_pivot, ‚îú‚ÄÄToe ‚ÄÄ‚ÄÄ‚ÄÄ‚ÄÄ‚å£‚ÄÄ‚ÄÄ, DCTLUI_SLIDER_FLOAT, 0.37, 0.0, 0.5, 0.001)
DEFINE_UI_PARAMS(p_toe_str, ‚îî Fall off‚ÄÄ  ‚å£ ‚ÄÄ‚ÄÄ, DCTLUI_SLIDER_FLOAT, 5.0, 0.135, 8.0, 0.001)


DEFINE_UI_PARAMS(p_mix_contrast, Linear / S curve: , DCTLUI_SLIDER_FLOAT, 1.0f, 0.0f, 1.0f, 0.1f)


DEFINE_UI_PARAMS(split_strength, Split Tone Strengthüí™, DCTLUI_SLIDER_FLOAT, 0.0, 0.0, 1.0, 0.001)
DEFINE_UI_PARAMS(split_highlight_color_mix, Hi üî¥<--->üü¢, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 1.0, 0.001)
DEFINE_UI_PARAMS(split_shadow_color_mix, Lo üü¢<--->üîµ, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 1.0, 0.001)
DEFINE_UI_PARAMS(bypass, üö´ Bypass, DCTLUI_CHECK_BOX, 0)
//DEFINE_UI_PARAMS(bypass_exp, ‚ÄÄ‚ÄÄ‚ÄÄ‚§∑ Exposure üåû, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(bypass_contrast, ‚ÄÄ‚ÄÄ‚ÄÄ‚§∑ Contrast üåì, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(bypass_splittone, ‚ÄÄ‚ÄÄ‚ÄÄ‚§∑ Split toning üî∞, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(opt_showcurve, üìà Show Curve, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(opt_ramp, üìè Show Ramp, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(p_transfer_f, Transfer function, DCTLUI_COMBO_BOX, 2, {logc3, logc4, di, aces_cct}, {ARRI LogC3, ARRI LogC4,  DaVinci Intermediate, ACEScct})
//DEFINE_UI_PARAMS(limiter, üîß Limit input to 0-1, DCTLUI_CHECK_BOX, 0)



__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B) {

    float3 in_RGB = make_float3(p_R, p_G, p_B);
    pivot = set_pivot(pivot, p_transfer_f);


    //create a linear ramp to enable the view graph control
    float width = (float)p_Width;
    float height = (float)p_Height;
    float X = (float)p_X;
    float Y = height - (float)p_Y;
    //Relative X,Y 
    float rY = Y / height;
    float rX = X / width;
    float3 ramp = {rX, rX, rX};


    //scales down the strength slider to limit the effective range to a range that produces pleasing results
    split_strength = split_strength * .2f;
    split_shadow_color_mix = (split_shadow_color_mix * .3f) + .5f;
    split_highlight_color_mix = (split_highlight_color_mix * .3f) + .1f;

    //Limit pivot to above zero value as this caused artifacts
    //if( pivot < 0.05f ){ pivot = _fmaxf(pivot,.02f);}

    
    //sanitize black and white points

    p_w_p_pivot = _fmaxf(_fminf((p_white_point - 0.01f), p_w_p_pivot ), 0.15f);
    p_black_point = 1.0f - p_black_point;
    p_b_p_pivot = _fminf((p_black_point - 0.01f), p_b_p_pivot );
    p_white_point = _fmaxf(p_white_point*.5f + 0.49f,0.6f);
    p_white_point = _fmaxf(p_white_point , 0.5f);
    p_black_point = _fmaxf(p_black_point , 0.8f);
    
    //clamp check box functionality
    //if(limiter == 1) {
    //in_RGB.x = _clampf(in_RGB.x, 0.f, 1.0f);
    //in_RGB.y = _clampf(in_RGB.y, 0.f, 1.0f);
    //in_RGB.z = _clampf(in_RGB.z, 0.f, 1.0f);    
    //}

    float3 out;
    float3 clean = {p_R, p_G, p_B};
    //bypass option that outputs untouched image when activated
    if (bypass ==1 && bypass_contrast == 1 && bypass_splittone == 1  || bypass ==1 && bypass_contrast == 0 && bypass_splittone == 0 ) {
        float3 clean = {p_R, p_G, p_B};

    return clean;
    }

    // exposure slider that works in linear
    //if (bypass ==1 && bypass_exp == 0 || bypass == 0 && bypass_exp == 1 || bypass == 0 && bypass_exp == 0 ) {
        P_exposure = P_exposure + 1.0f;
        in_RGB = GammaToLin(in_RGB, p_transfer_f);
        ramp = GammaToLin(ramp, p_transfer_f);

        // Apply linear gain
        in_RGB = in_RGB * P_exposure;
        ramp = ramp * P_exposure;
    
        in_RGB = LinToGamma(in_RGB, p_transfer_f);
        ramp = LinToGamma(ramp, p_transfer_f);
    //}

    //bypass option limited to the contrast operations
    if (bypass ==1 && bypass_contrast == 0 || bypass == 0 && bypass_contrast == 1 || bypass == 0 && bypass_contrast == 0) {
                
                //apply contrast operations
             float3 lin_contrast = apply_linear_contrastf3 (in_RGB, contrast, pivot);
             float3 ramp_linear = apply_linear_contrastf3 (ramp, contrast, pivot);

             float3 roll_contrast = apply_rolling_contrastf3 (in_RGB, contrast, pivot);
             float3 ramp_rolling = apply_rolling_contrastf3 (ramp, contrast, pivot);

             float3 mix_con = _mix(lin_contrast, roll_contrast, p_mix_contrast);
             float3 mix_ramp = _mix(ramp_linear, ramp_rolling, p_mix_contrast);

                //mix back the original saturation channel in HSV to preserve saturation
             float3 mix_con_HSV = RGB_to_HSV(mix_con);
             float get_sat = HSV_sat_mixed (clean, mix_con, p_mix_sat);
             float3 preserve_sat = mix_con_HSV;
             preserve_sat.y = get_sat;
             preserve_sat = HSV_to_RGB(preserve_sat);
                
                //apply compression to the white and black points
            float3 White_p = apply_white_point(preserve_sat, p_white_point, p_w_p_pivot, p_shoulder_str);
            float3 ramp_White_p = apply_white_point(mix_ramp, p_white_point, p_w_p_pivot, p_shoulder_str);

            float3 black_p = apply_black_point(White_p, p_black_point, p_b_p_pivot, p_toe_str);           
            float3 ramp_black_p = apply_black_point(ramp_White_p, p_black_point, p_b_p_pivot, p_toe_str);

            out = black_p;
            ramp = ramp_black_p;
    }

    //applies the split toning inclusindg the bypass functionality
    if (bypass ==1 && bypass_splittone == 0 || bypass == 0 && bypass_splittone == 1 || bypass == 0 && bypass_splittone == 0) {
        out = apply_shadow_split(out, split_strength, split_shadow_color_mix);
        out = apply_highlight_split(out, split_strength, split_highlight_color_mix);
        ramp = apply_shadow_split(ramp, split_strength, split_shadow_color_mix);
        ramp = apply_highlight_split(ramp, split_strength, split_highlight_color_mix);
    }
    
    //option to overlay a grayscale ramp on the bottom edge of the frame
    if (opt_ramp) {

        if( rY < 0.1f) {out = ramp;}

    
    }


    //Optional show curve functionality
    if (opt_showcurve == 1) {
    
        float overlayR = ramp.x >= (Y - 5.0f) / height && ramp.x <= (Y + 5.0f) / height ? 1.0f : 0.0f;
        float overlayG = ramp.y >= (Y - 5.0f) / height && ramp.y <= (Y + 5.0f) / height ? 1.0f : 0.0f;
        float overlayB = ramp.z >= (Y - 5.0f) / height && ramp.z <= (Y + 5.0f) / height ? 1.0f : 0.0f;
        out.x = overlayR == 0.0f ? out.x : overlayR;
        out.y = overlayG == 0.0f ? out.y : overlayG;
        out.z = overlayB == 0.0f ? out.z : overlayB;
            if (rX < pivot+0.002f && rX > pivot- 0.002f) {
                out.x = .6f;
                out.y = .6f;
                out.z = .6f;
            }

                else {
                    if (rX < p_w_p_pivot+0.002f && rX > p_w_p_pivot- 0.002f) {
                    out.x = 0.8f;
                    out.y = 0.1f;
                    out.z = 0.01f;
                        }

                    if (rX < p_b_p_pivot+0.002f && rX > p_b_p_pivot- 0.002f) {
                    out.x = 0.01f;
                    out.y = 0.3f;
                    out.z = 0.7f;
                    }
                }
    }
    
    return out;
}